<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv">

类 PIV对象类 <注释 = "等同于\"扩展对象类\",并导入了<chrono>头文件." 折叠 "@视窗.外部头文件.全局-100" = "<malloc.h>\r\n<chrono>">
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 折叠2 @虚拟方法 = 可覆盖
            @输出名 = "GetDumpString" @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        @ BaseClass::GetDumpString (@<展示内容>, @<最大展示数据尺寸>);
    }

    方法 流读入 <公开 注释 = "从所指定的流对象中读入本对象的数据. 请注意以下事项:" 注释 = "  1. 一旦定义了\"流读入\"方法,必须定义对应的\"流写出\"方法,所读入内容格式与"
            注释 = "\"流写出\"方法写出的内容格式必须完全一致;" 注释 = "  2. 任何类如果既没有定义\"流读入\"方法,也没有定义\"流写出\"方法,编译器会自动"
            注释 = "建立默认的\"流读入\"和\"流写出\"方法,默认方法就是首先调用基础类中的对应方法," 注释 = "然后将本对象中的所有非静态变量成员顺序从流中读入/写出;"
            注释 = "  3. 继承类中如果覆盖了本方法且基础类中也存在数据需要从流中读入,则必须负" 注释 = "责调用基础类中的\"流读入\"方法,调用格式如: \"父对象.流读入 (流对象)\";"
            注释 = "  4. 如果本方法中的读入操作比较复杂或耗时,在之前最好检查一下流对象当前是" 注释 = "否处于出错状态(\"流对象.是否出错\"方法返回真),如果出错则放弃后续的读入操作,"
            注释 = "以提高运行效率;" 注释 = "  5. 在读入过程中一旦发现出错,则需要将对应的错误码写入\"流对象.错误码\"属性"
            注释 = "中(流读入出错不需要,会自动写入),以禁止后续的流读入操作. 错误码可以是" 注释 = "\"流错误码\"类中的常量值,也可以是自行定义的错误码值(必须大于0);"
            注释 = "  6. 流对象一旦处于出错状态(流对象的\"错误码\"属性值不为\"流错误码.无错误\")," 注释 = "则后续所有流读入操作都会失败,如果欲再次使用此流对象,需要首先调用其"
            注释 = "\"清除错误\"方法清除掉流的出错状态或者将流关闭后再打开." 折叠 折叠2 @虚拟方法 = 可覆盖 @输出名 = "@LoadFromStream"
            @视窗.后缀文本 = "override">
    参数 流对象 <类型 = 输入流类 注释 = "提供欲从其中读入本对象数据内容的输入流">

    方法 流写出 <公开 注释 = "将本对象的数据写入所指定的流对象中. 注意:" 注释 = "  1. 一旦定义了\"流写出\"方法,必须定义对应的\"流读入\"方法,所写出内容格式与"
            注释 = "\"流读入\"方法读取的内容格式必须完全一致;" 注释 = "  2. 任何类如果既没有定义\"流读入\"方法,也没有定义\"流写出\"方法,编译器会自动"
            注释 = "建立默认的\"流读入\"和\"流写出\"方法,默认方法就是首先调用基础类中的对应方法," 注释 = "然后将本对象中的所有非静态变量成员顺序从流中读入/写出;"
            注释 = "  3. 继承类中如果覆盖了本方法且基础类中也存在数据需要写出到流中,则必须负" 注释 = "责调用基础类中的\"流写出\"方法,调用格式如: \"父对象.流写出 (流对象)\";"
            注释 = "  4. 如果本方法中的写出操作比较复杂或耗时,在之前最好检查一下流对象当前是" 注释 = "否处于出错状态(\"流对象.是否出错\"方法返回真),如果出错则放弃后续的写出操作,"
            注释 = "以提高运行效率;" 注释 = "  5. 在写出过程中一旦发现出错,则需要将对应的错误码写入\"流对象.错误码\"属性"
            注释 = "中(流写出出错不需要,会自动写入),以禁止后续的流写出操作. 错误码可以是" 注释 = "\"流错误码\"类中的常量值,也可以是自行定义的错误码值(必须大于0);"
            注释 = "  6. 流对象一旦处于出错状态(流对象的\"错误码\"属性值不为\"流错误码.无错误\")," 注释 = "则后续所有流写出操作都会失败,如果欲再次使用此流对象,需要首先调用其"
            注释 = "\"清除错误\"方法清除掉流的出错状态或者将流关闭后再打开." 折叠 折叠2 @虚拟方法 = 可覆盖 @输出名 = "@SaveIntoStream"
            @视窗.后缀文本 = "override">
    参数 流对象 <类型 = 输出流类 注释 = "提供欲将本对象数据内容写出到其中的输出流">
}

类 编译参数类 <公开 注释 = "用于设置MSVC的编译参数" 折叠 @文档 = "category = \"编译参数\"" @禁止创建对象 = 真>
{
    方法 禁用随机基址 <公开 静态 注释 = "禁用随机基址" "@视窗.附加编译参数.release-default" = "link: /DYNAMICBASE:NO">

    方法 禁用数据执行保护 <公开 静态 注释 = "禁用数据执行保护(DEP),只适用于32位程序,64位程序无法禁用DEP." @视窗.附加编译参数 = "link: /NXCOMPAT:NO">

    方法 启用大地址 <公开 静态 注释 = "可以让32位程序处理超过2GB的地址." 注释 = "32位程序默认只能使用2GB内存,启用此参数后可以在64位系统中使用将近4GB的内存."
            注释 = "32位系统则需要设置/3GB的启动参数,让32位程序使用3GB内存." @视窗.附加编译参数.win32 = "link: /LARGEADDRESSAWARE:NO">

    方法 设置校验和 <公开 静态 注释 = "将在.exe文件头中设置校验和" @视窗.附加编译参数.exe = "link: /RELEASE">
}

类 标准异常管理类 <公开 注释 = "用于管理由std标准库抛出的异常." 折叠 @文档 = "category = \"标准库\"" @视窗.外部头文件 = "<exception>" @全局类 = 真>
{
    方法 开始俘获标准异常 <公开 静态 注释 = "开始俘获标准异常,后面需要接着\"俘获标准异常\"." 折叠
            @嵌入式方法 = "name = try_std\r\nhas_body = true\r\nnext = \"catch_std\"">
    {
        @ try
    }

    方法 俘获标准异常 <公开 静态 注释 = "俘获所抛出的标准异常对象,前面需要\"开始俘获标准异常\"." 注释 = "内部可用方法\"取被俘获标准异常\"." 折叠
            @嵌入式方法 = "name = catch_std\r\nhas_body = true\r\nprev = \"try_std\"">
    {
        @ catch (const std::exception& _std_e_catched)
    }

    方法 取被俘获标准异常 <公开 静态 类型 = 文本型 注释 = "获取异常的描述文本,只能在\"俘获标准异常\"方法的子语句体中使用." 折叠
            @嵌入式方法 = "parent=\"catch_std\"">
    {
        @ @an<CVolString> (_std_e_catched.what ())
    }
}

类 结构类辅助 <公开 注释 = "结构类转换到结构体的辅助类." 注释 = "火山的结构类不等于结构体,但结构类内有一个名称为\"S\"的C++结构体," 注释 = "本类可以让结构类和结构体互相转换."
        折叠 @文档 = "category = \"数据处理\"" @禁止创建对象 = 真>
{
    方法 分配 <公开 静态 类型 = 变整数 注释 = "分配一个结构体指针" 返回值注释 = "返回结构体指针,内容为空." 折叠 @嵌入式方法 = "">
    参数 结构类 <注释 = "结构类的实例变量" @匹配类型 = 通用类>
    {
        @ reinterpret_cast<INT_P>(new @pdt<结构类>::S{})
    }

    方法 释放 <公开 静态 注释 = "结构体用完需要手动释放指针,否则会造成内存泄漏." 折叠 @嵌入式方法 = "">
    参数 结构类 <注释 = "结构类的实例变量" @匹配类型 = 通用类>
    参数 结构体指针 <类型 = 变整数 注释 = "欲释放的结构体指针">
    {
        @ delete reinterpret_cast<@pdt<结构类>::S *>(@<结构体指针>)
    }

    方法 写到结构体 <公开 静态 类型 = 变整数 注释 = "将结构类的内容填写到结构体中,然后返回结构体指针." 返回值注释 = "返回结构体指针,已填入结构类的内容." 折叠 @嵌入式方法 = "">
    参数 结构类 <注释 = "结构类的实例变量" @匹配类型 = 通用类>
    参数 结构体指针 <类型 = 变整数 注释 = "结构体的指针,需要提前\"分配\".">
    {
        @ @<结构类>.GetStruct (reinterpret_cast<@pdt<结构类>::S *>(@<结构体指针>))
    }

    方法 取结构体数据 <公开 静态 注释 = "从结构体指针中获取数据,并填写到结构类中." 折叠 @嵌入式方法 = "">
    参数 结构类 <注释 = "结构类的实例变量" @匹配类型 = 通用类>
    参数 结构体指针 <类型 = 变整数 注释 = "结构体的指针">
    {
        @ @<结构类>.SetStruct (reinterpret_cast<@pdt<结构类>::S *>(@<结构体指针>))
    }
}

类 数组P <公开 注释 = "\"数组类辅助操作\"的上位替代,部分参考了\"龙纹\"的\"FP函数扩展\"模块."
        注释 = "本类需要求std:++17,最低VS版本要求为Visual Studio 2017." 折叠 @文档 = "category = \"数组操作\"" @禁止创建对象 = 真
        @视窗.外部头文件 = "src\\piv_array.hpp" @视窗.附加编译参数 = "cpp: /std:c++17" @视窗.需求VS版本 = "15-">
{
    方法 创建数组类 <公开 静态 注释 = "语法糖,快速创建一个任意类型的数组类." 注释 = "例: 整数数组 = 数组P.创建数组类 (整数数组类, 1, 2, 3)" 折叠 @嵌入式方法 = "">
    参数 数组类型 <注释 = "提供所欲创建的数组类型,可以是任意类型的数组类." @匹配类型 = 通用类 @需求类型 = 数据类型 @返回值类型 = 0>
    参数 成员值 <注释 = "提供数组类的初始值,可以连续提供多个成员值." @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::arr::CreateArray<@<数组类型>> (@<成员值>)
    }

    方法 连续加入成员 <公开 静态 注释 = "注意: 数组类的\"加入成员\"已经支持可变参数,本方法已无存在的意义!!!" 注释 = "语法糖,将多个成员值连续加入到一个任意类型的数组类中."
            注释 = "例: 数组P.连续加入成员 (整数数组, 1, 2, 3)" 折叠 @嵌入式方法 = "">
    参数 欲操作的数组 <注释 = "提供所欲连续加入成员的数组类,可以是任意类型的数组类." @匹配类型 = 通用类>
    参数 成员值 <注释 = "提供所欲加入到数组类中的值,可以连续提供多个成员值." @匹配类型 = 通用型 @可扩展 = "">
    {
        @ piv::arr::AddManyValues (@<欲操作的数组>, @<成员值>)
    }

    方法 取对象数组数据 <公开 静态 类型 = 字节集类 注释 = "基于流操作获取指定对象数组类中所有成员的内容数据." 返回值注释 = "返回对象数组数据,如果提供的参数不是对象数组类,将返回空字节集."
            折叠 @嵌入式方法 = "">
    参数 对象数组 <注释 = "提供所欲获取所有成员内容数据的数组类,必须为\"对象数组类\"、" 注释 = "\"字节集数组类\",以及基于\"对象数组模板类\"的自定义数组类." @匹配类型 = 通用类>
    {
        @ piv::arr::SaveObjArrToData (@<对象数组>)
    }

    方法 置对象数组数据 <公开 静态 类型 = 逻辑型 注释 = "基于流操作,将对象数组的内容数据设置到指定的对象数组类中." 返回值注释 = "返回操作是否成功,不论成败,提供的对象数组都会先被清空."
            折叠 @嵌入式方法 = "">
    参数 对象数组 <注释 = "提供所欲设置成员内容数据的数组类,必须为\"对象数组类\"、" 注释 = "\"字节集数组类\",以及基于\"对象数组模板类\"的自定义数组类." @匹配类型 = 通用类>
    参数 数组数据 <类型 = 字节集类 注释 = "本参数用作提供对象数组的所有成员内容数据,该数据必须为" 注释 = "\"数组P.取对象数组数据\"方法返回,否则将导致不可预知的后果.">
    参数 成员类型 <注释 = "本参数提供对象数组类的成员类型名称" @匹配类型 = 通用类 @需求类型 = 数据类型>
    {
        @ piv::arr::LoadObjArrData (@<对象数组>, @<数组数据>, @<成员类型> ())
    }

    方法 取数组前面 <公开 静态 注释 = "将数组类的前N个成员提取到新的数组类中." 返回值注释 = "返回提取的新数组类,类型与欲提取的数组类相同." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组类 <注释 = "所欲提取前N个成员的数组类,可以是任意类型的数组类." @匹配类型 = 通用类 @返回值类型 = 0>
    参数 提取数量 <类型 = 整数 注释 = "所欲提取的成员数量,如果提供的数量大于成员数,将返回原数组." "">
    {
        @ piv::arr::GetArrayFront (@<所欲操作数组类>, @<提取数量>)
    }

    方法 取数组后面 <公开 静态 注释 = "将数组类的后N个成员提取到新的数组类中." 返回值注释 = "返回提取的新数组类,类型与欲提取的数组类相同." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组类 <注释 = "所欲提取后N个成员的数组类,可以是任意类型的数组类." @匹配类型 = 通用类 @返回值类型 = 0>
    参数 提取数量 <类型 = 整数 注释 = "所欲提取的成员数量,如果提供的数量大于成员数,将返回原数组." "">
    {
        @ piv::arr::GetArrayBack (@<所欲操作数组类>, @<提取数量>)
    }

    方法 求和 <公开 静态 注释 = "累加通用基本型数组类中的成员,支持文本相加." 注释 = "使用此方法必须保证数组非空,否则报错." 折叠 @嵌入式方法 = "">
    参数 欲操作的数组 <注释 = "提供所欲操作的数值型和文本型数组类" @匹配类型 = 通用类>
    参数 返回类型 <注释 = "提供数组类的成员类型,同时也是方法返回值的类型." @匹配类型 = 通用基本型 @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ piv::arr::Sum<@<返回类型>> (@<欲操作的数组>)
    }

    方法 求最大值 <公开 静态 注释 = "返回通用基本型数组类中最大的成员值." 注释 = "使用此方法必须保证数组非空,否则报错." 折叠 @嵌入式方法 = "">
    参数 欲操作的数组 <注释 = "提供所欲操作的数值型和文本型数组类" @匹配类型 = 通用类>
    参数 返回类型 <注释 = "提供数组类的成员类型,同时也是返回值的类型." @匹配类型 = 通用基本型 @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ piv::arr::MaxImum<@<返回类型>> (@<欲操作的数组>)
    }

    方法 求最小值 <公开 静态 注释 = "返回通用基本型数组类中最小的成员值." 注释 = "使用此方法必须保证数组非空,否则报错." 折叠 @嵌入式方法 = "">
    参数 欲操作的数组 <注释 = "提供所欲操作的数值型和文本型数组类" @匹配类型 = 通用类>
    参数 返回类型 <注释 = "提供数组类的成员类型,同时也是返回值的类型." @匹配类型 = 通用基本型 @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ piv::arr::MinImum<@<返回类型>> (@<欲操作的数组>)
    }

    方法 展示数组 <公开 静态 类型 = 文本型 注释 = "将一个通用基本型数组类格式化输出." 注释 = "例: 数组P.展示数组 (整数数组)" 注释 = "输出: {1, 2, 3}" 折叠
            @嵌入式方法 = "">
    参数 所欲操作数组类 <注释 = "提供所欲格式化输出的数组类,必须是数值型或文本型数组类." @匹配类型 = 通用类>
    {
        @ piv::arr::FormatArray (@<所欲操作数组类>)
    }
}

类 数组类辅助操作 <公开 注释 = "本类是过时功能,请改用\"数组P\"." 注释 = "  如想使用本类,请在项目属性的编译时预定义宏中添加" 注释 = "PIV_ENABLE_OBSOLETE"
        折叠 @文档 = "category = \"数组操作\"" @全局类 = 真 @编译条件 = "PIV_ENABLE_OBSOLETE">
{
    方法 创建文本型数组类 <公开 静态 类型 = 文本数组类 注释 = "创建一个文本型数组类,并连续加入多个成员." 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 欲添加的数据 <类型 = 文本型 编辑时信息 = "D7FF2, 0, 0, 0" @可扩展 = "d_text = \"); arr.data ().Add (\"">
    {
        @ [] {
        @     @dt<文本数组类> arr;
        @     arr.data ().Add (@<欲添加的数据>);
        @     return arr;
        @ } ()
    }

    方法 创建数值型数组类 <公开 静态 注释 = "创建一个指定基本数值类型的数组类,并连续加入多个成员." 返回值注释 = "返回创建的数组类." 折叠 @嵌入式方法 = "">
    参数 数值类型数组类 <注释 = "  所欲创建的数组类类型,必须为下列基本数值类型的数组类:" 注释 = "  字节数组类、短整数数组类、字符数组类"
            注释 = "  整数数组类、长整数数组类、小数数组类" @匹配类型 = 通用类 @需求类型 = 数据类型 @返回值类型 = 0>
    参数 欲添加的数据 <折叠2 编辑时信息 = "D7FF2, 0, 0, 0" @可扩展 = "d_text = \"); arr.data ().Add (\"" @匹配类型 = 通用基本型>
    {
        @ [] {
        @     @<数值类型数组类> arr;
        @     arr.data ().Add (@<欲添加的数据>);
        @     return arr;
        @ } ()
    }

    方法 数组连续加入字节集 <公开 静态 注释 = "可一次性加入多个成员到字节集数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 字节集数组类>
    参数 值 <类型 = 字节集类 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.Add (v, NULL); }
    }

    方法 数组连续加入对象 <公开 静态 注释 = "可一次性加入多个成员到对象数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 对象数组类>
    参数 值 <类型 = 对象类 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>().Add (v, NULL); }
    }

    方法 数组连续加入字节 <公开 静态 注释 = "可一次性加入多个成员到字节数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 字节数组类>
    参数 值 <类型 = 字节 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入短整数 <公开 静态 注释 = "可一次性加入多个成员到短整数数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 短整数数组类>
    参数 值 <类型 = 短整数 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入字符 <公开 静态 注释 = "可一次性加入多个成员到字符数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 字符数组类>
    参数 值 <类型 = 字符 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入整数 <公开 静态 注释 = "可一次性加入多个成员到整数数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 整数数组类>
    参数 值 <类型 = 整数 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入变整数 <公开 静态 注释 = "可一次性加入多个成员到变整数数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 变整数数组类>
    参数 值 <类型 = 变整数 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入长整数 <公开 静态 注释 = "可一次性加入多个成员到长整数数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 长整数数组类>
    参数 值 <类型 = 长整数 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入小数 <公开 静态 注释 = "可一次性加入多个成员到小数数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 小数数组类>
    参数 值 <类型 = 小数 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入逻辑型 <公开 静态 注释 = "可一次性加入多个成员到逻辑型数组类尾部." 折叠 @嵌入式方法 = "">
    参数 所欲操作数组 <类型 = 逻辑型数组类>
    参数 值 <类型 = 逻辑型 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }

    方法 数组连续加入文本 <公开 静态 注释 = "可一次性加入多个成员到文本数组类尾部." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 所欲操作数组 <类型 = 文本数组类>
    参数 值 <类型 = 文本型 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @<所欲操作数组>.data ().Add (v); }
    }
}

类 文件枚举类 <公开 注释 = "枚举文件和目录,需要带上类名调用." 注释 = "" 折叠 @文档 = "category = \"文件操作\"" @禁止创建对象 = 真>
{
    方法 枚举目录EX <公开 静态 类型 = 整数 注释 = "枚举某个目录下的所有信息." 返回值注释 = "成功返回目录数量,失败返回0." 折叠>
    参数 欲寻找的目录 <类型 = 文本型 注释 = "所欲寻找的文件目录,路径不以反斜杠结尾会自动添加." "">
    参数 目录信息数组 <类型 = 目录信息数组类 注释 = "用于装载目录信息数组的变量,寻找到的信息都放在这个数组类里返回." 注释 = "请确保提供的数组为空.">
    参数 是否遍历子目录 <类型 = 逻辑型 注释 = "是否枚举所有的下级目录,默认不枚举." @默认值 = 假>
    参数 欲跳过文件的属性 <类型 = 整数 注释 = "  参数值可以为\"文件属性\"类中各个常量值的和,用作同时指定多个匹配属性.凡是文件具有本参数中所指定的任"
            注释 = "一属性,则认为其未通过匹配(将其跳过). 本参数优先级在\"欲寻找文件的属性\"参数及\"找到文件\"事件之前."
            注释 = "  默认值6等于\"文件属性.系统文件 + 文件属性.隐藏文件\"." @默认值 = 6>
    {
        变量 查找文件 <类型 = 文件查找类>
        变量 文件名 <类型 = 文本型>
        变量 子目录 <类型 = 文本型>
        变量 目录信息 <类型 = 目录信息类>
        如果 (是否遍历子目录 == 假)
        {
            目录信息数组.删除所有成员 ()

        }
        目录信息.目录路径 = 欲寻找的目录
        检查加入路径字符 (目录信息.目录路径)
        文件名 = 查找文件.寻找文件 (目录信息.目录路径 + "*.*", , 欲跳过文件的属性)
        判断循环 (文本是否为空 (文件名) == 假)
        {
            目录信息.总文件尺寸 = 目录信息.总文件尺寸 + 取文件尺寸 (目录信息.目录路径 + 文件名)
            目录信息.文件数组.加入成员 (文件名)
            全局处理事件 ()
            文件名 = 查找文件.寻找文件 ("", , 欲跳过文件的属性)

        }
        目录信息.文件数量 = 目录信息.文件数组.取成员数 ()
        子目录 = 查找文件.寻找文件 (目录信息.目录路径 + "*", 文件属性.子目录, 欲跳过文件的属性)
        判断循环 (文本是否为空 (子目录) == 假)
        {
            目录信息.子目录数组.加入成员 (子目录)
            全局处理事件 ()
            子目录 = 查找文件.寻找文件 ("", 文件属性.子目录, 欲跳过文件的属性)
        }
        目录信息.子目录数量 = 目录信息.子目录数组.取成员数 ()
        目录信息数组.加入成员 (目录信息)
        如果 (是否遍历子目录)
        {
            子目录 = 查找文件.寻找文件 (目录信息.目录路径 + "*", 文件属性.子目录, 欲跳过文件的属性)
            判断循环 (文本是否为空 (子目录) == 假)
            {
                枚举目录EX (目录信息.目录路径 + 子目录, 目录信息数组, 是否遍历子目录, 欲跳过文件的属性)
                全局处理事件 ()
                子目录 = 查找文件.寻找文件 ("", 文件属性.子目录, 欲跳过文件的属性)

            }
        }
        返回 (目录信息数组.取成员数 ())
    }

    方法 枚举文件 <公开 静态 类型 = 整数 注释 = "通过通配符,枚举某个目录下指定文件名和类型的所有文件." 返回值注释 = "成功返回文件数量,失败返回0." 折叠>
    参数 欲寻找的目录 <类型 = 文本型 注释 = "所欲寻找的文件目录,路径不以反斜杠结尾会自动添加." "">
    参数 欲寻找的文件名 <类型 = 文本型 注释 = "如果寻找全部文件可以填入\"*.*\"，或填\"*.txt\"只找txt文件.">
    参数 文件数组 <类型 = 文本数组类 注释 = "用于装载文件数组的变量,寻找到的文件都放在这个数组里返回." 注释 = "请确保提供的数组为空.">
    参数 是否带路径 <类型 = 逻辑型 注释 = "指定返回的子目录是否带完整路径." @默认值 = 真>
    参数 是否遍历子目录 <类型 = 逻辑型 注释 = "是否枚举所有的下级目录,默认不枚举." @默认值 = 假>
    参数 欲跳过文件的属性 <类型 = 整数 注释 = "  参数值可以为\"文件属性\"类中各个常量值的和,用作同时指定多个匹配属性.凡是文件具有本参数中所指定的任"
            注释 = "一属性,则认为其未通过匹配(将其跳过). 本参数优先级在\"欲寻找文件的属性\"参数及\"找到文件\"事件之前."
            注释 = "  默认值6等于\"文件属性.系统文件 + 文件属性.隐藏文件\"." @默认值 = 6>
    {
        变量 查找文件 <类型 = 文件查找类>
        变量 父目录 <类型 = 文本型>
        变量 找到文件 <类型 = 文本型>
        如果 (是否遍历子目录 == 假)
        {
            文件数组.删除所有成员 ()

        }
        父目录 = 欲寻找的目录
        检查加入路径字符 (父目录)
        找到文件 = 查找文件.寻找文件 (父目录 + 欲寻找的文件名, -1, 欲跳过文件的属性)
        判断循环 (文本是否为空 (找到文件) == 假)
        {
            如果 (是否带路径)
            {
                插入文本 (找到文件, 0, 父目录)

            }
            文件数组.加入成员 (找到文件)
            全局处理事件 ()
            找到文件 = 查找文件.寻找文件 ("", -1, 欲跳过文件的属性)

        }
        如果 (是否遍历子目录)
        {
            找到文件 = 查找文件.寻找文件 (父目录 + "*", 文件属性.子目录, 欲跳过文件的属性)
            判断循环 (文本是否为空 (找到文件) == 假)
            {
                枚举文件 (父目录 + 找到文件, 欲寻找的文件名, 文件数组, 是否带路径, 是否遍历子目录, 欲跳过文件的属性)
                全局处理事件 ()
                找到文件 = 查找文件.寻找文件 ("", 文件属性.子目录, 欲跳过文件的属性)

            }

        }
        返回 (文件数组.取成员数 ())
    }

    方法 枚举子目录 <公开 静态 类型 = 整数 注释 = "取一个文件夹下级子目录.通过是否遍历子目录参数,可以枚举该文件夹的所有子目录." 返回值注释 = "成功返回子目录数量,失败返回0." 折叠>
    参数 父文件夹路径 <类型 = 文本型 注释 = "不需要填写*号,路径不以反斜杠结尾会自动添加.">
    参数 子目录数组 <类型 = 文本数组类 注释 = "保存找到的子目录,请确保提供的数组为空.">
    参数 是否带路径 <类型 = 逻辑型 注释 = "指定返回的子目录是否带完整路径." @默认值 = 真>
    参数 是否遍历子目录 <类型 = 逻辑型 注释 = "是否枚举所有的下级目录,默认不枚举." @默认值 = 假>
    参数 欲跳过文件的属性 <类型 = 整数 注释 = "  参数值可以为\"文件属性\"类中各个常量值的和,用作同时指定多个匹配属性.凡是文件具有本参数中所指定的任"
            注释 = "一属性,则认为其未通过匹配(将其跳过). 本参数优先级在\"欲寻找文件的属性\"参数及\"找到文件\"事件之前."
            注释 = "  默认值6等于\"文件属性.系统文件 + 文件属性.隐藏文件\"." @默认值 = 6>
    {
        变量 查找文件 <类型 = 文件查找类>
        变量 父目录 <类型 = 文本型>
        变量 子目录名 <类型 = 文本型>
        变量 本级子目录列表 <类型 = 文本数组类>
        变量 目录总数 <类型 = 整数>
        变量 子目录数 <类型 = 整数>
        如果 (是否遍历子目录 == 假)
        {
            子目录数组.删除所有成员 ()
        }
        父目录 = 父文件夹路径
        检查加入路径字符 (父目录)
        子目录名 = 查找文件.寻找文件 (父目录 + "*", 文件属性.子目录, 欲跳过文件的属性)
        判断循环 (文本是否为空 (子目录名) == 假)
        {
            本级子目录列表.加入成员 (子目录名)
            如果 (是否带路径)
            {
                插入文本 (子目录名, 0, 父目录)
            }
            子目录数组.加入成员 (子目录名)
            全局处理事件 ()
            子目录名 = 查找文件.寻找文件 ("", 文件属性.子目录, 欲跳过文件的属性)

        }
        子目录数 = 本级子目录列表.取成员数 ()
        目录总数 = 子目录数
        如果 (是否遍历子目录)
        {
            变量 索引 <类型 = 整数>
            循环 (0, 子目录数, 索引, 1)
            {
                目录总数 = 目录总数 + 枚举子目录 (父目录 + 本级子目录列表.取成员 (索引), 子目录数组, 是否带路径, 是否遍历子目录, 欲跳过文件的属性)

            }
        }
        返回 (目录总数)
    }

    方法 是否有子目录 <公开 静态 类型 = 逻辑型 注释 = "判断一个目录下是否有下级子目录." 折叠>
    参数 欲判断目录 <类型 = 文本型 注释 = "所欲判断的目录,目录不以反斜杠结尾会自动添加">
    {
        变量 查找文件 <类型 = 文件查找类>
        变量 父目录 <类型 = 文本型>
        父目录 = 欲判断目录
        检查加入路径字符 (父目录)
        返回 (取反 (文本是否为空 (查找文件.寻找文件 (父目录 + "*", 文件属性.子目录))))
    }
}

类 目录信息类 <公开 基础类 = 扩展对象类 注释 = "\"文件枚举类.枚举目录EX\"返回的信息" 折叠 @文档 = "category = \"文件操作.辅助类\"">
{
    变量 目录路径 <公开 类型 = 文本型>
    变量 子目录数量 <公开 类型 = 整数>
    变量 子目录数组 <公开 类型 = 文本数组类>
    变量 总文件尺寸 <公开 类型 = 长整数>
    变量 文件数量 <公开 类型 = 整数>
    变量 文件数组 <公开 类型 = 文本数组类>

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<目录信息类> 总共 4 个成员:\r\n"
        加入文本 (展示内容, "1. 目录路径: " + 取调试文本2 (最大展示数据尺寸, 目录路径) + "\r\n")
        加入文本 (展示内容, "2. 子目录数量: " + 取调试文本2 (最大展示数据尺寸, 子目录数量) + "\r\n")
        加入文本 (展示内容, "3. 子目录数组: " + 取调试文本2 (最大展示数据尺寸, 子目录数组) + "\r\n")
        加入文本 (展示内容, "4. 总文件尺寸: " + 取调试文本2 (最大展示数据尺寸, 总文件尺寸) + "\r\n")
        加入文本 (展示内容, "5. 文件数量: " + 取调试文本2 (最大展示数据尺寸, 文件数量) + "\r\n")
        加入文本 (展示内容, "6. 文件数组: " + 取调试文本2 (最大展示数据尺寸, 文件数组) + "\r\n")
    }
}

类 目录信息数组类 <公开 基础类 = 对象数组模板类 注释 = "\"文件枚举类.枚举目录EX\"返回的信息" @文档 = "category = \"文件操作.辅助类\""
        @模板实现类 = "目录信息类">

类 数据类型基础类 <公开 基础类 = 扩展对象类 注释 = "本类可以在封装结构体和C++类时作为其基础类,用作提供一些基本的操作功能." 注释 = "注意:"
        注释 = "  1. 本类需要配合 @m<PIV_DECLARE_STRUCT_CLASS>(type) 宏使用,type为所欲封装的结构体或C++类型;"
        注释 = "  2. 所封装的结构体和类必须有默认构造函数;" 注释 = "  3. 本类使用指针存储所封装的数据类型;"
        注释 = "  4. \"是否为参考\"为真时,表示引用了外部指针,赋值的类变量指向同一数据," 注释 = "此时本类不会管理指针的释放,请注意外部指针的生命周期;"
        注释 = "  5. \"是否为参考\"为假时,本类可以复制赋值;" 折叠 @文档 = "category = \"数据处理\"" @视窗.外部头文件 = "<memory>" @禁止创建对象 = 真>
{
    方法 置指针参考 <公开 注释 = "引用外部指针,所引用的指针不由本对象释放,请注意它的生命周期." 注释 = "可以多个对象实例引用同一个指针." 折叠 @嵌入式方法 = "">
    参数 数据指针 <类型 = 变整数 注释 = "必须是所封装C++类型的指针">
    {
        @ @sn<this>.reference(reinterpret_cast<@sn<current_class_def>::DATA_TYPE*>(@<数据指针>))
    }

    方法 复制 <公开 注释 = "将当前的对象数据复制到另一个对象中" 折叠 @嵌入式方法 = "">
    参数 目标对象 <类型 = 数据类型基础类>
    {
        @ @<目标对象>.Copy(@sn<this>.data())
    }

    方法 置指针数据 <公开 注释 = "将所指定指针的数据复制到本类中,本类原来的数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 数据指针 <类型 = 变整数 注释 = "必须是所封装C++类型的指针">
    {
        @ @sn<this>.Copy((@sn<current_class_def>::DATA_TYPE*)@<数据指针>)
    }

    方法 是否为参考 <公开 类型 = 逻辑型 注释 = "返回当前对象是否为参考变量,即所封装的C++类型指针由外部管理." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.is_reference()
    }

    方法 取数据指针 <公开 类型 = 变整数 注释 = "返回所封装C++类型的指针地址,如果指针为空将先进行初始化赋值再返回." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.pdata())
    }

    方法 取数据尺寸 <公开 类型 = 整数 注释 = "返回所封装C++类型的尺寸" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.get_size()
    }

    方法 取数据字节集 <公开 类型 = 字节集类 注释 = "返回所封装C++数据所对应的字节集数据" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.get_bin(CVolMem())
    }
}

类 结构指针基础类 <公开 基础类 = 扩展对象类 注释 = "本类可以在封装结构体和C++类时作为其基础类,用作提供一些基本的操作功能." 注释 = "注意:"
        注释 = "  1. 本类需要配合 @m<PIV_DECLARE_STRUCT_PTR>(type) 宏使用,type为所欲封装的结构体或C++类型;"
        注释 = "  2. 本类主要用于封装没有构造函数的C++类;" 注释 = "  3. 本类使用指针存储所封装的数据类型;"
        注释 = "  4. 本类只能引用外部指针,复制的类变量指向同一数据,且不会管理指针的释放,请注意外部指针的生命周期;"
        注释 = "  5. 本类的数据指针默认为空指针,当你执行赋值、\"置指针参考\"等方法时,才实际拥有数据;" 折叠 @文档 = "category = \"数据处理\"" @禁止创建对象 = 真>
{
    方法 置指针参考 <公开 注释 = "引用外部指针,所引用的指针不由本对象释放,请注意它的生命周期." 注释 = "可以多个对象实例引用同一个指针." 折叠 @嵌入式方法 = "">
    参数 数据指针 <类型 = 变整数 注释 = "必须是所封装C++类型的指针">
    {
        @ @sn<this>.reference ((@sn<current_class_def>::DATA_TYPE*)@<数据指针>)
    }

    方法 取数据指针 <公开 类型 = 变整数 注释 = "返回所封装C++类型的指针地址,如果指针为空则返回0." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.pdata ()
    }

    方法 取数据尺寸 <公开 类型 = 整数 注释 = "返回所封装C++类型的尺寸" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.get_size ()
    }

    方法 取数据字节集 <公开 类型 = 字节集类 注释 = "返回所封装C++数据所对应的字节集数据" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.get_bin (CVolMem ())
    }
}

# @begin
# <> <global>
# <> <include>
# #define PIVDEBUG(format, ...) _DEBUG_STATMENT (DebugTrace (FALSE, 0, 0, _T (format), __VA_ARGS__))
# #define PIV_ARRAY_AND_SIZE(_ARR)  (_ARR), sizeof(_ARR) / sizeof(*(_ARR))
# #define PIV_MEM_PTR_AND_SIZE(_MEM)  (_MEM).GetPtr(), (_MEM).GetSize()
# #define PIV_TEXT_AND_SIZE(_STR)  (_STR).GetText(), (_STR).GetLength()
# #define PIV_GET_GLOBAL_OBJ(_OBJ_TYPE)  dynamic_cast<_OBJ_TYPE&>(g_objVolApp.GetRefGlobalObject (VOL_RUNTIME_CLASS (_OBJ_TYPE)))
# namespace piv
# {
#     // 取基本数据封装类的值指针,空对象时返回nullptr
#     template <typename T = void*>
#     T GetBaseDataPtr(CVolBaseDataType& data) {
#         return data.IsNullObject() ? nullptr : reinterpret_cast<T>(data.GetDataPtr());
#     }
#     // 取文本指针,文本为空时返回nullptr
#     static const wchar_t* GetText(CVolString& str) { return str.IsEmpty() ? nullptr : str.GetText(); }
#     // 强制指针类型转换
#     template <typename dst_type, typename src_type>
#     dst_type pointer_cast(src_type src) {
#         return *static_cast<dst_type*>(static_cast<void*>(&src));
#     }
# } // namespace piv
# // 基于火山内部内存池实现的缓存类
# template <typename T = BYTE>
# class PivBuffer
# {
# private:
#     T *p = nullptr; INT_P size = 0;
# public:
#     PivBuffer() {}
#     ~PivBuffer() { Free(); }
#     // 带参构造(成员数, 是否清零)
#     PivBuffer(INT_P npSize, bool zero = true) { Alloc(npSize); }
#     // 分配缓存(成员数, 是否清零)
#     T* Alloc(INT_P npSize, bool zero = true) {
#         size = npSize * sizeof(T);
#         if (!p)
#             p = reinterpret_cast<T*>(g_objVolApp.GetPoolMem()->Alloc(size));
#         else
#             p = reinterpret_cast<T*>(g_objVolApp.GetPoolMem()->Realloc((void*)p, size));
#         if (zero) memset(p, 0, size);
#         return p;
#     }
#     // 重分配缓存(新成员数, 是否清零)
#     inline T* Realloc(INT_P npNewSize, bool zero = true) {
#         size = npNewSize * sizeof(T);
#         p = reinterpret_cast<T*>(g_objVolApp.GetPoolMem()->Realloc((void*)p, size));
#         if (zero) memset(p, 0, size);
#         return p;
#     }
#     // 释放缓存
#     inline void Free() { if (p) g_objVolApp.GetPoolMem()->Free((void*)p); size = 0; }
#     // 取指针
#     inline T* GetPtr() { return p; }
#     // 取指定类型指针
#     template <typename R = T>
#     inline R* Get() { return reinterpret_cast<R*>(p); }
#     // 取字节长度
#     inline INT_P GetSize() { return size; }
#     // 取成员数
#     inline INT_P GetCount() { return size / sizeof(T); }
#     // 取成员(索引)
#     T& At(INT_P pos) { return p[pos]; }
#     T* operator*() { return p; }
#     T& operator[](INT_P pos) { return p[pos]; }
# }; // PivBuffer
# <> </include>
# <> </global>
#
# // 用作快捷封装带参考的C++类  class_data_type: 所封装的数据类型
# @def_macro PIV_DECLARE_BASE_CLASS(class_data_type)  \
# <>     <include>  \
#     using DATA_TYPE = class_data_type;  \
#     std::unique_ptr<DATA_TYPE> m_ptr = nullptr;  \
#     bool m_ref = false;  \
#     @sn<current_class>(const DATA_TYPE& rhs) { m_ptr.reset(new DATA_TYPE{}); *m_ptr = rhs; m_ref = false; }  \
#     @sn<current_class>(DATA_TYPE&& rhs) { m_ptr.reset(new DATA_TYPE{}); *m_ptr = std::move(rhs); m_ref = false; }  \
#     @sn<current_class>(DATA_TYPE* rhs) { m_ptr.reset(rhs); m_ref = true; }  \
#     @sn<current_class>(const DATA_TYPE* rhs) { m_ptr.reset(new DATA_TYPE{}); *m_ptr = *rhs; m_ref = false; }  \
#     inline @sn<current_class>& operator=(const DATA_TYPE& rhs) {  \
#         if (m_ref) { m_ptr.release(); m_ptr.reset(new DATA_TYPE{}); }  \
#         *m_ptr = rhs; m_ref = false; return *this;  \
#     }  \
#     inline @sn<current_class>& operator=(DATA_TYPE&& rhs) {  \
#         if (m_ref) { m_ptr.release(); m_ptr.reset(new DATA_TYPE{}); }  \
#         *m_ptr = std::move(rhs); m_ref = false; return *this;  \
#     }  \
#     inline @sn<current_class>& operator=(DATA_TYPE* rhs) {  \
#         if (m_ref) { m_ptr.release(); }  \
#         m_ptr.reset(rhs); m_ref = true; return *this;  \
#     }  \
#     inline @sn<current_class>& operator=(const DATA_TYPE* rhs) {  \
#         if (m_ref) { m_ptr.release(); m_ptr.reset(new DATA_TYPE{}); }  \
#         *m_ptr = *rhs; m_ref = false; return *this;  \
#     }  \
#     inline @sn<current_class>& operator=(@sn<current_class>&& rhs) {  \
#         if (m_ref) { m_ptr.release(); }  \
#         m_ptr = std::move(rhs.m_ptr); m_ref = rhs.m_ref;  \
#         return *this;  \
#     }  \
#     inline void @an<_OnInitExtra>() { if(!m_ptr) m_ptr.reset(new DATA_TYPE{}); }  \
#     inline void @an<_OnCleanupExtra>() { if(m_ref) { m_ptr.release(); } }  \
#     inline void @an<_CopySelfFromExtra>(const @sn<current_class>& objCopyFrom) {  \
#         if (m_ref) { m_ptr.release(); } m_ref = objCopyFrom.m_ref;  \
#         if (objCopyFrom.m_ref) {  \
#             m_ptr.reset(const_cast<DATA_TYPE*>(objCopyFrom.pdata()));  \
#         } else {  \
#             m_ptr.reset(new DATA_TYPE{}); *m_ptr = objCopyFrom.data();  \
#         }  \
#     }  \
#     inline DATA_TYPE& data() { return *m_ptr; }  \
#     inline const DATA_TYPE& data() const { return *m_ptr; }  \
#     inline DATA_TYPE* pdata() { return m_ptr.get(); }  \
#     inline const DATA_TYPE* pdata() const { return m_ptr.get(); }  \
#     inline operator DATA_TYPE&() { return data(); }  \
#     inline operator const DATA_TYPE&() const { return data(); }  \
#     inline operator DATA_TYPE*() { return pdata(); }  \
#     inline operator const DATA_TYPE*() const { return pdata(); }  \
# <>     </include>
#
# // 用作快捷封装带参考的结构体和C++类  struct_data_type: 所封装的数据类型
# @def_macro PIV_DECLARE_STRUCT_CLASS(struct_data_type)  \
#     @m<PIV_DECLARE_BASE_CLASS> (struct_data_type)  \
# <>     <include>  \
#     @sn<current_class>(DATA_TYPE& rhs) { m_ptr.reset(&rhs); m_ref = true; }  \
#     inline void reference(DATA_TYPE* rhs) { if (m_ref) { m_ptr.release(); } m_ptr.reset(rhs); m_ref = true; }  \
#     inline @sn<current_class>& Copy(const DATA_TYPE& rhs) {  \
#         if (m_ref) { m_ptr.release(); m_ptr.reset(new DATA_TYPE{}); m_ref = false; }  \
#         *m_ptr = rhs; return *this;  \
#     }  \
#     inline @sn<current_class>& Copy(const DATA_TYPE* rhs) {  \
#         if (m_ref) { m_ptr.release(); m_ptr.reset(new DATA_TYPE{}); m_ref = false; }  \
#         *m_ptr = *rhs; return *this;  \
#     }  \
#     inline DATA_TYPE* GetPtr() { return IsNullObject () ? nullptr : m_ptr.get(); }  \
#     inline const DATA_TYPE* GetPtr() const { return IsNullObject () ? nullptr : m_ptr.get(); }  \
#     inline BOOL is_reference() const { return m_ref; };  \
#     inline INT get_size() const { return static_cast<INT>(sizeof(DATA_TYPE)); }  \
#     inline CVolMem& get_bin (CVolMem& memBuf) { memBuf.CopyFrom(m_ptr.get(), sizeof(DATA_TYPE)); return memBuf; }  \
# <>     </include>
#
# // 结构指针基础类
# @def_macro PIV_DECLARE_STRUCT_PTR(DATA_TYPE)  \
# <>     <include>  \
#     DATA_TYPE* m_ptr = nullptr;  \
#     @sn<current_class>(DATA_TYPE* rhs) { m_ptr = rhs; }  \
#     void @an<_CopySelfFromExtra>(const @sn<current_class>& objCopyFrom)  { m_ptr = objCopyFrom.m_ptr; }  \
#     inline BOOL @an<_IsSelfEqualExtra>(const @sn<current_class>& objCompare) const { return m_ptr == objCompare.m_ptr; }  \
#     inline @sn<current_class>& operator=(@sn<current_class>&& rhs) {  \
#         m_ptr = std::move(rhs.m_ptr);  \
#         return *this;  \
#     }  \
#     inline void reference(DATA_TYPE* pData) { m_ptr = m_ptr; }  \
#     inline DATA_TYPE& data() { return *m_ptr; }  \
#     inline const DATA_TYPE& data() const { return *m_ptr; }  \
#     inline DATA_TYPE* pdata() { return m_ptr; }  \
#     inline const DATA_TYPE* pdata() const { return m_ptr; }  \
#     inline operator DATA_TYPE&() { return *m_ptr; }  \
#     inline operator DATA_TYPE*() { return m_ptr; }  \
#     inline INT get_size() const { return static_cast<INT>(sizeof(DATA_TYPE)); }  \
#     inline CVolMem& get_bin(CVolMem& memBuf) { if (m_ptr) { memBuf.CopyFrom(m_ptr, sizeof(DATA_TYPE)); } return memBuf; }  \
# <>     </include>
# @end
