<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "文本操作" 注释 = "https://github.com/SaierMe/piv" "">

# 文本处理 ====

类 文本P <公开 注释 = "一些文本操作相关的辅助方法(通过类名调用)" 折叠 @禁止创建对象 = 真 @文档 = "category = \"文本操作\""
        @视窗.外部头文件 = "src\\piv_encoding.hpp">
{
    方法 文本逻辑比较 <公开 静态 类型 = 整数 注释 = "比较两个文本,返回逻辑比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "" @视窗.外部头文件 = "shlwapi.h"
            @视窗.外部库 = "Shlwapi.lib">
    参数 所欲操作的文本 <类型 = 文本型>
    参数 所欲比较的文本 <类型 = 文本型 注释 = "提供所欲比较的文本">
    {
        @ StrCmpLogicalW (@<所欲操作的文本>.GetText (), @<所欲比较的文本>.GetText ())
    }

    方法 多字节数组到文本 <公开 静态 类型 = 文本型 注释 = "将ANSI编码的字节数组转换为火山的文本型." 折叠 @嵌入式方法 = "">
    参数 多字节数组 <类型 = "字节 []" 注释 = "必须是带结束零字符的字节数组">
    {
        @ *PivA2Ws {reinterpret_cast<const char *>(@<多字节数组>)}
        // @ @an<CVolString> (GetWideText ((const CHAR*)@<多字节数组>, CVolMem (), NULL))
    }

    方法 UTF8指针到文本 <公开 静态 类型 = 文本型 注释 = "将UTF-8的文本指针转换为火山的文本型." 折叠 @嵌入式方法 = "">
    参数 UTF8文本指针 <类型 = 变整数 注释 = "必须是带结束零字符的UTF8文本指针">
    {
        @ *PivU2Ws {reinterpret_cast<const char *>(@<UTF8文本指针>)}
        // @ @an<CVolString> (Utf8ToWStr ((const U8CHAR*)@<UTF8文本指针>, -1, CVolMem ()))
    }

    方法 UTF8字节数组到文本 <公开 静态 类型 = 文本型 注释 = "将UTF-8编码的字节数组转换为火山的文本型." 折叠 @嵌入式方法 = "">
    参数 UTF8字节数组 <类型 = "字节 []" 注释 = "必须是带结束零字符的字节数组">
    {
        @ *PivU2Ws {reinterpret_cast<const char *>(@<UTF8字节数组>)}
        // @ @an<CVolString> (Utf8ToWStr ((const U8CHAR*)@<UTF8字节数组>, -1, CVolMem ()))
    }

    方法 取所有中间文本 <公开 静态 类型 = 文本数组类 注释 = "(过时)获取所有两段文本中间的内容" 返回值注释 = "返回所获取的文本数组" 折叠>
    参数 文本数据 <类型 = 文本型 注释 = "所欲取中间文本的数据">
    参数 开始文本 <类型 = 文本型 注释 = "中间文本前面的内容,不会出现在结果中.">
    参数 结束文本 <类型 = 文本型 注释 = "中间文本后面的内容,不会出现在结果中.">
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    {
        变量 结果数组 <类型 = 文本数组类>
        变量 开始文本长度 <类型 = 整数>
        变量 结束文本长度 <类型 = 整数>
        变量 开始位置 <类型 = 整数 值 = 0>
        变量 结束位置 <类型 = 整数 值 = 0>
        开始文本长度 = 取文本长度 (开始文本)
        结束文本长度 = 取文本长度 (结束文本)
        判断循环 (真)
        {
            开始位置 = 寻找文本 (文本数据, 开始文本, 结束位置, 是否不区分大小写)
            如果 (开始位置 == -1)
            {
                跳出循环
            }
            开始位置 = 开始位置 + 开始文本长度
            结束位置 = 寻找文本 (文本数据, 结束文本, 开始位置, 是否不区分大小写)
            如果 (结束位置 == -1)
            {
                跳出循环
            }
            结果数组.加入成员 (取文本中间 (文本数据, 开始位置, 结束位置 - 开始位置))
            开始位置 = 结束位置 + 结束文本长度

        }
        返回 (结果数组)
    }

    方法 取所有中间文本Ex <公开 静态 类型 = 整数 注释 = "获取所有两段文本中间的内容" 返回值注释 = "中间文本的数量" 折叠>
    参数 文本数据 <类型 = 文本型 注释 = "所欲取中间文本的数据">
    参数 结果数组 <类型 = 文本数组类 注释 = "返回所获取的文本数组">
    参数 开始文本 <类型 = 文本型 注释 = "中间文本前面的内容,不会出现在结果中.">
    参数 结束文本 <类型 = 文本型 注释 = "中间文本后面的内容,不会出现在结果中.">
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 忽略空白结果 <类型 = 逻辑型 注释 = "是否忽略空白的中间文本,不加入到结果数组." @默认值 = 真>
    {
        变量 开始文本长度 <类型 = 整数>
        变量 结束文本长度 <类型 = 整数>
        变量 开始位置 <类型 = 整数 值 = 0>
        变量 结束位置 <类型 = 整数 值 = 0>
        变量 中间文本 <类型 = 文本型>
        结果数组.删除所有成员 ()
        开始文本长度 = 取文本长度 (开始文本)
        结束文本长度 = 取文本长度 (结束文本)
        判断循环 (真)
        {
            开始位置 = 寻找文本 (文本数据, 开始文本, 结束位置, 是否不区分大小写)
            如果 (开始位置 == -1)
            {
                跳出循环
            }
            开始位置 = 开始位置 + 开始文本长度
            结束位置 = 寻找文本 (文本数据, 结束文本, 开始位置, 是否不区分大小写)
            如果 (结束位置 == -1)
            {
                跳出循环
            }
            中间文本 = 取文本中间 (文本数据, 开始位置, 结束位置 - 开始位置)
            如果 (文本是否为空 (中间文本) == 假 || 忽略空白结果 == 假)
            {
                结果数组.加入成员 (中间文本)
            }
            开始位置 = 结束位置 + 结束文本长度
        }
        返回 (结果数组.取成员数 ())
    }

    方法 取子文本中间 <公开 静态 类型 = 文本型 注释 = "取出两段文本中间的内容" 折叠 "">
    参数 文本内容 <类型 = 文本型 注释 = "所欲取文本中间的原始文本">
    参数 开始文本 <类型 = 文本型 注释 = "提供所欲查找的开始文本内容">
    参数 结束文本 <类型 = 文本型 注释 = "提供所欲查找的结束文本内容">
    参数 起始搜寻位置 <类型 = 整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        变量 开始位置 <类型 = 整数>
        开始位置 = 寻找文本 (文本内容, 开始文本, 起始搜寻位置, 是否不区分大小写)
        如果 (开始位置 == -1)
        {
            返回 (选择 (失败返回原文本, 文本内容, ""))
        }
        起始搜寻位置 = 开始位置 + 取文本长度 (开始文本)
        变量 结束位置 <类型 = 整数>
        结束位置 = 寻找文本 (文本内容, 结束文本, 起始搜寻位置, 是否不区分大小写)
        如果 (结束位置 == -1)
        {
            返回 (选择 (失败返回原文本, 文本内容, ""))
        }
        如果 (是否包含开始文本 == 假)
        {
            开始位置 = 起始搜寻位置
        }
        返回 (取文本中间 (文本内容, 开始位置, 结束位置 - 开始位置 + 选择 (是否包含结束文本, 取文本长度 (结束文本), 0)))
    }

    方法 取子文本左边 <公开 静态 类型 = 文本型 注释 = "寻找文本,然后取出找到的文本左边的内容." 折叠 "">
    参数 被查找的文本 <类型 = 文本型>
    参数 要查找的文本 <类型 = 文本型>
    参数 起始搜寻位置 <类型 = 整数 @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "默认为从左到右找,真为从右往左找." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        变量 找到的位置 <类型 = 整数>
        如果 (是否反向查找 == 真)
        {
            找到的位置 = 倒找文本 (被查找的文本, 要查找的文本, 选择 (起始搜寻位置 == 0, -1, 起始搜寻位置), 是否不区分大小写)
        }
        否则
        {
            找到的位置 = 寻找文本 (被查找的文本, 要查找的文本, 起始搜寻位置, 是否不区分大小写)
        }
        如果 (找到的位置 != -1)
        {
            返回 (取文本左边 (被查找的文本, 找到的位置))
        }
        否则
        {
            返回 (选择 (失败返回原文本, 被查找的文本, ""))

        }
    }

    方法 取子文本右边 <公开 静态 类型 = 文本型 注释 = "寻找文本,然后取出找到的文本右边的内容." 折叠 "">
    参数 被查找的文本 <类型 = 文本型 "">
    参数 要查找的文本 <类型 = 文本型>
    参数 起始搜寻位置 <类型 = 整数 @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "默认为从左到右找,真为从右往左找." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到就返回原文本,默认为返回空文本." @默认值 = 假>
    {
        变量 找到的位置 <类型 = 整数>
        如果 (是否反向查找 == 真)
        {
            找到的位置 = 倒找文本 (被查找的文本, 要查找的文本, 选择 (起始搜寻位置 == 0, -1, 起始搜寻位置), 是否不区分大小写)
        }
        否则
        {
            找到的位置 = 寻找文本 (被查找的文本, 要查找的文本, 起始搜寻位置, 是否不区分大小写)
        }
        如果 (找到的位置 != -1)
        {
            返回 (取文本右边 (被查找的文本, 取文本长度 (被查找的文本) - 找到的位置 - 取文本长度 (要查找的文本)))
        }
        否则
        {
            返回 (选择 (失败返回原文本, 被查找的文本, ""))

        }
    }

    方法 取随机文本 <公开 静态 类型 = 文本型 注释 = "获取指定类型的随机文本" 返回值注释 = "成功返回指定字符数的随机文本,失败返回空文本." 折叠 @禁止流程检查 = 真>
    参数 欲取字符数 <类型 = 整数 注释 = "要取的字符个数">
    参数 字符类型 <类型 = 整数 注释 = "为以下数值相加值或位或值,默认为1+2+4;" 注释 = "  1、数字;" 注释 = "  2、小写字母;" 注释 = "  4、大写字母;"
            注释 = "  8、特殊符号;" @默认值 = 7>
    {
        @ TCHAR Buffer[96] { 0 };
        @ if ((@<字符类型> & 1) == 1) wcscat (Buffer, L"0123456789");
        @ if ((@<字符类型> & 2) == 2) wcscat (Buffer, L"abcdefghijklmnopqrstuvwxyz");
        @ if ((@<字符类型> & 4) == 4) wcscat (Buffer, L"ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        @ if ((@<字符类型> & 8) == 8) wcscat (Buffer, L" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~");
        @ size_t Offset = wcslen (Buffer) - 1;
        @ if (Offset <= 0) return _CT ("");
        @ CVolString szStr;
        @ wchar_t* pStr = szStr.InitWithChars (@<欲取字符数>, ' ');
        @ for (INT i = 0; i < @<欲取字符数>; i++) {
        @     pStr[i] = Buffer[randint (0, Offset)];
        @ }
        @ return szStr;
    }
}

类 文本处理类 <公开 注释 = "一些文本操作相关的全局辅助方法" 注释 = "" 折叠 @文档 = "category = \"文本操作\"" @全局类 = 真 @禁止创建对象 = 真>
{
    方法 创建文本对象W <公开 静态 类型 = 标准文本类 注释 = "通过字符串字面量创建一个UTF-16LE编码文本对象." 注释 = "本方法不会产生文本编码转换."
            返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<标准文本类> {L@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 创建文本对象U <公开 静态 类型 = 标准文本类U 注释 = "通过字符串字面量创建一个UTF-8编码文本对象." 注释 = "本方法不会产生文本编码转换."
            返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<标准文本类U> {u8@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 创建文本对象A <公开 静态 类型 = 标准文本类A 注释 = "通过字符串字面量创建一个ANSI多字节编码文本对象." 注释 = "本方法不会产生文本编码转换."
            返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<标准文本类A> {@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 创建文本视图W <公开 静态 类型 = 文本视图类 注释 = "创建一个UTF-16LE编码的文本视图,并将它指向填入的字符串字面量." 注释 = "本方法不会产生文本复制和文本编码转换."
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类> {L@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 创建文本视图U <公开 静态 类型 = 文本视图类U 注释 = "创建一个UTF-8编码的文本视图,并将它指向填入的字符串字面量." 注释 = "本方法不会产生文本复制和文本编码转换."
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类U> {u8@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 创建文本视图A <公开 静态 类型 = 文本视图类A 注释 = "创建一个ANSI多字节编码的文本视图,并将它指向填入的字符串字面量." 注释 = "本方法不会产生文本复制和文本编码转换."
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类A> {@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    # ====
    # 如需使用以下的过时功能,请在项目属性的编译时预定义宏中添加 PIV_ENABLE_OBSOLETE
    # ====

    方法 版本号比较 <公开 静态 类型 = 整数 注释 = "请改用\"文本P.文本逻辑比较\"." 注释 = "比较两个软件版本号,能正确返回12>2(默认的文本比较是12<2)."
            返回值注释 = "版本一大于版本二返回1,版本一等于版本二返回0,版本一小于版本二返回-1." 折叠 @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 版本一 <类型 = 文本型 注释 = "可以是任意形式的版本号,请填写正确的分隔符.">
    参数 版本二 <类型 = 文本型 注释 = "比较的两个版本号格式应当一致">
    参数 分隔符 <类型 = 文本型 注释 = "可以是多个字符的集合,提供空文本表示不分隔." @默认值 = ".-">
    {
        如果 (版本一 == 版本二)
        {
            返回 (0)
        }
        如果 (文本是否为空 (版本一) == 真)
        {
            返回 (-1)
        }
        如果 (文本是否为空 (版本二) == 真)
        {
            返回 (1)
        }
        变量 子版本一 <类型 = 文本数组类>
        变量 子版本二 <类型 = 文本数组类>
        变量 子数量一 <类型 = 整数>
        变量 子数量二 <类型 = 整数>
        子数量一 = 分割文本 (版本一, 分隔符, 子版本一)
        子数量二 = 分割文本 (版本二, 分隔符, 子版本二)
        变量 较大值 <类型 = 整数>
        变量 较小值 <类型 = 整数>
        变量 版本文本一 <类型 = 文本型>
        变量 版本文本二 <类型 = 文本型>
        变量 分隔符二 <类型 = 文本型>
        置文本预分配字符数 (版本文本一, 取文本长度 (版本一) * 2)
        置文本预分配字符数 (版本文本二, 取文本长度 (版本一) * 2)
        如果 (取文本长度 (分隔符) > 1)
        {
            分隔符二 = 取文本左边 (分隔符, 1)
        }
        否则
        {
            分隔符二 = 分隔符
        }
        较大值 = 取较大值 (子数量一, 子数量二)
        较小值 = 取较小值 (子数量一, 子数量二)
        // 第一组
        版本文本一 = 子版本一.取成员 (0)
        版本文本二 = 子版本二.取成员 (0)
        如果 (取文本长度 (版本文本一) > 取文本长度 (版本文本二))
        {
            版本文本二 = 取重复文本 ("0", 取文本长度 (版本文本一) - 取文本长度 (版本文本二)) + 版本文本二
        }
        否则 (取文本长度 (版本文本一) < 取文本长度 (版本文本二))
        {
            版本文本一 = 取重复文本 ("0", 取文本长度 (版本文本二) - 取文本长度 (版本文本一)) + 版本文本一
        }
        // 第二至N组
        变量 索引 <类型 = 整数>
        循环 (1, 较大值, 索引, 1)
        {
            变量 文本一 <类型 = 文本型>
            变量 文本二 <类型 = 文本型>
            如果 (索引 < 较小值)
            {
                变量 长度一 <类型 = 整数>
                变量 长度二 <类型 = 整数>
                文本一 = 子版本一.取成员 (索引)
                文本二 = 子版本二.取成员 (索引)
                长度一 = 取文本长度 (文本一)
                长度二 = 取文本长度 (文本二)
                如果 (长度一 == 长度二)
                {
                    加入文本 (版本文本一, 分隔符二 + 文本一)
                    加入文本 (版本文本二, 分隔符二 + 文本二)
                }
                否则 (长度一 > 长度二)
                {
                    加入文本 (版本文本一, 分隔符二 + 文本一)
                    加入文本 (版本文本二, 分隔符二 + 取重复文本 ("0", 长度一 - 长度二) + 文本二)
                }
                否则 (长度一 < 长度二)
                {
                    加入文本 (版本文本一, 分隔符二 + 取重复文本 ("0", 长度二 - 长度一) + 文本一)
                    加入文本 (版本文本二, 分隔符二 + 文本二)
                }
            }
            否则
            {
                如果 (较大值 == 子数量一)
                {
                    文本一 = 子版本一.取成员 (索引)
                    加入文本 (版本文本一, 分隔符二 + 文本一)
                    加入文本 (版本文本二, 分隔符二 + 取重复文本 ("0", 取文本长度 (文本一)))
                }
                否则
                {
                    文本二 = 子版本二.取成员 (索引)
                    加入文本 (版本文本一, 分隔符二 + 取重复文本 ("0", 取文本长度 (文本二)))
                    加入文本 (版本文本二, 分隔符二 + 文本二)

                }
            }
        }
        返回 (文本比较 (版本文本一, 版本文本二))
    }

    方法 文本_多字节指针到文本 <公开 静态 类型 = 文本型 注释 = "官方已有一样的方法\"多字节指针到文本\"." 注释 = "将ANSI的文本指针转换为火山的文本型." 折叠 @嵌入式方法 = ""
            @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 多字节文本指针 <类型 = 变整数 注释 = "必须是带结束零字符的多字节文本指针">
    {
        @ @an<CVolString> (GetWideText ((const CHAR*)@<多字节文本指针>, CVolMem (), NULL))
    }

    方法 文本_UTF8指针到文本 <公开 静态 类型 = 文本型 注释 = "请改用\"文本P.UTF8指针到文本\"." 注释 = "将UTF-8的文本指针转换为火山的文本型." 折叠
            @嵌入式方法 = "" @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 UTF8文本指针 <类型 = 变整数 注释 = "必须是带结束零字符的UTF8文本指针">
    {
        @ @an<CVolString> (Utf8ToWStr ((const U8CHAR*)@<UTF8文本指针>, -1, CVolMem ()))
    }

    方法 文本_取文本中间_批量 <公开 静态 类型 = 文本数组类 注释 = "请改用\"文本P.取所有中间文本\"." 折叠 @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 文本数据 <类型 = 文本型>
    参数 开始文本 <类型 = 文本型>
    参数 结束文本 <类型 = 文本型>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    {
        变量 结果数组 <类型 = 文本数组类>
        变量 开始文本长度 <类型 = 整数>
        变量 结束文本长度 <类型 = 整数>
        变量 开始位置 <类型 = 整数 值 = 0>
        变量 结束位置 <类型 = 整数 值 = 0>
        开始文本长度 = 取文本长度 (开始文本)
        结束文本长度 = 取文本长度 (结束文本)
        判断循环 (真)
        {
            开始位置 = 寻找文本 (文本数据, 开始文本, 结束位置, 是否不区分大小写)
            如果 (开始位置 == -1)
            {
                跳出循环
            }
            开始位置 = 开始位置 + 开始文本长度
            结束位置 = 寻找文本 (文本数据, 结束文本, 开始位置, 是否不区分大小写)
            如果 (结束位置 == -1)
            {
                跳出循环
            }
            结果数组.加入成员 (取文本中间 (文本数据, 开始位置, 结束位置 - 开始位置))
            开始位置 = 结束位置 + 结束文本长度

        }
        返回 (结果数组)
    }

    方法 文本_取文本中间 <公开 静态 类型 = 文本型 注释 = "请改用\"文本P.取子文本中间\"." 注释 = "取出两段文本中间的内容" 折叠
            @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 文本内容 <类型 = 文本型 注释 = "所欲取文本中间的原始文本">
    参数 开始文本 <类型 = 文本型 注释 = "提供所欲查找的开始文本内容">
    参数 结束文本 <类型 = 文本型 注释 = "提供所欲查找的结束文本内容">
    参数 起始搜寻位置 <类型 = 整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        变量 开始位置 <类型 = 整数>
        开始位置 = 寻找文本 (文本内容, 开始文本, 起始搜寻位置, 是否不区分大小写)
        如果 (开始位置 == -1)
        {
            返回 (选择 (失败返回原文本, 文本内容, ""))
        }
        起始搜寻位置 = 开始位置 + 取文本长度 (开始文本)
        变量 结束位置 <类型 = 整数>
        结束位置 = 寻找文本 (文本内容, 结束文本, 起始搜寻位置, 是否不区分大小写)
        如果 (结束位置 == -1)
        {
            返回 (选择 (失败返回原文本, 文本内容, ""))
        }
        如果 (是否包含开始文本 == 假)
        {
            开始位置 = 起始搜寻位置
        }
        返回 (取文本中间 (文本内容, 开始位置, 结束位置 - 开始位置 + 选择 (是否包含结束文本, 取文本长度 (结束文本), 0)))
    }

    方法 文本_取文本左边 <公开 静态 类型 = 文本型 注释 = "请改用\"文本P.取子文本左边\"." 注释 = "寻找文本,然后取出找到的文本左边的内容." 折叠
            @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 被查找的文本 <类型 = 文本型>
    参数 要查找的文本 <类型 = 文本型>
    参数 起始搜寻位置 <类型 = 整数 @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "默认为从左到右找；真为从右往左找" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        变量 找到的位置 <类型 = 整数>
        如果 (是否反向查找 == 真)
        {
            找到的位置 = 倒找文本 (被查找的文本, 要查找的文本, 选择 (起始搜寻位置 == 0, -1, 起始搜寻位置), 是否不区分大小写)
        }
        否则
        {
            找到的位置 = 寻找文本 (被查找的文本, 要查找的文本, 起始搜寻位置, 是否不区分大小写)
        }
        如果 (找到的位置 != -1)
        {
            返回 (取文本左边 (被查找的文本, 找到的位置))
        }
        否则
        {
            返回 (选择 (失败返回原文本, 被查找的文本, ""))

        }
    }

    方法 文本_取文本右边 <公开 静态 类型 = 文本型 注释 = "请改用\"文本P.取子文本右边\"." 注释 = "寻找文本,然后取出找到的文本右边的内容." 折叠
            @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 被查找的文本 <类型 = 文本型 "">
    参数 要查找的文本 <类型 = 文本型>
    参数 起始搜寻位置 <类型 = 整数 @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假区分大小写" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "默认为从左到右找；真为从右往左找" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到就返回原文本,默认为返回空文本" @默认值 = 假>
    {
        变量 找到的位置 <类型 = 整数>
        如果 (是否反向查找 == 真)
        {
            找到的位置 = 倒找文本 (被查找的文本, 要查找的文本, 选择 (起始搜寻位置 == 0, -1, 起始搜寻位置), 是否不区分大小写)
        }
        否则
        {
            找到的位置 = 寻找文本 (被查找的文本, 要查找的文本, 起始搜寻位置, 是否不区分大小写)
        }
        如果 (找到的位置 != -1)
        {
            返回 (取文本右边 (被查找的文本, 取文本长度 (被查找的文本) - 找到的位置 - 取文本长度 (要查找的文本)))
        }
        否则
        {
            返回 (选择 (失败返回原文本, 被查找的文本, ""))

        }
    }

    方法 文本_取随机文本 <公开 静态 类型 = 文本型 注释 = "请改用\"文本P.取随机文本\"." 注释 = "获取指定类型的随机文本."
            返回值注释 = "成功返回指定字符数的随机文本,失败返回空文本." 折叠 @禁止流程检查 = 真 @编译条件 = "PIV_ENABLE_OBSOLETE">
    参数 欲取字符数 <类型 = 整数 注释 = "要取的字符个数">
    参数 字符类型 <类型 = 整数 注释 = "为以下数值相加值或位或值,默认为1+2+4;" 注释 = "  1、数字" 注释 = "  2、小写字母" 注释 = "  4、大写字母"
            注释 = "  8、特殊符号" @默认值 = 7>
    {
        @ TCHAR Buffer[96] { 0 };
        @ if ((@<字符类型> & 1) == 1) wcscat (Buffer, L"0123456789");
        @ if ((@<字符类型> & 2) == 2) wcscat (Buffer, L"abcdefghijklmnopqrstuvwxyz");
        @ if ((@<字符类型> & 4) == 4) wcscat (Buffer, L"ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        @ if ((@<字符类型> & 8) == 8) wcscat (Buffer, L" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~");
        @ size_t Offset = wcslen (Buffer) - 1;
        @ if (Offset <= 0) return _CT ("");
        @ CVolString szStr;
        @ szStr.SetLength (@<欲取字符数>);
        @ SetRandSeed (0);
        @ for (INT i = 0; i < @<欲取字符数>; i++) {
        @     wcsncpy ((wchar_t*)szStr.GetText () + i, Buffer + randint (0, Offset), 1);
        @ }
        @ return szStr;
    }
}

# 文本格式(std::format) ====

类 标准格式化类 <公开 注释 = "  {fmt}是一个文本格式化库,已经进入了C++20标准(std::format)," 注释 = "因为火山暂时不兼容C++20,所以这里封装了原型的{fmt}."
        注释 = "  {fmt}的执行效率比核心库的\"取格式文本\"高,格式也更自由多变." 注释 = "  版本: 9.1.0" 注释 = "  格式文本的语法请参考:"
        注释 = "  https://fmt.dev/latest/syntax.html"
        注释 = "  https://www.apiref.com/cpp-zh/cpp/utility/format/formatter.html" 折叠
        @文档 = "category = \"文本操作\"" @视窗.外部头文件 = "src\\piv_fmt.h" @全局类 = 真>
{
    方法 取标准格式文本 <公开 静态 类型 = 文本型 注释 = "使用{fmt}格式化文本,然后返回结果文本."
            注释 = "例如: 取标准格式文本 (\"{1:>06}的{0}: {1:#06X}\", \"十六进制\", 2022)" 注释 = "结果: \"002022的十六进制: 0X07E6\"" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 格式文本 <类型 = 文本型 注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)">
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @an<CVolString> (fmt::format (@<格式文本>, @<替换数据>).c_str ())
    }

    方法 标准格式化输出 <公开 静态 注释 = "使用{fmt}格式化文本,然后输出到控制台,默认不带换行符."
            注释 = "例如: 标准格式化输出 (\"{:#^20}\", \"Hello World!\")" 注释 = "结果: \"####Hello World!####\"" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 格式文本 <类型 = 文本型 注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)">
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ fmt::print (@<格式文本>, @<替换数据>)
    }

    方法 加入标准格式文本 <公开 静态 注释 = "使用{fmt}格式化文本,然后将结果文本添加到当前文本尾部." 注释 = "参数支持文本类型: 文本型、标准文本类、文本视图类" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 所欲操作的文本 <类型 = 文本型>
    参数 格式文本 <类型 = 文本型 注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)">
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<所欲操作的文本>.AddText (fmt::format (@<格式文本>, @<替换数据>).c_str ())
    }

    # UTF8 ---

    方法 取标准格式文本U8 <公开 静态 类型 = 文本型 注释 = "跟\"取标准格式文本\"的不同之处是内部使用UTF8处理."
            注释 = "因为{fmt}处理Unicode汉字的对齐不准确,使用本方法能正确对齐." 注释 = "因为增加了多余的编码转换,本方法会慢一点."
            注释 = "参数支持文本类型: 文本型、标准文本类U、文本视图类U" 折叠 @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)" @匹配类型 = 通用型>
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ *PivU2Ws (fmt::format (piv::edit::cstr<char> (@<格式文本>), @<替换数据>))
    }
}

# 标准文本(std::basic_string) ====

类 标准文本模板类 <公开 注释 = "标准文本类(std::basic_string)的模板基础类." 注释 = "\"模板类型1\"为字符类型." 折叠
        @文档 = "category = \"文本操作\"" @视窗.外部头文件 = "src\\piv_string.hpp" @模板基础类 = 真>
{

    # 属性 ---

    方法 取文本预分配字符数 <公开 静态 类型 = 变整数 注释 = "返回当前文本对象已分配的内存空间大小(单位为字符)." 注释 = "为了快速添加文本,该尺寸一般比实际的文本长度稍大." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.data ().capacity ())
    }

    方法 置文本预分配字符数 <公开 静态 注释 = "  设置本文本对象为了快速进行内容的添加/删除处理使用的空间分配尺寸," 注释 = "每次文本需要调整其空间大小时,都使用本属性值乘于单个字符尺寸作为空"
            注释 = "间调整基准尺寸.值越大,批量加入/删除文本内容时所实际需要重分配空间" 注释 = "的次数就越少,操作速度越快,但是多余内存占用就越大." 注释 = "  一般情况下无需更改本属性值."
            折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲分配字符数 <类型 = 变整数>
    {
        @ @<所欲操作本文本>.data ().reserve (static_cast<size_t>(@<所欲分配字符数>))
    }

    方法 预分配字符数 <公开 静态 属性读 类型 = 变整数 注释 = "  返回当前文本对象已分配的内存空间大小(单位为字符)," 注释 = "为了快速添加文本,该尺寸一般比实际的文本长度稍大." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.data ().capacity ())
    }

    方法 预分配字符数 <公开 静态 属性写 注释 = "  设置本文本对象为了快速进行内容的添加/删除处理使用的空间分配尺寸,"
            注释 = "每次文本需要调整其空间大小时,都使用本属性值乘于单个字符尺寸作为空" 注释 = "间调整基准尺寸.值越大,批量加入/删除文本内容时所实际需要重分配空间"
            注释 = "的次数就越少,操作速度越快,但是多余内存占用就越大." 注释 = "  一般情况下无需更改本属性值." 折叠>
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲分配字符数 <类型 = 变整数>
    {
        @ @<所欲操作本文本>.data ().reserve (static_cast<size_t>(@<所欲分配字符数>));
    }

    方法 编码类型 <公开 静态 属性读 类型 = 整数 注释 = "返回当前文本对象的编码类型: 1=ANSI本地多字节; 2=UTF16-LE; 3=UTF-8)" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.type ()
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否为空" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.IsEmpty ()
    }

    方法 取文本指针 <公开 静态 类型 = 变整数 注释 = "返回当前文本的指针,尾部带结束零字符." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ reinterpret_cast<INT_P>(@<所欲操作本文本>.GetText ())
    }

    方法 取文本长度 <公开 静态 类型 = 变整数 注释 = "返回当前文本的字符长度" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.GetLength ())
    }

    方法 取字节长度 <公开 静态 类型 = 变整数 注释 = "返回当前文本的字节长度" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.GetSize ())
    }

    方法 取文字长度 <公开 静态 类型 = 变整数 注释 = "  返回当前文本的文字长度,对于UTF-8和多字节,一个文字往往会占用一或多个字符,"
            注释 = "即便Unicode也不是所有文字都占一个字符,比如Emoji表情就占两个字符." 注释 = "  本方法可以准确返回文本中所有文字的数量." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.GetWordLength ())
    }

    方法 取文本哈希值 <公开 静态 类型 = 变整数 注释 = "  计算并返回当前文本的哈希值,区分英文字母的大小写." 注释 = "  文本哈希值可以在比较两个文本是否相同时使用(即如果两个文本"
            注释 = "的哈希值不同,则两个文本必定不相同)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.GetHash ())
    }

    方法 取文本大小写无关哈希值 <公开 静态 类型 = 变整数 注释 = "  计算并返回当前文本的哈希值,不区分英文字母的大小写."
            注释 = "  文本哈希值可以在比较两个文本是否相同时使用(即如果两个文本" 注释 = "的哈希值不同,则两个文本必定不相同)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.GetIHash ())
    }

    方法 取数据指针 <公开 静态 类型 = 变整数 注释 = "返回文本对象内std::basic_string成员的指针" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ reinterpret_cast<INT_P>(@<所欲操作本文本>.pdata())
    }

    # 设置文本 ---

    方法 置文件资源 <公开 静态 类型 = 逻辑型 注释 = "将所指定的文件资源复制到当前的文本对象中,返回是否载入成功." 返回值注释 = "无论是否成功,文本对象都会先被清空." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲载入的数据资源 <类型 = 视窗文件资源 注释 = "所欲指向的文本数据资源,文本编码必须跟文本对象一致.">
    {
        @ @<所欲操作本文本>.LoadResData (@<所欲载入的数据资源>)
    }

    # 文件读写 ---

    方法 读入文本文件 <公开 静态 类型 = 逻辑型 注释 = "从所指定路径文件中读入指定尺寸的文本内容到本文本内,返回是否读取成功."
            注释 = "如果文本文件的编码与当前的文本对象不一致,将进行编码转换." 折叠 @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲读取文件名 <类型 = 文本型 注释 = "提供所欲读取文件的路径名称,请勿读入大于2GB的文件.">
    参数 所欲读取数据尺寸 <类型 = 整数 注释 = "提供所欲读取数据的尺寸(单位字节),为-1表示全部读取." @默认值 = -1>
    参数 文件文本编码 <类型 = 文本编码类型 注释 = "提供文件中文本内容的编码格式;" 注释 = "如果为\"文本编码类型.未知\",则首先检查是否为\"文本编码类型.UTF16\"格式;"
            注释 = "如果不是,则认为其为\"文本编码类型.多字节\"格式." @默认值 = 文本编码类型.UTF16>
    {
        @ @<所欲操作本文本>.ReadFromFile (@<所欲读取文件名>, @<所欲读取数据尺寸>, (VOL_STRING_ENCODE_TYPE)@<文件文本编码>)
    }

    方法 写出文本文件 <公开 静态 类型 = 逻辑型 注释 = "将本文本对象的内容写入到所指定路径的文件中,返回是否写出成功." 注释 = "如果指定的写出文本编码与当前的文本对象不一致,将进行编码转换."
            折叠 @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲写到文件名 <类型 = 文本型 注释 = "提供所欲写到文件的路径名称">
    参数 所欲写出文本长度 <类型 = 整数 注释 = "提供所欲写出文本的字符数目,为-1表示全部写出." @默认值 = -1>
    参数 所欲写出文本编码 <类型 = 文本编码类型 注释 = "提供欲将所写出文本转换到的编码类型,不能为\"文本编码类型.未知\"." @默认值 = 文本编码类型.UTF16>
    参数 是否添加BOM签名 <类型 = 逻辑型 注释 = "是否在写出的文本前面加上BOM签名,本参数对多字节无效." @默认值 = 真>
    {
        @ @<所欲操作本文本>.WriteIntoFile (@<所欲写到文件名>, @<所欲写出文本长度>, (VOL_STRING_ENCODE_TYPE)@<所欲写出文本编码>, @<是否添加BOM签名>)
    }

    # 加入文本 ---

    方法 加入无符号值 <公开 静态 类型 = 标准文本模板类 注释 = "将指定的整数型转换到无符号,加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 无符号值 <注释 = "所欲加入的数值(支持字节、短整数、整数、长整数),会自动转换到无符号类型." @匹配类型 = 通用整数型>
    {
        @ @<所欲操作本文本>.AddUnsignedValue (@<无符号值>)
    }

    # 删除文本 ---

    方法 删除部分文本 <公开 静态 类型 = 整数 注释 = "删除当前文本对象中的指定区域内的字符,返回所实际删除的字符数." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始字符索引 <类型 = 变整数 注释 = "提供所欲删除首字符的索引位置,必须大于等于0且小于等于文本当前长度.">
    参数 欲删除字符数 <类型 = 变整数 注释 = "提供所欲删除字符的数目;" 注释 = "如果加上\"起始字符索引\"后大于文本当前长度,则删除\"起始字符索引\"后的所有字符.">
    {
        @ static_cast<INT>(@<所欲操作本文本>.RemoveChars (static_cast<size_t>(@<起始字符索引>), static_cast<size_t>(@<欲删除字符数>)))
    }

    # 寻找 ---

    方法 寻找字符 <公开 静态 类型 = 变整数 注释 = "在文本中查找所指定字符的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲查找的字符 <类型 = 模板类型1 注释 = "提供所欲查找的字符,类型为字符(Unicode)或字节(UTF-8和多字节).">
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,应大于等于0且小于等于文本长度." @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindChar (@<所欲查找的字符>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符 <公开 静态 类型 = 变整数 注释 = "在文本中逆向查找所指定字符的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲查找的字符 <类型 = 模板类型1 注释 = "提供所欲查找的字符,类型为字符(Unicode)或字节(UTF-8和多字节).">
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,应小于等于文本长度,小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.ReverseFindChar (@<所欲查找的字符>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 替换 ---

    方法 替换字符 <公开 静态 类型 = 逻辑型 注释 = "将文本中所有指定字符均替换为另一个" 返回值注释 = "返回是否产生了实际替换" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲被替换的字符 <类型 = 模板类型1 注释 = "提供文本中所欲被替换的字符">
    参数 所欲替换到的字符 <类型 = 模板类型1 注释 = "提供用作替换的字符">
    参数 起始替换索引位置 <类型 = 变整数 注释 = "提供起始替换索引位置,必须大于等于0且小于等于文本长度." @默认值 = 0>
    {
        @ @<所欲操作本文本>.Replace (static_cast<size_t>(@<起始替换索引位置>), @<所欲被替换的字符>, @<所欲替换到的字符>)
    }

    方法 交换文本 <公开 静态 注释 = "将两个标准文本类的内容交换" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲交换的文本 <类型 = 标准文本模板类 注释 = "所欲交换内容的另一个文本对象">
    {
        @ @<所欲操作本文本>.data ().swap (@<所欲交换的文本>.data ())
    }

    # 取部分文本 ---

    方法 取字符 <公开 静态 类型 = 模板类型1 注释 = "返回文本中所指定索引位置处的字符,文本为空时将报错." 返回值注释 = "返回类型为字符(Unicode)或字节(UTF-8和多字节)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 字符索引位置 <类型 = 整数 注释 = "提供所欲获取字符的索引位置,必须大于等于0小于文本的长度.">
    {
        @ @<所欲操作本文本>.At (static_cast<size_t>(@<字符索引位置>))
    }

    方法 取首字符 <公开 静态 类型 = 模板类型1 注释 = "返回文本的首字符,文本为空时返回0." 返回值注释 = "返回类型为字符(Unicode)或字节(UTF-8和多字节)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.Front ()
    }

    方法 取尾字符 <公开 静态 类型 = 模板类型1 注释 = "返回文本的尾字符,文本为空时返回0." 返回值注释 = "返回类型为字符(Unicode)或字节(UTF-8和多字节)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.Back ()
    }

    # 比较 ---

    方法 是否以字符开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定字符开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的字符 <类型 = 模板类型1 注释 = "提供用来检查是否以其开头的字符," 注释 = "类型为字符(Unicode)或字节(UTF-8和多字节).">
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.LeadOf (@<所欲检查的字符>, @<是否区分大小写>)
    }

    方法 是否以字符结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定字符结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的字符 <类型 = 模板类型1 注释 = "提供用来检查是否以其结束的字符," 注释 = "类型为字符(Unicode)或字节(UTF-8和多字节).">
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.EndOf (@<所欲检查的字符>, @<是否区分大小写>)
    }

    # 输出 ---

    方法 复制到字符数组 <公开 静态 类型 = 变整数 注释 = "将本文本的内容复制到所指定的字符数组中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲复制到的字符数组 <类型 = "模板类型1 []" 注释 = "提供所欲复制到的字符数组,成员类型为字符(Unicode)或字节(UTF-8和多字节).">
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置);" 注释 = "将复制索引位置后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.CopyStr (@<所欲复制到的字符数组>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    方法 到字节集 <公开 静态 类型 = 字节集类 注释 = "返回一个包含当前文本数据的字节集" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否添加结束零字符 <类型 = 逻辑型 注释 = "指定返回的文本字节集中是否包括结束零字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToVolMem (@<是否添加结束零字符>)
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回一个包含当前文本视图数据的文本型,本方法会产生内存复制." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.ToVolString ()
    }

    方法 到整数 <公开 静态 类型 = 整数 注释 = "将当前文本的整数值文本转换到整数并返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 进制 <类型 = 整数 注释 = "提供整数文本的进制类型,范围为2到36进制." 注释 = "默认值0表示根据数值前缀自动识别进制,如\"0x\"为16进制,"
            注释 = "\'0\'开头为8进制,1-9开头为10进制." @默认值 = 0>
    {
        @ @<所欲操作本文本>.ToInt (@<进制>)
    }

    方法 到长整数 <公开 静态 类型 = 长整数 注释 = "将当前文本的长整数值文本转换到长整数并返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 进制 <类型 = 整数 注释 = "提供整数文本的进制类型,范围为2到36进制." 注释 = "默认值0表示根据数值前缀自动识别进制,如\"0x\"为16进制,"
            注释 = "\'0\'开头为8进制,1-9开头为10进制." @默认值 = 0>
    {
        @ @<所欲操作本文本>.ToInt64 (@<进制>)
    }

    方法 到小数 <公开 静态 类型 = 小数 注释 = "将当前文本的双精度浮点数文本转换到小数并返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.ToDouble ()
    }

    # 转换

    方法 BASE64到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE64编码格式文本,解码为对应的字节集后返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase64Bin ()
    }

    方法 BASE85到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE85编码格式文本,解码为对应的字节集后返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase85Bin ()
    }

    方法 BASE91到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE91编码格式文本,解码为对应的字节集后返回." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本模板类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase91Bin ()
    }
}

类 标准文本类 <公开 基础类 = 标准文本模板类 注释 = "UTF-16LE编码(与\"文本型\"相同编码)的标准文本类(std::wstring)." 折叠
        @文档 = "category = \"文本操作\"" @模板实现类 = "字符" @别名 = "PivStringW">
{

    # 设置文本 ---

    方法 创建文本 <公开 静态 类型 = 标准文本类 注释 = "通过字符串字面量创建一个UTF-16LE编码文本对象." 注释 = "注意本方法需要以类名调用(而不是类变量),本方法不会产生文本编码转换."
            注释 = "另外有作用相同的全局方法\"创建文本对象W\"." 返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<标准文本类> {L@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 置字面量 <公开 静态 注释 = "将填入的一段字符串字面量置入到文本对象中." 注释 = "注意文本对象原本的内容会被覆盖,本方法不会产生文本编码转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<所欲操作本文本>.data () = L@sn<quot>@pvpt<文本字面量>@sn<quot>
    }

    方法 置文本 <公开 静态 类型 = 标准文本类 注释 = "将所指定的文本数据置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.SetText (@<文本数据>)
    }

    方法 置部分文本 <公开 静态 类型 = 标准文本类 注释 = "将所指定文本数据的一部分置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ @<所欲操作本文本>.SetText (@<文本数据>, static_cast<size_t>(@<所欲添加的长度>))
    }

    方法 置十六进制文本 <公开 静态 类型 = 标准文本类 注释 = "将提供的十六进制文本还原为文本并置入到本对象中,返回文本对象自身."
            注释 = "注意原本的内容会被覆盖,十六进制文本对应的编码必须为UTF-16LE." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲置入十六进制文本 <注释 = "提供所欲置入的十六进制文本,支持类型:" 注释 = "  文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.FromHexStr (@<欲置入十六进制文本>)
    }

    方法 置USC2文本 <公开 静态 类型 = 标准文本类 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并置入到本对象中,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲置入USC2文本 <注释 = "提供所欲置入的USC2文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.FromUsc2Str (@<欲置入USC2文本>)
    }

    方法 填充文本 <公开 静态 类型 = 标准文本类 注释 = "使用所指定长度的指定字符重新填写本标准文本类对象,返回文本对象自身" 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 填充长度 <类型 = 变整数 注释 = "提供所欲填写文本的长度(即重复填充所指定字符的次数),必须大于等于0.">
    参数 填充字符 <类型 = 字符 注释 = "提供所欲使用的填充用字符,类型为字符(Unicode)或字节(UTF-8和多字节);" 注释 = "默认为空格,注意不能为零字符(\'\\0\')."
            @默认值 = ' '>
    {
        @ @<所欲操作本文本>.InitWithChars (static_cast<size_t>(@<填充长度>), @<填充字符>)
    }

    方法 置文本指针 <公开 静态 类型 = 标准文本类 注释 = "从文本指针置入文本数据,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲置入的文本指针,文本编码必须跟文本视图一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度;" 注释 = "参数为-1时会自动识别长度,但指向的文本必须带结束零字符;"
            注释 = "如果文本不含结束零字符或者要置入部分文本,则必须提供正确的字符长度." @默认值 = -1>
    {
        @ @<所欲操作本文本>.SetText (@<文本指针>, static_cast<size_t>(@<文本长度>))
    }

    方法 置文本长度 <公开 静态 类型 = 标准文本类 注释 = "设置当前文本对象的长度,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲设置的长度 <类型 = 变整数 注释 = "如果小于原有文本长度,则将原有文本剪切到所指定长度;" 注释 = "如果大于原有文本长度,则在尾部补充对应数目的空格字符.">
    {
        @ @<所欲操作本文本>.SetLength (static_cast<size_t>(@<所欲设置的长度>))
    }

    # 加入文本 ---

    方法 加入文本 <公开 静态 类型 = 标准文本类 注释 = "将一个或多个文本数据加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "所欲加入的UTF-16LE文本数据,支持连续加入,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<所欲操作本文本>.AddText (@<文本数据>)
    }

    方法 加入字面量 <公开 静态 类型 = 标准文本类 注释 = "将一个文本字面量加入到当前文本对象的尾部,返回文本对象自身."
            注释 = "相比\"加入文本\",本方法不会产生编码转换,但只能填写文本常量." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @<所欲操作本文本>.AddText (L@sn<quot>@pvpt<文本字面量>@sn<quot>)
    }

    方法 加入部分文本 <公开 静态 类型 = 标准文本类 注释 = "将所指定文本数据的一部分加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲加入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ @<所欲操作本文本>.Append (@<文本数据>, @<所欲添加的长度>)
    }

    方法 加入重复文本 <公开 静态 类型 = 标准文本类 注释 = "将所指定的文本重复多次加入当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 所欲添加的次数 <类型 = 变整数>
    {
        @ @<所欲操作本文本>.AddManyText (@<所欲添加的文本>, static_cast<size_t>(@<所欲添加的次数>))
    }

    方法 加入格式文本 <公开 静态 类型 = 标准文本类 注释 = "将所指定的格式文本添加到当前文本尾部,返回文本对象自身." 注释 = "注意: 本方法填写文本参数时只能使用文本型."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_str_param_text_pointer = true" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 格式文本 <注释 = "本参数支持类型: 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 注释 = "提供其中可以包含格式替换符的文本,其中的格式替换符将被后续对应参数所替换."
            注释 = "以下为常用的格式替换符,详细信息请参阅C++文档中关于sprintf函数的说明." 注释 = "    %c: 字符" 注释 = "    %d: 整数(以有符号十进制格式替换)"
            注释 = "    %o: 整数(以无符号八进制格式替换)" 注释 = "    %u: 整数(以无符号十进制格式替换)" 注释 = "    %x: 整数(以无符号小写十六进制格式替换)"
            注释 = "    %X: 整数(以无符号大写十六进制格式替换)" 注释 = "    %I64d: 长整数(以有符号十进制格式替换)"
            注释 = "    %I64o: 长整数(以无符号八进制格式替换)" 注释 = "    %I64u: 长整数(以无符号十进制格式替换)"
            注释 = "    %I64x: 长整数(以无符号小写十六进制格式替换)" 注释 = "    %I64X: 长整数(以无符号大写十六进制格式替换)"
            注释 = "    %e, %E: 小数(以指数形式替换)" 注释 = "    %f: 小数(以非指数形式替换)" 注释 = "    %.8f: 小数(用来表达小数的带宽度限制的常用格式替换符)"
            注释 = "    %g, %G: 小数(根据值大小自动选择是否以指数形式替换)" 注释 = "    %s: 文本型" 注释 = "    %%: 百分号字符本身"
            注释 = "注意: 如果欲格式化\"变整数\"值,请务必将其先强制转换为整数或者长整数,再使用对应的格式替换符." @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." 注释 = "注意: 本参数填写文本数据时只能使用文本型."
            编辑时信息 = "B7FF4, 0, 0, 0" @匹配类型 = 通用基本型 @可扩展 = "">
    {
        @ @<所欲操作本文本>.AddFormatText (@<格式文本>, @<替换数据>)
    }

    方法 加入格式化文本 <公开 静态 类型 = 标准文本类 注释 = "使用{fmt}将指定的格式化文本添加到当前文本尾部,返回文本对象自身." 注释 = "支持的文本类型: 文本型、标准文本类、文本视图类"
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_str_param_text_pointer = true" @视窗.返回参考 = 真 @强制依赖 = "标准格式化类">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 格式文本 <注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)" @匹配类型 = 通用型>
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、文本型、标准文本类、文本视图类" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<所欲操作本文本>.Append (fmt::format (piv::edit::cstr<wchar_t>(@<格式文本>), @<替换数据>))
    }

    方法 加入十六进制文本 <公开 静态 类型 = 标准文本类 注释 = "将提供的十六进制文本还原为文本并添加到当前文本尾部,返回文本对象自身." 注释 = "十六进制文本对应的编码必须为UTF-16LE."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲加入十六进制文本 <注释 = "提供所欲加入的十六进制文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddHexStr (@<欲加入十六进制文本>)
    }

    方法 加入USC2文本 <公开 静态 类型 = 标准文本类 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并添加到当前文本尾部,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲加入USC2文本 <注释 = "提供所欲加入到尾部的USC2文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddUsc2Str (@<欲加入USC2文本>)
    }

    方法 加入文本指针 <公开 静态 类型 = 标准文本类 注释 = "将所指定指针处的文本数据添加到本文本对象的尾部," 注释 = "所添加指针的文本编码必须与文本对象一致."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲置入的文本指针,文本编码必须跟文本视图一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度;" 注释 = "参数为-1时会自动识别长度,但指向的文本必须带结束零字符."
            注释 = "如果文本不含结束零字符或者只加入部分文本,则必须提供正确的字符长度." @默认值 = -1>
    {
        @ @<所欲操作本文本>.Append (@<文本指针>, @<文本长度>)
    }

    方法 加入字符 <公开 静态 类型 = 标准文本类 注释 = "将单个或多个字符添加到当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的字符 <类型 = 字符 注释 = "提供所欲添加到文本中的字符(可扩展参数,支持一次加入多个字符)." @可扩展 = "">
    {
        @ @<所欲操作本文本>.AddChar (@<所欲添加的字符>)
    }

    方法 加入重复字符 <公开 静态 类型 = 标准文本类 注释 = "将所指定的字符添加多个到当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的字符 <类型 = 字符 注释 = "提供所欲添加到文本中的字符,类型为字符(Unicode)或字节(UTF-8和多字节).">
    参数 所欲重复添加的次数 <类型 = 变整数 注释 = "提供将所指定字符重复添加的次数" @默认值 = 1>
    {
        @ @<所欲操作本文本>.AddManyChar (static_cast<size_t>(@<所欲重复添加的次数>), @<所欲添加的字符>)
    }

    方法 添加字符数组 <公开 静态 类型 = 标准文本类 注释 = "将所指定字符数组中的文本内容添加到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的字符数组 <类型 = "字符 []" 注释 = "提供所欲添加其文本内容的字符数组">
    参数 所欲添加的字符数目 <类型 = 变整数 注释 = "提供该字符数组中所欲加入到本文本中的字符数目;" 注释 = "必须大于等于0且小于等于指定字符数组定义时所分配的成员字符数目.">
    {
        @ @<所欲操作本文本>.Append (@<所欲添加的字符数组>, @<所欲添加的字符数目>)
    }

    方法 加入换行符 <公开 静态 类型 = 标准文本类 注释 = "将回车及换行字符(\"\\r\\n\")添加到当前文本尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.AddChar ('\r').AddChar ('\n')
    }

    方法 检查加入换行符 <公开 静态 类型 = 标准文本类 注释 = "如果当前文本不以换行字符(\'\\n\')结束,则将回车及换行字符(\"\\r\\n\")"
            注释 = "添加到当前文本尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.CheckAddCRLF ()
    }

    方法 检查加入路径字符 <公开 静态 类型 = 标准文本类 注释 = "如果当前文本不以路径字符\'\\\'结束,则添加该字符到尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.CheckAddPathChar ()
    }

    方法 加入小写文本 <公开 静态 类型 = 标准文本类 注释 = "将所指定文本中的英文字母转换到小写后添加到当前文本尾部," 注释 = "返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)"
            折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddLowerText (@<所欲添加的文本>)
    }

    方法 加入大写文本 <公开 静态 类型 = 标准文本类 注释 = "将所指定文本中的英文字母转换到大写后添加到当前文本尾部," 注释 = "返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)"
            折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddUpperText (@<所欲添加的文本>)
    }

    # 插入文本 ---

    方法 插入字符 <公开 静态 类型 = 标准文本类 注释 = "将所指定字符插入到文本的所指定索引位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的索引位置,必须大于等于0且小于等于文本当前长度.">
    参数 所欲插入的字符 <类型 = 字符 注释 = "提供所欲插入到文本中的字符">
    {
        @ @<所欲操作本文本>.InsertText (static_cast<size_t>(@<插入索引位置>), @<所欲插入的字符>)
    }

    方法 插入行首空格 <公开 静态 类型 = 标准文本类 注释 = "在文本的每行(基于换行符分隔)行首插入指定数目的空格字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的空格数 <类型 = 整数 注释 = "指定在文本每行行首插入的空格字符数目,不能小于0.">
    {
        @ @<所欲操作本文本>.InsertLineBeginLeaderSpaces (@<所欲插入的空格数>)
    }

    方法 插入文本 <公开 静态 类型 = 标准文本类 注释 = "将所指定文本插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.InsertText (static_cast<size_t>(@<所欲插入的索引位置>), @<所欲插入的文本>)
    }

    方法 插入部分文本 <公开 静态 类型 = 标准文本类 注释 = "将所指定文本的一部分插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 所欲插入的长度 <类型 = 变整数 注释 = "提供欲将指定文本的多少字符插入到当前文本的所指定位置">
    {
        @ @<所欲操作本文本>.InsertText (static_cast<size_t>(@<所欲插入的索引位置>), @<所欲插入的文本>, static_cast<size_t>(@<所欲插入的长度>))
    }

    # 删除文本 ---

    方法 清空文本 <公开 静态 类型 = 标准文本类 注释 = "清空文本,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.Clear ()
    }

    方法 删除字符 <公开 静态 类型 = 标准文本类 注释 = "删除当前文本对象中的所指定区域的字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始字符索引 <类型 = 变整数 注释 = "提供所欲删除首字符的索引位置,必须大于等于0且小于等于文本当前长度.">
    参数 欲删除字符数 <类型 = 变整数 注释 = "提供所欲删除字符的数目;" 注释 = "如果加上\"起始字符索引\"后大于文本当前长度,则删除\"起始字符索引\"后的所有字符.">
    {
        @ @<所欲操作本文本>.RemoveChar (static_cast<size_t>(@<起始字符索引>), static_cast<size_t>(@<欲删除字符数>))
    }

    方法 删除文字 <公开 静态 类型 = 标准文本类 注释 = "删除当前文本对象中的所指定区域的文字,返回文本对象自身."
            注释 = "注: 跟\"删除字符\"不同,本方法以实际显示的文字为单位(一个文字可能对应" 注释 = "单个或多个字符)." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始文字索引 <类型 = 变整数 注释 = "提供所欲删除首文字的索引位置,必须大于等于0;" 注释 = "如果大于文本的文字长度,则表示删除整个文本.">
    参数 欲删除文字数 <类型 = 变整数 注释 = "提供所欲删除文字的数目;" 注释 = "如果加上\"起始文字索引\"后大于文本的文字长度,则删除\"起始文字索引\"后的所有字符.">
    {
        @ @<所欲操作本文本>.RemoveWord (static_cast<size_t>(@<起始文字索引>), static_cast<size_t>(@<欲删除文字数>))
    }

    方法 删除空白行 <公开 静态 类型 = 标准文本类 注释 = "删除当前文本中的所有空行(基于换行符分隔,包括行中全为空白字符的文本行)," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveAllSpaceLines ()
    }

    方法 删首字符 <公开 静态 类型 = 标准文本类 注释 = "删除首部一个字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveFront ()
    }

    方法 删尾字符 <公开 静态 类型 = 标准文本类 注释 = "删除尾部一个字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveBack ()
    }

    方法 删首空 <公开 静态 类型 = 标准文本类 注释 = "删除当前文本首部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.TrimLeft ()
    }

    方法 删尾空 <公开 静态 类型 = 标准文本类 注释 = "删除当前文本尾部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.TrimRight ()
    }

    方法 删首尾空 <公开 静态 类型 = 标准文本类 注释 = "删除文本首部和尾部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.TrimAll ()
    }

    方法 删全部空 <公开 静态 类型 = 标准文本类 注释 = "删除文本中的所有空白字符(包括控制符、通信专用字符和制表符)," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 保留换行符 <类型 = 逻辑型 注释 = "是否保留文本中的换行符" @默认值 = 真>
    {
        @ @<所欲操作本文本>.TrimAllSpace (@<保留换行符>)
    }

    方法 检查删除路径字符 <公开 静态 类型 = 标准文本类 注释 = "如果当前文本以一个可以被删除的路径字符\'\\\'结束(即不为类似\"c:\\\"这样的文本),则将其删除."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveEndPathChar ()
    }

    # 寻找 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在文本中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.ReverseSearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "支持类型: 文本型、标准文本类、文本视图类、字节集类(UTF-16LE);" 注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindFirstOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "支持类型: 文本型、标准文本类、文本视图类、字节集类(UTF-16LE);" 注释 = "字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindLastOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "支持类型: 文本型、标准文本类、文本视图类、字节集类(UTF-16LE);" 注释 = "寻找并返回不等于字符集合中任意字符的首个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindFirstNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "支持类型: 文本型、标准文本类、文本视图类、字节集类(UTF-16LE);" 注释 = "寻找并返回不等于字符集合中任意字符的最后一个字符的位置."
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindLastNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 替换 ---

    方法 文本替换 <公开 静态 类型 = 标准文本类 注释 = "用指定文本数据替换当前文本对象的某一部分,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定替换的起始索引位置,必须大于等于0且小于等于被替换文本长度.">
    参数 替换长度 <类型 = 变整数 注释 = "指定所欲替换的文本部分的长度;" 注释 = "如果加上\"起始替换索引位置\"后大于等于当前的文本长度,"
            注释 = "则变成在当前文本后面加入用作替换的文本.">
    参数 用作替换的文本 <注释 = "支持类型: 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.Replace (static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换长度>), @<用作替换的文本>)
    }

    方法 子文本替换 <公开 静态 类型 = 标准文本类 注释 = "将所指定文本中的指定内容子文本替换为另一个文本,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲被替换的子文本 <注释 = "提供欲被替换的子文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 用作替换的文本 <注释 = "提供用作替换所指定子文本的文本,类型必须与\"欲被替换的子文本\"相同." @匹配类型 = 等于前参数值类型>
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定在欲被替换文本中的起始搜寻索引位置;" 注释 = "必须大于等于0且小于等于当前文本的长度." @默认值 = 0>
    参数 替换次数 <类型 = 变整数 注释 = "指定所欲进行替换的次数,如果小于0则全部替换." @默认值 = -1>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.ReplaceSubText (@<欲被替换的子文本>, @<用作替换的文本>, static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换次数>), @<是否区分大小写>)
    }

    方法 替换控制符 <公开 静态 类型 = 标准文本类 注释 = "将文本中的所有控制类字符替换为空格,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.ReplaceAllControlCharsToSpace ()
    }

    # 分割 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类、文本视图类、字节集类(UTF-16LE);" 注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其"
            注释 = "中任何一个字符时均认为发现了一个分割点)." 注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三"
            注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本容器类 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本" 注释 = "存放在最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitStrings (@<分割字符集合>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本容器类 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitSubStrings (@<分割用子文本>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,因此"
            注释 = "请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类、文本视图类、字节集类(UTF-16LE);" 注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其"
            注释 = "中任何一个字符时均认为发现了一个分割点)." 注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三"
            注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitStringsView (@<分割字符集合>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割子文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,"
            注释 = "因此请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitSubStringViews (@<分割用子文本>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 取文本中间 <公开 静态 类型 = 标准文本类 注释 = "返回一个标准文本类,其中包含当前文本中从指定位置算起指定数量的字符." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于文本长度,否则报错." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置)," 注释 = "将返回索引位置后面的全部剩余字符." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本文本>.Middle (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本左边 <公开 静态 类型 = 标准文本类 注释 = "返回一个标准文本类,其中包含当前文本中从左边算起指定数量的字符." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.Left (static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本右边 <公开 静态 类型 = 标准文本类 注释 = "返回一个标准文本类,其中包含当前文本中从右边算起指定数量的字符." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.Right (static_cast<size_t>(@<欲取出字符的数目>))
    }

    # ---

    方法 取中间文字 <公开 静态 类型 = 标准文本类 注释 = "  返回一个标准文本类,其中包含当前文本中从指定位置算起指定数量的文字."
            注释 = "  注: 跟\"取文本中间\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "D725, 0, 0, 0">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首文字位置,如果大于文本的文字数量会返回空文本." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(文字数目-索引位置),将返回索引位置后面" 注释 = "的全部剩余文字." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本文本>.MiddleWords (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取左边文字 <公开 静态 类型 = 标准文本类 注释 = "  返回一个标准文本类,其中包含当前文本中从左边算起指定数量的文字."
            注释 = "  注: 跟\"取文本左边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本的文字长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.LeftWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取右边文字 <公开 静态 类型 = 标准文本类 注释 = "  返回一个标准文本类,其中包含当前文本中从右边算起指定数量的文字."
            注释 = "  注: 跟\"取文本右边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本的文字长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.RightWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    # ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 子文本数组 <类型 = 标准文本容器类 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.GetMiddle (@<子文本数组>.data (), @<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                                                 @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 标准文本类 注释 = "取出两段文本中间的内容,返回为标准文本类." 折叠 编辑时信息 = "2D723, 0, 0, 0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本文本>.GetMiddle (@<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                              @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 标准文本类 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本文本>.GetLeft (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                            @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 标准文本类 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本文本>.GetRight (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                             @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较 ---

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本的内容是否相同" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.IsEqual (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.compare (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.LeadOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.EndOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 取文本MD5 <公开 静态 类型 = 标准文本类 注释 = "计算并返回文本的MD5数据摘要(32个字符)." 折叠 @嵌入式方法 = "req_cpp_bool = true"
            @强制依赖 = "MD5校验类">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ @dt<标准文本类> {piv::GetStringMd5 (@<所欲操作本文本>.data (), @<是否大写>)}
    }

    # 输出 ---

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "  复制文本的目标位置,支持类型: 变整数、文本型、字节集类、标准文本类" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.CopyStr (@<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    方法 到文本视图 <公开 静态 类型 = 文本视图类 注释 = "返回一个包含当前文本视图数据的文本型." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "默认为假,返回的文本视图指向当前的标准文本,必须保证" 注释 = "当前对象不能比文本视图短;"
            注释 = "为真时,将使用智能指针在文本视图中复制并缓存当前的" 注释 = "文本数据,返回的文本视图不再与当前对象关联." @默认值 = 假>
    {
        @ @dt<文本视图类> {@<所欲操作本文本>.data (), @<缓存文本数据>}
    }

    方法 到十六进制 <公开 静态 类型 = 标准文本类 注释 = "将本文本的内容转换为十六进制格式的连续文本" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToHex (@<是否分隔字符>)
    }

    方法 到十六进制文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为十六进制格式的连续文本,返回火山的文本型." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToHexStr (@<是否分隔字符>)
    }

    方法 到USC2 <公开 静态 类型 = 标准文本类 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToUsc2 (@<编码ASCII字符>)
    }

    方法 到USC2文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本,返回火山的文本型."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToUsc2Str (@<编码ASCII字符>)
    }

    # 转换 ---

    方法 到小写 <公开 静态 类型 = 标准文本类 注释 = "将当前文本中的所有英文字母转换为小写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.MakeLower ()
    }

    方法 到大写 <公开 静态 类型 = 标准文本类 注释 = "将当前文本中的所有英文字母转换为大写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.MakeUpper ()
    }

    方法 到半角 <公开 静态 类型 = 标准文本类 注释 = "将文本中所有的全角ASCII字符转换为对应的半角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换全角字符,默认转换全部全角ASCII字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @<所欲操作本文本>.ToHalfWidth (@<转换选项>)
    }

    方法 到全角 <公开 静态 类型 = 标准文本类 注释 = "将文本中所有的半角ASCII字符转换为对应的全角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换半角字符,默认转换全部半角字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @<所欲操作本文本>.ToFullWidth (@<转换选项>)
    }

    方法 到UTF8 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本的编码转换到UTF-8并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @dt<标准文本类U> {*PivW2U {@<所欲操作本文本>.data ()}}
    }

    方法 到多字节 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本的编码转换到ANSI本地多字节并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @dt<标准文本类A> {*PivW2A {@<所欲操作本文本>.data ()}}
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类 注释 = "将当前文本进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8方式编码,否则为多字节." @默认值 = 真>
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ @<所欲操作本文本>.UrlEncode (@<是否UTF8>, @<不编码保留字符>)
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类 注释 = "将当前文本进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8方式编码,否则为多字节." @默认值 = 真>
    {
        @ @<所欲操作本文本>.UrlDecode (@<是否UTF8>)
    }

    方法 自身到小写 <公开 静态 类型 = 标准文本类 注释 = "将当前文本中的所有英文字母转换为小写,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.ToLower ()
    }

    方法 自身到大写 <公开 静态 类型 = 标准文本类 注释 = "将当前文本中的所有英文字母转换为大写,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.ToUpper ()
    }

    方法 逆序置文本 <公开 静态 类型 = 标准文本类 注释 = "将当前文本的内容逆序翻转,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.GetReverseText ()
    }

    方法 取逆序文本 <公开 静态 类型 = 标准文本类 注释 = "将当前文本的内容逆序翻转,然后将其返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.GetReverseText ()
    }

    方法 BASE64编码 <公开 静态 类型 = 标准文本类 注释 = "返回当前文本数据所对应的BASE64编码格式文本内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 每行最大字符数 <类型 = 整数 注释 = "指定每行编码文本的最大字符数,小于0表示无限制,等于0表示使用默认每行字符数(76)." @默认值 = 0>
    {
        @ @<所欲操作本文本>.EncodeBase64 (@<每行最大字符数>)
    }

    方法 BASE64解码 <公开 静态 类型 = 标准文本类 注释 = "  将当前的BASE64编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE64到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase64 ()
    }

    方法 BASE85编码 <公开 静态 类型 = 标准文本类 注释 = "返回当前文本数据所对应的BASE85编码格式文本内容" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 自动填充 <类型 = 逻辑型 注释 = "为真时将自动在临时文本后填充0字符,以满足字节对齐为4的倍数." 注释 = "如果为假,文本长度必须为4的倍数,否则将失败返回空文本." @默认值 = 真>
    {
        @ @<所欲操作本文本>.EncodeBase85 (@<自动填充>)
    }

    方法 BASE85解码 <公开 静态 类型 = 标准文本类 注释 = "  将当前的BASE85编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE85到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase85 ()
    }

    方法 BASE91编码 <公开 静态 类型 = 标准文本类 注释 = "返回当前文本数据所对应的BASE91编码格式文本内容." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.EncodeBase91 ()
    }

    方法 BASE91解码 <公开 静态 类型 = 标准文本类 注释 = "  将当前的BASE91编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE91到字节集\"." 注释 = "  保留ASCII字符为{<>\"}." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase91 ()
    }
}

类 标准文本类U <公开 基础类 = 标准文本模板类 注释 = "UTF-8编码的标准文本类(std::string)." 折叠 @文档 = "category = \"文本操作\""
        @模板实现类 = "字节" @别名 = "PivStringU">
{

    # 设置文本 ---

    方法 创建文本 <公开 静态 类型 = 标准文本类U 注释 = "通过字符串字面量创建一个UTF-8编码文本对象." 注释 = "注意本方法需要以类名调用(而不是类变量),本方法不会产生文本编码转换."
            注释 = "另外有作用相同的全局方法\"创建文本对象U\"." 返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<标准文本类U> {u8@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 置字面量 <公开 静态 注释 = "将填入的一段字符串字面量置入到文本对象中." 注释 = "注意文本对象原本的内容会被覆盖,本方法不会产生文本编码转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<所欲操作本文本>.data () = u8@sn<quot>@pvpt<文本字面量>@sn<quot>
    }

    方法 置文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定的文本数据置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.SetText (@<文本数据>)
    }

    方法 置部分文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本数据的一部分置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ @<所欲操作本文本>.SetText (@<文本数据>, static_cast<size_t>(@<所欲添加的长度>))
    }

    方法 置十六进制文本 <公开 静态 类型 = 标准文本类U 注释 = "将提供的十六进制文本还原为文本并置入到本对象中,返回文本对象自身."
            注释 = "注意原本的内容会被覆盖,十六进制文本对应的编码必须为UTF-8." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲置入十六进制文本 <注释 = "提供所欲置入的十六进制文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.FromHexStr (@<欲置入十六进制文本>)
    }

    方法 置USC2文本 <公开 静态 类型 = 标准文本类U 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并置入到本对象中,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲置入USC2文本 <注释 = "提供所欲置入的USC2文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.FromUsc2Str (@<欲置入USC2文本>)
    }

    方法 填充文本 <公开 静态 类型 = 标准文本类U 注释 = "使用所指定长度的指定字符重新填写本标准文本类对象,返回文本对象自身" 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 填充长度 <类型 = 变整数 注释 = "提供所欲填写文本的长度(即重复填充所指定字符的次数),必须大于等于0.">
    参数 填充字符 <类型 = 字节 注释 = "提供所欲使用的填充用字符,类型为字符(Unicode)或字节(UTF-8和多字节);" 注释 = "默认为空格,注意不能为零字符(\'\\0\')."
            @默认值 = 32>
    {
        @ @<所欲操作本文本>.InitWithChars (static_cast<size_t>(@<填充长度>), @<填充字符>)
    }

    方法 置文本指针 <公开 静态 类型 = 标准文本类U 注释 = "从文本指针置入文本数据,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲置入的文本指针,文本编码必须跟文本视图一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度,参数为-1时会自动识别长度," 注释 = "但指向的文本必须带结束零字符;" 注释 = "如果文本不含结束零字符或者要置入部分文本,则必"
            注释 = "须提供正确的字符长度." @默认值 = -1>
    {
        @ @<所欲操作本文本>.SetText (@<文本指针>, static_cast<size_t>(@<文本长度>))
    }

    方法 置文本长度 <公开 静态 类型 = 标准文本类U 注释 = "设置当前文本对象的长度,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲设置的长度 <类型 = 变整数 注释 = "如果小于原有文本长度,则将原有文本剪切到所指定长度;" 注释 = "如果大于原有文本长度,则在尾部补充对应数目的空格字符.">
    {
        @ @<所欲操作本文本>.SetLength (static_cast<size_t>(@<所欲设置的长度>))
    }

    # 加入文本 ---

    方法 加入文本 <公开 静态 类型 = 标准文本类U 注释 = "将一个或多个文本数据加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "所欲加入的UTF-8文本数据,支持连续加入,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<所欲操作本文本>.AddText (@<文本数据>)
    }

    方法 加入字面量 <公开 静态 类型 = 标准文本类U 注释 = "将一个文本字面量加入到当前文本对象的尾部,返回文本对象自身."
            注释 = "相比\"加入文本\",本方法不会产生编码转换,但只能填写文本常量." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @<所欲操作本文本>.AddText (u8@sn<quot>@pvpt<文本字面量>@sn<quot>)
    }

    方法 加入部分文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本数据的一部分加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲加入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ @<所欲操作本文本>.Append (@<文本数据>, @<所欲添加的长度>)
    }

    方法 加入重复文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定的文本重复多次加入当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 所欲添加的次数 <类型 = 变整数>
    {
        @ @<所欲操作本文本>.AddManyText (@<所欲添加的文本>, static_cast<size_t>(@<所欲添加的次数>))
    }

    方法 加入格式文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定的格式文本添加到当前文本尾部,返回文本对象自身." 注释 = "注意: 本方法填写文本参数时只能使用文本型."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_str_param_text_pointer_u8 = true" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 格式文本 <注释 = "本参数支持类型: 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = "提供其中可以包含格式替换符的文本,其中的格式替换符将被后续对应参数所替换."
            注释 = "以下为常用的格式替换符,详细信息请参阅C++文档中关于sprintf函数的说明." 注释 = "    %c: 字符" 注释 = "    %d: 整数(以有符号十进制格式替换)"
            注释 = "    %o: 整数(以无符号八进制格式替换)" 注释 = "    %u: 整数(以无符号十进制格式替换)" 注释 = "    %x: 整数(以无符号小写十六进制格式替换)"
            注释 = "    %X: 整数(以无符号大写十六进制格式替换)" 注释 = "    %I64d: 长整数(以有符号十进制格式替换)"
            注释 = "    %I64o: 长整数(以无符号八进制格式替换)" 注释 = "    %I64u: 长整数(以无符号十进制格式替换)"
            注释 = "    %I64x: 长整数(以无符号小写十六进制格式替换)" 注释 = "    %I64X: 长整数(以无符号大写十六进制格式替换)"
            注释 = "    %e, %E: 小数(以指数形式替换)" 注释 = "    %f: 小数(以非指数形式替换)" 注释 = "    %.8f: 小数(用来表达小数的带宽度限制的常用格式替换符)"
            注释 = "    %g, %G: 小数(根据值大小自动选择是否以指数形式替换)" 注释 = "    %s: 文本型" 注释 = "    %%: 百分号字符本身"
            注释 = "注意: 如果欲格式化\"变整数\"值,请务必将其先强制转换为整数或者长整数,再使用对应的格式替换符." @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." 编辑时信息 = "B7FF4, 0, 0, 0" @匹配类型 = 通用基本型
            @可扩展 = "">
    {
        @ @<所欲操作本文本>.AddFormatText (@<格式文本>, @<替换数据>)
    }

    方法 加入格式化文本 <公开 静态 类型 = 标准文本类U 注释 = "使用{fmt}将指定的格式化文本添加到当前文本尾部,返回文本对象自身."
            注释 = "支持的文本类型: 文本型、标准文本类U、文本视图类U" 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true" @视窗.返回参考 = 真 @强制依赖 = "标准格式化类">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 格式文本 <注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)" @匹配类型 = 通用型>
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、文本型、标准文本类U、文本视图类U" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<所欲操作本文本>.Append (fmt::format (piv::edit::cstr<char>(@<格式文本>), @<替换数据>))
    }

    方法 加入十六进制文本 <公开 静态 类型 = 标准文本类U 注释 = "将提供的十六进制文本还原为文本并添加到当前文本尾部,返回文本对象自身." 注释 = "十六进制文本对应的编码必须为UTF-8."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲加入十六进制文本 <注释 = "提供所欲加入的十六进制文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddHexStr (@<欲加入十六进制文本>)
    }

    方法 加入USC2文本 <公开 静态 类型 = 标准文本类U 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并添加到当前文本尾部,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲加入USC2文本 <注释 = "提供所欲加入到尾部的USC2文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddUsc2Str (@<欲加入USC2文本>)
    }

    方法 加入文本指针 <公开 静态 类型 = 标准文本类U 注释 = "将所指定指针处的文本数据添加到本文本对象的尾部," 注释 = "所添加指针的文本编码必须与文本对象一致."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲置入的文本指针,文本编码必须跟文本视图一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度;" 注释 = "参数为-1时会自动识别长度,但指向的文本必须带结束零字符;"
            注释 = "如果文本不含结束零字符或者只加入部分文本,则必须提供正确的字符长度." @默认值 = -1>
    {
        @ @<所欲操作本文本>.Append (@<文本指针>, @<文本长度>)
    }

    方法 加入字符 <公开 静态 类型 = 标准文本类U 注释 = "将单个或多个字符添加到当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的字符 <类型 = 字节 注释 = "提供所欲添加到文本中的字符(可扩展参数,支持一次加入多个字符)." @可扩展 = "">
    {
        @ @<所欲操作本文本>.AddChar (@<所欲添加的字符>)
    }

    方法 加入重复字符 <公开 静态 类型 = 标准文本类U 注释 = "将所指定的字符添加多个到当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的字符 <类型 = 字节 注释 = "提供所欲添加到文本中的字符">
    参数 所欲重复添加的次数 <类型 = 变整数 注释 = "提供将所指定字符重复添加的次数" @默认值 = 1>
    {
        @ @<所欲操作本文本>.AddManyChar (static_cast<size_t>(@<所欲重复添加的次数>), @<所欲添加的字符>)
    }

    方法 添加字符数组 <公开 静态 类型 = 标准文本类U 注释 = "将所指定字符数组中的文本内容添加到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的字符数组 <类型 = "字节 []" 注释 = "提供所欲添加其文本内容的字符数组">
    参数 所欲添加的字符数目 <类型 = 变整数 注释 = "提供该字符数组中所欲加入到本文本中的字符数目;" 注释 = "必须大于等于0且小于等于指定字符数组定义时所分配的成员字符数目.">
    {
        @ @<所欲操作本文本>.Append (@<所欲添加的字符数组>, @<所欲添加的字符数目>)
    }

    方法 加入换行符 <公开 静态 类型 = 标准文本类U 注释 = "将回车及换行字符(\"\\r\\n\")添加到当前文本尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.AddChar ('\r').AddChar ('\n')
    }

    方法 检查加入换行符 <公开 静态 类型 = 标准文本类U 注释 = "如果当前文本不以换行字符(\'\\n\')结束,则将回车及换行字符(\"\\r\\n\")"
            注释 = "添加到当前文本尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.CheckAddCRLF ()
    }

    方法 检查加入路径字符 <公开 静态 类型 = 标准文本类U 注释 = "如果当前文本不以路径字符\'\\\'结束,则添加该字符到尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)"
            折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.CheckAddPathChar ()
    }

    方法 加入小写文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本中的英文字母转换到小写后添加到当前文本尾部," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddLowerText (@<所欲添加的文本>)
    }

    方法 加入大写文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本中的英文字母转换到大写后添加到当前文本尾部," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddUpperText (@<所欲添加的文本>)
    }

    # 插入文本 ---

    方法 插入字符 <公开 静态 类型 = 标准文本类U 注释 = "将所指定字符插入到文本的所指定索引位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的索引位置,必须大于等于0且小于等于文本当前长度.">
    参数 所欲插入的字符 <类型 = 字节 注释 = "提供所欲插入到文本中的字符">
    {
        @ @<所欲操作本文本>.InsertText (static_cast<size_t>(@<插入索引位置>), @<所欲插入的字符>)
    }

    方法 插入行首空格 <公开 静态 类型 = 标准文本类U 注释 = "在文本的每行(基于换行符分隔)行首插入指定数目的空格字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的空格数 <类型 = 整数 注释 = "指定在文本每行行首插入的空格字符数目,不能小于0.">
    {
        @ @<所欲操作本文本>.InsertLineBeginLeaderSpaces (@<所欲插入的空格数>)
    }

    方法 插入文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.InsertText (static_cast<size_t>(@<所欲插入的索引位置>), @<所欲插入的文本>)
    }

    方法 插入部分文本 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本的一部分插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的UTF-8文本数据,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 所欲插入的长度 <类型 = 变整数 注释 = "提供欲将指定文本的多少字符插入到当前文本的所指定位置">
    {
        @ @<所欲操作本文本>.InsertText (static_cast<size_t>(@<所欲插入的索引位置>), @<所欲插入的文本>, static_cast<size_t>(@<所欲插入的长度>))
    }

    # 删除文本 ---

    方法 清空文本 <公开 静态 类型 = 标准文本类U 注释 = "清空文本,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.Clear ()
    }

    方法 删除字符 <公开 静态 类型 = 标准文本类U 注释 = "删除当前文本对象中的所指定区域的字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始字符索引 <类型 = 变整数 注释 = "提供所欲删除首字符的索引位置,必须大于等于0且小于等于文本当前长度.">
    参数 欲删除字符数 <类型 = 变整数 注释 = "提供所欲删除字符的数目;" 注释 = "如果加上\"起始字符索引\"后大于文本当前长度,则删除\"起始字符索引\"后的所有字符.">
    {
        @ @<所欲操作本文本>.RemoveChar (static_cast<size_t>(@<起始字符索引>), static_cast<size_t>(@<欲删除字符数>))
    }

    方法 删除文字 <公开 静态 类型 = 标准文本类U 注释 = "  删除当前文本对象中的所指定区域的文字,返回文本对象自身."
            注释 = "  注: 跟\"删除字符\"不同,本方法以实际显示的文字为单位(一个文字可能对应" 注释 = "单个或多个字符)." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始文字索引 <类型 = 变整数 注释 = "提供所欲删除首文字的索引位置,必须大于等于0;" 注释 = "如果大于文本的文字长度,则表示删除整个文本.">
    参数 欲删除文字数 <类型 = 变整数 注释 = "提供所欲删除文字的数目;" 注释 = "如果加上\"起始文字索引\"后大于文本的文字长度,则删除\"起始文字索引\"后的所有字符.">
    {
        @ @<所欲操作本文本>.RemoveWord (static_cast<size_t>(@<起始文字索引>), static_cast<size_t>(@<欲删除文字数>))
    }

    方法 删除空白行 <公开 静态 类型 = 标准文本类U 注释 = "删除当前文本中的所有空行(基于换行符分隔,包括行中全为空白字符的文本行)," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveAllSpaceLines ()
    }

    方法 删首字符 <公开 静态 类型 = 标准文本类U 注释 = "删除首部一个字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveFront ()
    }

    方法 删尾字符 <公开 静态 类型 = 标准文本类U 注释 = "删除尾部一个字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveBack ()
    }

    方法 删首空 <公开 静态 类型 = 标准文本类U 注释 = "删除当前文本首部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.TrimLeft ()
    }

    方法 删尾空 <公开 静态 类型 = 标准文本类U 注释 = "删除当前文本尾部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.TrimRight ()
    }

    方法 删首尾空 <公开 静态 类型 = 标准文本类U 注释 = "删除文本首部和尾部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.TrimAll ()
    }

    方法 删全部空 <公开 静态 类型 = 标准文本类U 注释 = "删除文本中的所有空白字符(包括控制符、通信专用字符和制表符)," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 保留换行符 <类型 = 逻辑型 注释 = "是否保留文本中的换行符" @默认值 = 真>
    {
        @ @<所欲操作本文本>.TrimAllSpace (@<保留换行符>)
    }

    方法 检查删除路径字符 <公开 静态 类型 = 标准文本类U 注释 = "如果当前文本以一个可以被删除的路径字符\'\\\'结束(即不为类似\"c:\\\"这样的文本),则将其删除."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveEndPathChar ()
    }

    # 寻找 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在文本中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.ReverseSearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = "  字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindFirstOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = "  字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindLastOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = "  寻找并返回不等于字符集合中任意字符的首个字符的位置."
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindFirstNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = "  寻找并返回不等于字符集合中任意字符的最后一个字符的位置."
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindLastNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 替换 ---

    方法 文本替换 <公开 静态 类型 = 标准文本类U 注释 = "用指定文本数据替换当前文本对象的某一部分,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定替换的起始索引位置,必须大于等于0且小于等于被替换文本长度.">
    参数 替换长度 <类型 = 变整数 注释 = "指定所欲替换的文本部分的长度;" 注释 = "如果加上\"起始替换索引位置\"后大于等于当前的文本长度,"
            注释 = "则变成在当前文本后面加入用作替换的文本.">
    参数 用作替换的文本 <注释 = "支持类型: 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.Replace (static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换长度>), @<用作替换的文本>)
    }

    方法 子文本替换 <公开 静态 类型 = 标准文本类U 注释 = "将所指定文本中的指定内容子文本替换为另一个文本,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲被替换的子文本 <注释 = "提供欲被替换的子文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 用作替换的文本 <注释 = "提供用作替换所指定子文本的文本,类型必须与\"欲被替换的子文本\"相同." @匹配类型 = 等于前参数值类型>
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定在欲被替换文本中的起始搜寻索引位置;" 注释 = "必须大于等于0且小于等于当前文本的长度." @默认值 = 0>
    参数 替换次数 <类型 = 变整数 注释 = "指定所欲进行替换的次数,如果小于0则全部替换." @默认值 = -1>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.ReplaceSubText (@<欲被替换的子文本>, @<用作替换的文本>, static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换次数>), @<是否区分大小写>)
    }

    方法 替换控制符 <公开 静态 类型 = 标准文本类U 注释 = "将文本中的所有控制类字符替换为空格,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.ReplaceAllControlCharsToSpace ()
    }

    # 分割 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其"
            注释 = "中任何一个字符时均认为发现了一个分割点)." 注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三"
            注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本容器类U 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitStrings (@<分割字符集合>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = "文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本容器类U 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitSubStrings (@<分割用子文本>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,因此"
            注释 = "请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其"
            注释 = "中任何一个字符时均认为发现了一个分割点)." 注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三"
            注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类U 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitStringsView (@<分割字符集合>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割子文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,"
            注释 = "因此请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = "文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类U 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitSubStringViews (@<分割用子文本>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 取文本中间 <公开 静态 类型 = 标准文本类U 注释 = "返回一个标准文本类,其中包含当前文本中从指定位置算起指定数量的字符." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于文本长度,否则报错." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将返回索引位置后面" 注释 = "的全部剩余字符." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本文本>.Middle (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本左边 <公开 静态 类型 = 标准文本类U 注释 = "返回一个标准文本类,其中包含当前文本中从左边算起指定数量的字符." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.Left (static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本右边 <公开 静态 类型 = 标准文本类U 注释 = "返回一个标准文本类,其中包含当前文本中从右边算起指定数量的字符." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.Right (static_cast<size_t>(@<欲取出字符的数目>))
    }

    # ---

    方法 取中间文字 <公开 静态 类型 = 标准文本类U 注释 = "  返回一个标准文本类,其中包含当前文本中从指定位置算起指定数量的文字."
            注释 = "  注: 跟\"取文本中间\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "D725, 0, 0, 0">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首文字位置,如果大于文本的文字数量会返回空文本." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(文字数目-索引位置),将返回索引位置后面" 注释 = "的全部剩余文字." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本文本>.MiddleWords (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取左边文字 <公开 静态 类型 = 标准文本类U 注释 = "  返回一个标准文本类,其中包含当前文本中从左边算起指定数量的文字."
            注释 = "  注: 跟\"取文本左边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本的文字长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.LeftWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取右边文字 <公开 静态 类型 = 标准文本类U 注释 = "  返回一个标准文本类,其中包含当前文本中从右边算起指定数量的文字."
            注释 = "  注: 跟\"取文本右边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本的文字长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.RightWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    # ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 子文本数组 <类型 = 标准文本容器类U 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.GetMiddle (@<子文本数组>.data (), @<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                                                 @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 标准文本类U 注释 = "取出两段文本中间的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本文本>.GetMiddle (@<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                              @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 标准文本类U 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本文本>.GetLeft (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                            @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 标准文本类U 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本文本>.GetRight (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                             @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较 ---

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本的内容是否相同" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.IsEqual (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.compare (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.LeadOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.EndOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 取文本MD5 <公开 静态 类型 = 标准文本类U 注释 = "计算并返回文本的MD5数据摘要(32个字符)." 折叠 @嵌入式方法 = "req_cpp_bool = true"
            @强制依赖 = "MD5校验类">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ @dt<标准文本类U> {piv::GetStringMd5 (@<所欲操作本文本>.data (), @<是否大写>)}
    }

    # 输出 ---

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "  复制文本的目标位置,支持类型: 变整数、文本型、字节集类、标准文本类U" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.CopyStr (@<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    方法 到文本视图 <公开 静态 类型 = 文本视图类U 注释 = "返回一个包含当前文本视图数据的文本型." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "默认为假,返回的文本视图指向当前的标准文本,必须保证" 注释 = "当前对象不能比文本视图短;"
            注释 = "为真时,将使用智能指针在文本视图中复制并缓存当前的" 注释 = "文本数据,返回的文本视图不再与当前对象关联." @默认值 = 假>
    {
        @ @dt<文本视图类> {@<所欲操作本文本>.data (), @<缓存文本数据>}
    }

    方法 到十六进制 <公开 静态 类型 = 标准文本类U 注释 = "将本文本的内容转换为十六进制格式的连续文本" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToHex (@<是否分隔字符>)
    }

    方法 到十六进制文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为十六进制格式的连续文本,返回火山的文本型." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToHexStr (@<是否分隔字符>)
    }

    方法 到USC2 <公开 静态 类型 = 标准文本类U 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToUsc2 (@<编码ASCII字符>)
    }

    方法 到USC2文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本,返回火山的文本型."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToUsc2Str (@<编码ASCII字符>)
    }

    # 转换 ---

    方法 到小写 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本中的所有英文字母转换为小写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.MakeLower ()
    }

    方法 到大写 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本中的所有英文字母转换为大写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.MakeUpper ()
    }

    方法 到半角 <公开 静态 类型 = 标准文本类U 注释 = "将文本中所有的全角ASCII字符转换为对应的半角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换全角字符,默认转换全部全角ASCII字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "  可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @<所欲操作本文本>.ToHalfWidth (@<转换选项>)
    }

    方法 到全角 <公开 静态 类型 = 标准文本类U 注释 = "将文本中所有的半角ASCII字符转换为对应的全角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换半角字符,默认转换全部半角字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "  可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @<所欲操作本文本>.ToFullWidth (@<转换选项>)
    }

    方法 到UTF16 <公开 静态 类型 = 标准文本类 注释 = "将当前文本的编码转换到UTF-16LE并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @dt<标准文本类> {*PivU2W {@<所欲操作本文本>.data ()}}
    }

    方法 到多字节 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本的编码转换到ANSI本地多字节并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @dt<标准文本类A> {*PivU2A {@<所欲操作本文本>.data ()}}
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ @<所欲操作本文本>.UrlEncode (true, @<不编码保留字符>)
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.UrlDecode (true)
    }

    方法 自身到小写 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本中的所有英文字母转换为小写,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.ToLower ()
    }

    方法 自身到大写 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本中的所有英文字母转换为大写,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.ToUpper ()
    }

    方法 逆序置文本 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本的内容逆序翻转,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.GetReverseText ()
    }

    方法 取逆序文本 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本的内容逆序翻转,然后将其返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.GetReverseText ()
    }

    方法 BASE64编码 <公开 静态 类型 = 标准文本类U 注释 = "返回当前文本数据所对应的BASE64编码格式文本内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 每行最大字符数 <类型 = 整数 注释 = "指定每行编码文本的最大字符数,小于0表示无限制,等于0表示使用默认每行字符数(76)." @默认值 = 0>
    {
        @ @<所欲操作本文本>.EncodeBase64 (@<每行最大字符数>)
    }

    方法 BASE64解码 <公开 静态 类型 = 标准文本类U 注释 = "  将当前的BASE64编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE64到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase64 ()
    }

    方法 BASE85编码 <公开 静态 类型 = 标准文本类U 注释 = "返回当前文本数据所对应的BASE85编码格式文本内容" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 自动填充 <类型 = 逻辑型 注释 = "为真时将自动在临时文本后填充0字符,以满足字节对齐为4的倍数." 注释 = "如果为假,文本长度必须为4的倍数,否则将失败返回空文本." @默认值 = 真>
    {
        @ @<所欲操作本文本>.EncodeBase85 (@<自动填充>)
    }

    方法 BASE85解码 <公开 静态 类型 = 标准文本类U 注释 = "  将当前的BASE85编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE85到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase85 ()
    }

    方法 BASE91编码 <公开 静态 类型 = 标准文本类U 注释 = "返回当前文本数据所对应的BASE91编码格式文本内容." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.EncodeBase91 ()
    }

    方法 BASE91解码 <公开 静态 类型 = 标准文本类U 注释 = "  将当前的BASE91编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE91到字节集\"." 注释 = "  保留ASCII字符为{<>\"}." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase91 ()
    }
}

类 标准文本类A <公开 基础类 = 标准文本模板类 注释 = "  ANSI本地多字节编码的标准文本类(std::string)."
        注释 = "  注意: 本类部分方法只适配了GB2312简体中文编码," 注释 = "用在其他语言编码上可能会有不可预料的结果(乱码)." 折叠 @文档 = "category = \"文本操作\""
        @模板实现类 = "字节" @别名 = "PivStringA">
{

    # 设置文本 ---

    方法 创建文本 <公开 静态 类型 = 标准文本类A 注释 = "通过字符串字面量创建一个ANSI多字节编码文本对象." 注释 = "注意本方法需要以类名调用(而不是类变量),本方法不会产生文本编码转换."
            注释 = "另外有作用相同的全局方法\"创建文本对象A\"." 返回值注释 = "返回所创建的标准文本类(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @dt<标准文本类A> {@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 置字面量 <公开 静态 注释 = "将填入的一段字符串字面量置入到文本对象中." 注释 = "注意文本对象原本的内容会被覆盖,本方法不会产生文本编码转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<所欲操作本文本>.data () = @sn<quot>@pvpt<文本字面量>@sn<quot>
    }

    方法 置文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定的文本数据置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的ANSI多字节文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.SetText (@<文本数据>)
    }

    方法 置部分文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本数据的一部分置入到文本对象中,返回文本对象自身." 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲置入的ANSI多字节文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ @<所欲操作本文本>.SetText (@<文本数据>, static_cast<size_t>(@<所欲添加的长度>))
    }

    方法 置十六进制文本 <公开 静态 类型 = 标准文本类A 注释 = "将提供的十六进制文本还原为文本并置入到本对象中,返回文本对象自身."
            注释 = "注意原本的内容会被覆盖,十六进制文本对应的编码必须为ANSI本地多字节." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲置入十六进制文本 <注释 = "提供所欲置入的十六进制文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.FromHexStr (@<欲置入十六进制文本>)
    }

    方法 置USC2文本 <公开 静态 类型 = 标准文本类A 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并置入到本对象中,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲置入USC2文本 <注释 = "提供所欲置入的USC2文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.FromUsc2Str (@<欲置入USC2文本>)
    }

    方法 填充文本 <公开 静态 类型 = 标准文本类A 注释 = "使用所指定长度的指定字符重新填写本标准文本类对象,返回文本对象自身" 注释 = "注意文本对象原本的内容会被覆盖."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 填充长度 <类型 = 变整数 注释 = "提供所欲填写文本的长度(即重复填充所指定字符的次数),必须大于等于0.">
    参数 填充字符 <类型 = 字节 注释 = "提供所欲使用的填充用字符,类型为字符(Unicode)或字节(UTF-8和多字节);" 注释 = "默认为空格,注意不能为零字符(\'\\0\')."
            @默认值 = 32>
    {
        @ @<所欲操作本文本>.InitWithChars (static_cast<size_t>(@<填充长度>), @<填充字符>)
    }

    方法 置文本指针 <公开 静态 类型 = 标准文本类A 注释 = "从文本指针置入文本数据,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲置入的文本指针,文本编码必须跟文本视图一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度;" 注释 = "参数为-1时会自动识别长度,但指向的文本必须带结束零字符;"
            注释 = "如果文本不含结束零字符或者要置入部分文本,则必须提供正确的字符长度." @默认值 = -1>
    {
        @ @<所欲操作本文本>.SetText (@<文本指针>, static_cast<size_t>(@<文本长度>))
    }

    方法 置文本长度 <公开 静态 类型 = 标准文本类A 注释 = "设置当前文本对象的长度,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲设置的长度 <类型 = 变整数 注释 = "如果小于原有文本长度,则将原有文本剪切到所指定长度;" 注释 = "如果大于原有文本长度,则在尾部补充对应数目的空格字符.">
    {
        @ @<所欲操作本文本>.SetLength (static_cast<size_t>(@<所欲设置的长度>))
    }

    # 加入文本 ---

    方法 加入文本 <公开 静态 类型 = 标准文本类A 注释 = "将一个或多个文本数据加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "所欲加入的ANSI多字节文本数据,支持连续加入,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 注释 = " 小数、通用整数型"
            @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<所欲操作本文本>.AddText (@<文本数据>)
    }

    方法 加入字面量 <公开 静态 类型 = 标准文本类A 注释 = "将一个文本字面量加入到当前文本对象的尾部,返回文本对象自身."
            注释 = "相比\"加入文本\",本方法不会产生编码转换,但只能填写文本常量." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量" @需求类型 = 立即数或常量>
    {
        @ @<所欲操作本文本>.AddText (@sn<quot>@pvpt<文本字面量>@sn<quot>)
    }

    方法 加入部分文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本数据的一部分加入到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本数据 <注释 = "提供所欲加入的ANSI多字节文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 所欲添加的长度 <类型 = 变整数 注释 = "提供欲将所指定文本的多少字符添加到当前文本尾部">
    {
        @ @<所欲操作本文本>.Append (@<文本数据>, @<所欲添加的长度>)
    }

    方法 加入重复文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定的文本重复多次加入当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的ANSI多字节文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 所欲添加的次数 <类型 = 变整数>
    {
        @ @<所欲操作本文本>.AddManyText (@<所欲添加的文本>, static_cast<size_t>(@<所欲添加的次数>))
    }

    方法 加入格式化文本 <公开 静态 类型 = 标准文本类A 注释 = "使用{fmt}将指定的格式化文本添加到当前文本尾部,返回文本对象自身."
            注释 = "注意: 本方法只支持\"标准文本类A\"和\"文本视图类A\"两种文本类型,请勿使用\"文本型\"!" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真 @强制依赖 = "标准格式化类">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 格式文本 <注释 = "  \"{[参数ID][:][填充字符][对齐][符号][#][0][宽度][.精度][L][类型]}\""
            注释 = "  一个标准的替换字段如上,只有首尾的\"{\"和\"}\"字符是必须,其他均可空,全部留" 注释 = "空则是按顺序把替换参数填进去."
            注释 = "  [参数ID]的范围是0-9,表示替换参数的顺序,同一个\"参数ID\"可以在\"格式文本\"" 注释 = "中多次出现."
            注释 = "  [:]选项可空,但如果要使用后面的选项则必须填写." 注释 = "  [填充字符]默认为空格,可填写除了\"{\"和\"}\"以外的任意单个字符;"
            注释 = "  [对齐]选项可用[<][>][^]之一,分别为靠左、靠右和居中对齐.数值参数默认靠" 注释 = "右对齐,其余参数默认靠左对齐."
            注释 = "  [符号]选项可用[+][-][ ],[+]表示在所有数值前插入加号或负号; [-]为默" 注释 = "认值,表示仅在负数前插入负号; [ ]表示在正数前插入空格,负数前插入负号."
            注释 = "  [#]选项只能用于数值参数,在输出2进制、8进制或16进制数值时加上前缀,比如" 注释 = "2进制的\"0b\"、8进制的\"0\"、16进制的\"0x\"."
            注释 = "  [0]只能用于数值参数,填充数字0来对齐,[填充字符]的优先级会高于此选项." 注释 = "  [宽度]选项指定填充对齐的最小宽度,可以使用\"{}\"实现动态宽度."
            注释 = "  [.精度]选项仅用于小数值,其中[精度]为十进制值,用来指定显示小数点后多少" 注释 = "位数字,如\"{:.2f}\"为显示小数点后两位.[精度]可以使用\"{}\"实现动态精度."
            注释 = "  [L]使用本地区域设置插入适当的数字分隔符,此选项仅对数字类型有效." 注释 = "  [类型]选项如下:" 注释 = "    s : 文本型(可省略)"
            注释 = "    c : 字符(可省略)" 注释 = "    b ：整数(以二进制替换,前缀为\"0b\")" 注释 = "    B ：整数(以二进制替换,前缀为\"0B\")"
            注释 = "    c : 整数(将数值转换为字符替换)" 注释 = "    d ：整数(以十进制格式替换,可省略)" 注释 = "    o ：整数(以八进制格式替换)"
            注释 = "    x ：整数(以小写的十六进制替换,前缀为\"0x\")" 注释 = "    X ：整数(以大写的十六进制替换,前缀为\"0X\")"
            注释 = "    a : 小数(以小写的十六进制格式替换,小数点9之后使用指数表示)" 注释 = "    A : 小数(以大写的十六进制格式替换,小数点9之后使用指数表示)"
            注释 = "    e : 小数(以指数格式替换,小写符号)" 注释 = "    E : 小数(以指数格式替换,大写符号)" 注释 = "    f : 小数(以非指数格式替换,小写符号)"
            注释 = "    F : 小数(以非指数格式替换,大写符号)" 注释 = "    g : 小数(根据值大小自动选择是否以指数格式替换,小写符号)"
            注释 = "    G : 小数(根据值大小自动选择是否以指数格式替换,大写符号)" @匹配类型 = 通用型>
    参数 替换数据 <注释 = "  用作给格式文本中的替换字段提供替换参数,替换参数和替换字段的数量可以不" 注释 = "一致. 如果替换字段中用了\"参数ID\",需要注意替换参数的顺序."
            注释 = "  支持类型: 通用数值型、标准文本类A、文本视图类A" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @<所欲操作本文本>.Append (fmt::format (piv::edit::cstr<char>(@<格式文本>), @<替换数据>))
    }

    方法 加入十六进制文本 <公开 静态 类型 = 标准文本类A 注释 = "将提供的十六进制文本还原为文本并添加到当前文本尾部,返回文本对象自身."
            注释 = "十六进制文本对应的编码必须为ANSI本地多字节." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲加入十六进制文本 <注释 = "  提供所欲加入的十六进制文本,支持类型:" 注释 = "  文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddHexStr (@<欲加入十六进制文本>)
    }

    方法 加入USC2文本 <公开 静态 类型 = 标准文本类A 注释 = "将以\"\\u\"开头的Unicode编码文本转换为文本并添加到当前文本尾部,返回文本对象自身."
            注释 = "例: \"\\u4f60\\u597d,\\u706b\\u5c71!\"转换为\"你好,火山!\"" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲加入USC2文本 <注释 = "提供所欲加入到尾部的USC2文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddUsc2Str (@<欲加入USC2文本>)
    }

    方法 加入文本指针 <公开 静态 类型 = 标准文本类A 注释 = "将所指定指针处的文本数据添加到本文本对象的尾部," 注释 = "所添加指针的文本编码必须与文本对象一致."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲置入的文本指针,文本编码必须跟文本视图一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度;" 注释 = "参数为-1时会自动识别长度,但指向的文本必须带结束零字符;"
            注释 = "如果文本不含结束零字符或者只加入部分文本,则必须提供正确的字符长度." @默认值 = -1>
    {
        @ @<所欲操作本文本>.Append (@<文本指针>, @<文本长度>)
    }

    方法 加入字符 <公开 静态 类型 = 标准文本类A 注释 = "将单个或多个字符添加到当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的字符 <类型 = 字节 注释 = "提供所欲添加到文本中的字符(可扩展参数,支持一次加入多个字符)." @可扩展 = "">
    {
        @ @<所欲操作本文本>.AddChar (@<所欲添加的字符>)
    }

    方法 加入重复字符 <公开 静态 类型 = 标准文本类A 注释 = "将所指定的字符添加多个到当前文本的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的字符 <类型 = 字节 注释 = "提供所欲添加到文本中的字符">
    参数 所欲重复添加的次数 <类型 = 变整数 注释 = "提供将所指定字符重复添加的次数" @默认值 = 1>
    {
        @ @<所欲操作本文本>.AddManyChar (static_cast<size_t>(@<所欲重复添加的次数>), @<所欲添加的字符>)
    }

    方法 添加字符数组 <公开 静态 类型 = 标准文本类A 注释 = "将所指定字符数组中的文本内容添加到当前文本对象的尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的字符数组 <类型 = "字节 []" 注释 = "提供所欲添加其文本内容的字符数组">
    参数 所欲添加的字符数目 <类型 = 变整数 注释 = "提供该字符数组中所欲加入到本文本中的字符数目;" 注释 = "必须大于等于0且小于等于指定字符数组定义时所分配的成员字符数目.">
    {
        @ @<所欲操作本文本>.Append (@<所欲添加的字符数组>, @<所欲添加的字符数目>)
    }

    方法 加入换行符 <公开 静态 类型 = 标准文本类A 注释 = "将回车及换行字符(\"\\r\\n\")添加到当前文本尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.AddChar ('\r').AddChar ('\n')
    }

    方法 检查加入换行符 <公开 静态 类型 = 标准文本类A 注释 = "如果当前文本不以换行字符(\'\\n\')结束,则将回车及换行字符(\"\\r\\n\")"
            注释 = "添加到当前文本尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.CheckAddCRLF ()
    }

    方法 检查加入路径字符 <公开 静态 类型 = 标准文本类A 注释 = "如果当前文本不以路径字符\'\\\'结束,则添加该字符到尾部,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)"
            折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.CheckAddPathChar ()
    }

    方法 加入小写文本 <公开 静态 类型 = 标准文本类A 注释 = "  将所指定文本中的英文字母转换到小写后添加到当前文本尾部," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的ANSI本地多字节文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddLowerText (@<所欲添加的文本>)
    }

    方法 加入大写文本 <公开 静态 类型 = 标准文本类 注释 = "  将所指定文本中的英文字母转换到大写后添加到当前文本尾部," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲添加的文本 <注释 = "提供所欲加入的UTF-16LE文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.AddUpperText (@<所欲添加的文本>)
    }

    # 插入文本 ---

    方法 插入字符 <公开 静态 类型 = 标准文本类A 注释 = "将所指定字符插入到文本的所指定索引位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的索引位置,必须大于等于0且小于等于文本当前长度.">
    参数 所欲插入的字符 <类型 = 字节 注释 = "提供所欲插入到文本中的字符">
    {
        @ @<所欲操作本文本>.InsertText (static_cast<size_t>(@<插入索引位置>), @<所欲插入的字符>)
    }

    方法 插入行首空格 <公开 静态 类型 = 标准文本类A 注释 = "在文本的每行(基于换行符分隔)行首插入指定数目的空格字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的空格数 <类型 = 整数 注释 = "指定在文本每行行首插入的空格字符数目,不能小于0.">
    {
        @ @<所欲操作本文本>.InsertLineBeginLeaderSpaces (@<所欲插入的空格数>)
    }

    方法 插入文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的ANSI多字节文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.InsertText (static_cast<size_t>(@<所欲插入的索引位置>), @<所欲插入的文本>)
    }

    方法 插入部分文本 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本的一部分插入到当前文本所指定位置,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲插入的索引位置 <类型 = 变整数 注释 = "指定所欲插入的字符索引位置,必须大于等于0且小于等于当前文本的长度.">
    参数 所欲插入的文本 <注释 = "提供所欲插入的ANSI多字节文本数据,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 所欲插入的长度 <类型 = 变整数 注释 = "提供欲将指定文本的多少字符插入到当前文本的所指定位置">
    {
        @ @<所欲操作本文本>.InsertText (static_cast<size_t>(@<所欲插入的索引位置>), @<所欲插入的文本>, static_cast<size_t>(@<所欲插入的长度>))
    }

    # 删除文本 ---

    方法 清空文本 <公开 静态 类型 = 标准文本类A 注释 = "清空文本,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.Clear ()
    }

    方法 删除字符 <公开 静态 类型 = 标准文本类A 注释 = "删除当前文本对象中的所指定区域的字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始字符索引 <类型 = 变整数 注释 = "提供所欲删除首字符的索引位置,必须大于等于0且小于等于文本当前长度.">
    参数 欲删除字符数 <类型 = 变整数 注释 = "提供所欲删除字符的数目;" 注释 = "如果加上\"起始字符索引\"后大于文本当前长度,则删除\"起始字符索引\"后的所有字符.">
    {
        @ @<所欲操作本文本>.RemoveChar (static_cast<size_t>(@<起始字符索引>), static_cast<size_t>(@<欲删除字符数>))
    }

    方法 删除文字 <公开 静态 类型 = 标准文本类A 注释 = "  删除当前文本对象中的所指定区域的文字,返回文本对象自身."
            注释 = "  注: 跟\"删除字符\"不同,本方法以实际显示的文字为单位(一个文字可能对应" 注释 = "单个或多个字符)." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始文字索引 <类型 = 变整数 注释 = "提供所欲删除首文字的索引位置;" 注释 = "必须大于等于0,如果大于文本的文字长度,则表示删除整个文本.">
    参数 欲删除文字数 <类型 = 变整数 注释 = "提供所欲删除文字的数目;" 注释 = "如果加上\"起始文字索引\"后大于文本的文字长度,则删除\"起始文字索引\"后的所有字符.">
    {
        @ @<所欲操作本文本>.RemoveWord (static_cast<size_t>(@<起始文字索引>), static_cast<size_t>(@<欲删除文字数>))
    }

    方法 删除空白行 <公开 静态 类型 = 标准文本类A 注释 = "删除当前文本中的所有空行(基于换行符分隔,包括行中全为空白字符的文本行)," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveAllSpaceLines ()
    }

    方法 删首字符 <公开 静态 类型 = 标准文本类A 注释 = "删除首部一个字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveFront ()
    }

    方法 删尾字符 <公开 静态 类型 = 标准文本类A 注释 = "删除尾部一个字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveBack ()
    }

    方法 删首空 <公开 静态 类型 = 标准文本类A 注释 = "删除当前文本首部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.TrimLeft ()
    }

    方法 删尾空 <公开 静态 类型 = 标准文本类A 注释 = "删除当前文本尾部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.TrimRight ()
    }

    方法 删首尾空 <公开 静态 类型 = 标准文本类A 注释 = "删除文本首部和尾部的所有空白字符,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.TrimAll ()
    }

    方法 删全部空 <公开 静态 类型 = 标准文本类A 注释 = "  删除文本中的所有空白字符(包括控制符、通信专用字符和制表符)," 注释 = "返回文本对象自身."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 保留换行符 <类型 = 逻辑型 注释 = "是否保留文本中的换行符" @默认值 = 真>
    {
        @ @<所欲操作本文本>.TrimAllSpace (@<保留换行符>)
    }

    方法 检查删除路径字符 <公开 静态 类型 = 标准文本类A 注释 = "如果当前文本以一个可以被删除的路径字符\'\\\'结束(即不为类似\"c:\\\"这样的文本),则将其删除."
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.RemoveEndPathChar ()
    }

    # 寻找 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在文本中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.ReverseSearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 注释 = "  字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindFirstOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 注释 = "  字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindLastOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 注释 = "  寻找并返回不等于字符集合中任意字符的首个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindFirstNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 注释 = "  寻找并返回不等于字符集合中任意字符的最后一个字符的位置."
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.FindLastNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 替换 ---

    方法 文本替换 <公开 静态 类型 = 标准文本类A 注释 = "用指定文本数据替换当前文本对象的某一部分,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定替换的起始索引位置,必须大于等于0且小于等于被替换文本长度.">
    参数 替换长度 <类型 = 变整数 注释 = "指定所欲替换的文本部分的长度;" 注释 = "如果加上\"起始替换索引位置\"后大于等于当前的文本长度,"
            注释 = "则变成在当前文本后面加入用作替换的文本.">
    参数 用作替换的文本 <注释 = "支持类型: 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    {
        @ @<所欲操作本文本>.Replace (static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换长度>), @<用作替换的文本>)
    }

    方法 子文本替换 <公开 静态 类型 = 标准文本类A 注释 = "将所指定文本中的指定内容子文本替换为另一个文本,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲被替换的子文本 <注释 = "提供欲被替换的子文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 用作替换的文本 <注释 = "提供用作替换所指定子文本的文本,类型必须与\"欲被替换的子文本\"相同." @匹配类型 = 等于前参数值类型>
    参数 起始替换索引位置 <类型 = 变整数 注释 = "指定在欲被替换文本中的起始搜寻索引位置;" 注释 = "必须大于等于0且小于等于当前文本的长度." @默认值 = 0>
    参数 替换次数 <类型 = 变整数 注释 = "指定所欲进行替换的次数,如果小于0则全部替换." @默认值 = -1>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.ReplaceSubText (@<欲被替换的子文本>, @<用作替换的文本>, static_cast<size_t>(@<起始替换索引位置>), static_cast<size_t>(@<替换次数>), @<是否区分大小写>)
    }

    方法 替换控制符 <公开 静态 类型 = 标准文本类A 注释 = "将文本中的所有控制类字符替换为空格,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.ReplaceAllControlCharsToSpace ()
    }

    # 分割 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其"
            注释 = "中任何一个字符时均认为发现了一个分割点)." 注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三"
            注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本容器类A 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitStrings (@<分割字符集合>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = "文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 标准文本容器类A 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitSubStrings (@<分割用子文本>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的字符集合进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,因此"
            注释 = "请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其"
            注释 = "中任何一个字符时均认为发现了一个分割点)." 注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三"
            注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类A 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitStringsView (@<分割字符集合>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本视图 <公开 静态 类型 = 变整数 注释 = "  将文本基于所指定的子文本进行分割,然后将分割的视图存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  与\"分割子文本\"不同,本方法不会产生文本复制,数组中的内容仍指向当前的文本,"
            注释 = "因此请勿在当前文本被修改后继续使用该数组." 返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类A 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.SplitSubStringViews (@<分割用子文本>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 取文本中间 <公开 静态 类型 = 标准文本类A 注释 = "返回一个标准文本类,其中包含当前文本中从指定位置算起指定数量的字符." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于文本长度,否则报错." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将返回索引位置后面" 注释 = "的全部剩余字符." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本文本>.Middle (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本左边 <公开 静态 类型 = 标准文本类A 注释 = "返回一个标准文本类,其中包含当前文本中从左边算起指定数量的字符." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.Left (static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本右边 <公开 静态 类型 = 标准文本类A 注释 = "返回一个标准文本类,其中包含当前文本中从右边算起指定数量的字符." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.Right (static_cast<size_t>(@<欲取出字符的数目>))
    }

    # ---

    方法 取中间文字 <公开 静态 类型 = 标准文本类A 注释 = "  返回一个标准文本类,其中包含当前文本中从指定位置算起指定数量的文字."
            注释 = "  注: 跟\"取文本中间\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "D725, 0, 0, 0">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首文字位置,如果大于文本的文字数量会返回空文本." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(文字数目-索引位置),将返回索引位置后面" 注释 = "的全部剩余文字." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本文本>.MiddleWords (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取左边文字 <公开 静态 类型 = 标准文本类A 注释 = "  返回一个标准文本类,其中包含当前文本中从左边算起指定数量的文字."
            注释 = "  注: 跟\"取文本左边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本的文字长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.LeftWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取右边文字 <公开 静态 类型 = 标准文本类A 注释 = "  返回一个标准文本类,其中包含当前文本中从右边算起指定数量的文字."
            注释 = "  注: 跟\"取文本右边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于文本的文字长度,将返回完整的文本.">
    {
        @ @<所欲操作本文本>.RightWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    # ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 子文本数组 <类型 = 标准文本容器类A 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.GetMiddle (@<子文本数组>.data (), @<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                                                 @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 标准文本类A 注释 = "取出两段文本中间的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本文本>.GetMiddle (@<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                              @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 标准文本类A 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本文本>.GetLeft (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                            @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 标准文本类A 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为标准文本类." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本文本>.GetRight (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                             @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较 ---

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本的内容是否相同" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.IsEqual (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.compare (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.LeadOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本文本>.EndOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 取文本MD5 <公开 静态 类型 = 标准文本类A 注释 = "计算并返回文本的MD5数据摘要(32个字符)." 折叠 @嵌入式方法 = "req_cpp_bool = true"
            @强制依赖 = "MD5校验类">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ @dt<标准文本类A> {piv::GetStringMd5 (@<所欲操作本文本>.data (), @<是否大写>)}
    }

    # 输出 ---

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "  复制文本的目标位置,支持类型: 变整数、文本型、字节集类、标准文本类A" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(@<所欲操作本文本>.CopyStr (@<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    方法 到文本视图 <公开 静态 类型 = 文本视图类A 注释 = "返回一个包含当前文本视图数据的文本型." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "默认为假,返回的文本视图指向当前的标准文本,必须保证" 注释 = "当前对象不能比文本视图短;"
            注释 = "为真时,将使用智能指针在文本视图中复制并缓存当前的" 注释 = "文本数据,返回的文本视图不再与当前对象关联." @默认值 = 假>
    {
        @ @dt<文本视图类> {@<所欲操作本文本>.data (), @<缓存文本数据>}
    }

    方法 到十六进制 <公开 静态 类型 = 标准文本类A 注释 = "将本文本的内容转换为十六进制格式的连续文本" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToHex (@<是否分隔字符>)
    }

    方法 到十六进制文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为十六进制格式的连续文本,返回火山的文本型." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToHexStr (@<是否分隔字符>)
    }

    方法 到USC2 <公开 静态 类型 = 标准文本类A 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToUsc2 (@<编码ASCII字符>)
    }

    方法 到USC2文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本,返回火山的文本型."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @<所欲操作本文本>.ToUsc2Str (@<编码ASCII字符>)
    }

    # 转换 ---

    方法 到小写 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本中的所有英文字母转换为小写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.MakeLower ()
    }

    方法 到大写 <公开 静态 类型 = 标准文本类 注释 = "将当前文本中的所有英文字母转换为大写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.MakeUpper ()
    }

    方法 到半角 <公开 静态 类型 = 标准文本类A 注释 = "将文本中所有的全角ASCII字符转换为对应的半角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换全角字符,默认转换全部全角ASCII字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "  可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @<所欲操作本文本>.ToHalfWidth (@<转换选项>)
    }

    方法 到全角 <公开 静态 类型 = 标准文本类A 注释 = "将文本中所有的半角ASCII字符转换为对应的全角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换半角字符,默认转换全部半角字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "  可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @<所欲操作本文本>.ToFullWidth (@<转换选项>)
    }

    方法 到UTF8 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本的编码转换到UTF-8并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @dt<标准文本类U> {*PivA2U {@<所欲操作本文本>.data ()}}
    }

    方法 到UTF16 <公开 静态 类型 = 标准文本类 注释 = "将当前文本的编码转换到UTF-16LE并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @dt<标准文本类> {*PivA2W {@<所欲操作本文本>.data ()}}
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ @<所欲操作本文本>.UrlEncode (false, @<不编码保留字符>)
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.UrlDecode (false)
    }

    方法 自身到小写 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本中的所有英文字母转换为小写,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.ToLower ()
    }

    方法 自身到大写 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本中的所有英文字母转换为大写,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.ToUpper ()
    }

    方法 逆序置文本 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本的内容逆序翻转,返回文本对象自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.GetReverseText ()
    }

    方法 取逆序文本 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本的内容逆序翻转,然后将其返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.GetReverseText ()
    }

    方法 BASE64编码 <公开 静态 类型 = 标准文本类A 注释 = "返回当前文本数据所对应的BASE64编码格式文本内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 每行最大字符数 <类型 = 整数 注释 = "指定每行编码文本的最大字符数,小于0表示无限制,等于0表示使用默认每行字符数(76)." @默认值 = 0>
    {
        @ @<所欲操作本文本>.EncodeBase64 (@<每行最大字符数>)
    }

    方法 BASE64解码 <公开 静态 类型 = 标准文本类A 注释 = "  将当前的BASE64编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE64到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase64 ()
    }

    方法 BASE85编码 <公开 静态 类型 = 标准文本类A 注释 = "返回当前文本数据所对应的BASE85编码格式文本内容" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 自动填充 <类型 = 逻辑型 注释 = "为真时将自动在临时文本后填充0字符,以满足字节对齐为4的倍数." 注释 = "如果为假,文本长度必须为4的倍数,否则将失败返回空文本." @默认值 = 真>
    {
        @ @<所欲操作本文本>.EncodeBase85 (@<自动填充>)
    }

    方法 BASE85解码 <公开 静态 类型 = 标准文本类A 注释 = "  将当前的BASE85编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE85到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase85 ()
    }

    方法 BASE91编码 <公开 静态 类型 = 标准文本类A 注释 = "返回当前文本数据所对应的BASE91编码格式文本内容." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.EncodeBase91 ()
    }

    方法 BASE91解码 <公开 静态 类型 = 标准文本类A 注释 = "  将当前的BASE91编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE91到字节集\"." 注释 = "  保留ASCII字符为{<>\"}." 折叠 @嵌入式方法 = "">
    参数 所欲操作本文本 <类型 = 标准文本类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    {
        @ @<所欲操作本文本>.DecodeBase91 ()
    }
}

# 文本视图(std::basic_string_view) ====

类 文本视图模板类 <公开 注释 = "文本视图类(std::basic_string_view)的模板基础类." 注释 = "\"模板类型1\"为字符类型." 折叠
        @文档 = "category = \"文本操作\"" @视窗.外部头文件 = "src\\piv_string.hpp" @视窗.附加编译参数 = "cpp: /std:c++17"
        @模板基础类 = 真>
{

    # 属性 ---

    方法 取引用计数 <公开 静态 类型 = 整数 注释 = "  返回文本数据缓存的智能指针引用计数." 注释 = "  如果在置文本数据时使用了\"缓存文本数据\",会将文本"
            注释 = "数据复制到智能指针,并将文本视图指向智能指针." 注释 = "  之后将文本视图赋值到另一个文本视图变量,会使智能" 注释 = "指针的引用计数加1,而文本视图被销毁将使引用计数减1."
            注释 = "  直到引用计数减到0,才释放缓存的文本数据." 返回值注释 = "返回0则表示没有缓存文本数据" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.UseConut ()
    }

    方法 是否为空 <公开 静态 类型 = 逻辑型 注释 = "返回文本视图是否为空" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.IsEmpty ()
    }

    方法 取文本指针 <公开 静态 类型 = 变整数 注释 = "  获取文本视图的首字符指针,无法保证该指针含结束零字符," 注释 = "一般需要配合\"取文本长度\"使用." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ reinterpret_cast<INT_P>(@<所欲操作本视图>.GetText ())
    }

    方法 取文本长度 <公开 静态 类型 = 变整数 注释 = "获取文本视图的文本长度(字符数量)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.GetLength ())
    }

    方法 取字节长度 <公开 静态 类型 = 变整数 注释 = "获取文本视图的字节长度." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.GetSize ())
    }

    方法 取文字长度 <公开 静态 类型 = 变整数 注释 = "  返回文本视图的文字长度,对于UTF-8和多字节,一个文字往往会占用一或多个字符,"
            注释 = "即便Unicode也不是所有文字都占一个字符,比如Emoji表情就占两个字符." 注释 = "  本方法可以准确返回文本中所有文字的数量." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.GetWordLength ())
    }

    方法 取文本哈希值 <公开 静态 类型 = 变整数 注释 = "  计算并返回文本的哈希值,区分英文字母的大小写." 注释 = "  文本哈希值可以在比较两个文本是否相同时使用(即如果"
            注释 = "两个文本的哈希值不同,则两个文本必定不相同)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.GetHash ())
    }

    方法 取文本大小写无关哈希值 <公开 静态 类型 = 变整数 注释 = "  计算并返回文本的哈希值,不区分英文字母的大小写." 注释 = "  文本哈希值可以在比较两个文本是否相同时使用(即如果"
            注释 = "两个文本的哈希值不同,则两个文本必定不相同)." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.GetIHash ())
    }

    方法 取数据指针 <公开 静态 类型 = 变整数 注释 = "返回文本视图内std::basic_string_view成员的指针" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ reinterpret_cast<INT_P>(@<所欲操作本视图>.pdata())
    }

    # 设置文本 ---

    方法 置文件资源 <公开 静态 类型 = 逻辑型 注释 = "将文本视图指向所指定的文件资源,返回是否载入成功." 返回值注释 = "无论是否成功,视图都会先被清空." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲指向的数据资源 <类型 = 视窗文件资源 注释 = "所欲指向的文本数据资源,文本编码必须跟文本视图一致.">
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "默认为假,视图将指向提供的视窗文件资源,文件资源" 注释 = "在程序结束之前一直有效,无需考虑生命周期;"
            注释 = "为真时,将使用智能指针缓存所提供的文本数据,文本" 注释 = "视图与提供的视窗文件资源不再关联." @默认值 = 假>
    {
        @ @<所欲操作本视图>.LoadResData (@<所欲指向的数据资源>, @<缓存文本数据>)
    }

    # 文件读写 ---

    方法 读入文本文件 <公开 静态 类型 = 逻辑型 注释 = "从所指定路径文件中读入指定尺寸的文本内容到本对象内,返回是否读取成功."
            注释 = "如果文本文件的编码与当前的文本视图不一致,将进行编码转换." 注释 = "注意: 本方法必定会缓存文本数据" 折叠
            @嵌入式方法 = "req_str_param_text_pointer = true">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲读取文件名 <类型 = 文本型 注释 = "提供所欲读取文件的路径名称,请勿读入大于2GB的文件.">
    参数 所欲读取数据尺寸 <类型 = 整数 注释 = "提供所欲读取数据的尺寸(单位字节),为-1表示全部读取." @默认值 = -1>
    参数 文件文本编码 <类型 = 文本编码类型 注释 = "提供文件中文本内容的编码格式;" 注释 = "如果为\"文本编码类型.未知\",则首先检查是否为\"文本编码类型.UTF16\"格式;"
            注释 = "如果不是,则认为其为\"文本编码类型.多字节\"格式." @默认值 = 文本编码类型.UTF16>
    {
        @ @<所欲操作本视图>.ReadFromFile (@<所欲读取文件名>, @<所欲读取数据尺寸>, (VOL_STRING_ENCODE_TYPE)@<文件文本编码>)
    }

    方法 写出文本文件 <公开 静态 类型 = 逻辑型 注释 = "将文本视图的内容写入到所指定路径的文件中,返回是否写出成功." 注释 = "如果指定的写出文本编码与当前的文本视图不一致,将进行编码转换."
            折叠 @嵌入式方法 = "req_str_param_text_pointer = true\r\nreq_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲写到文件名 <类型 = 文本型 注释 = "提供所欲写到文件的路径名称">
    参数 所欲写出文本长度 <类型 = 整数 注释 = "提供所欲写出文本的字符数目,为-1表示全部写出." @默认值 = -1>
    参数 所欲写出文本编码 <类型 = 文本编码类型 注释 = "提供欲将所写出文本转换到的编码类型,不能为\"文本编码类型.未知\"." @默认值 = 文本编码类型.UTF16>
    参数 是否添加BOM签名 <类型 = 逻辑型 注释 = "是否在写出的文本前面加上BOM签名,本参数对多字节无效." @默认值 = 真>
    {
        @ @<所欲操作本视图>.WriteIntoFile (@<所欲写到文件名>, @<所欲写出文本长度>, (VOL_STRING_ENCODE_TYPE)@<所欲写出文本编码>, @<是否添加BOM签名>)
    }

    # 字符 ---

    方法 取字符 <公开 静态 类型 = 模板类型1 注释 = "返回文本视图中所指定索引位置处的字符,文本视图为空时将报错." 返回值注释 = "返回类型为字符(Unicode)或字节(UTF-8和多字节)"
            折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 字符索引位置 <类型 = 整数 注释 = "提供所欲获取字符的索引位置,必须大于等于0小于文本视图的长度.">
    {
        @ @<所欲操作本视图>.At (static_cast<size_t>(@<字符索引位置>))
    }

    方法 取首字符 <公开 静态 类型 = 模板类型1 注释 = "返回文本视图的首字符,文本视图为空时返回0."
            返回值注释 = "返回类型为字符(Unicode)或字节(UTF-8和多字节),文本视图为空时返回0." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.Front ()
    }

    方法 取尾字符 <公开 静态 类型 = 模板类型1 注释 = "返回文本视图的尾字符,文本视图为空时返回0."
            返回值注释 = "返回类型为字符(Unicode)或字节(UTF-8和多字节),文本视图为空时返回0." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.Back ()
    }

    # 寻找

    方法 寻找字符 <公开 静态 类型 = 变整数 注释 = "在文本视图中查找所指定字符的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲查找的字符 <类型 = 模板类型1 注释 = "提供所欲查找的字符,类型为字符(Unicode)或字节(UTF-8和多字节).">
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,应大于等于0且小于等于文本长度." @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindChar (@<所欲查找的字符>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符 <公开 静态 类型 = 变整数 注释 = "在文本视图中逆向查找所指定字符的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲查找的字符 <类型 = 模板类型1 注释 = "提供所欲查找的字符,类型为字符(Unicode)或字节(UTF-8和多字节).">
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,应小于等于文本长度,小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.ReverseFindChar (@<所欲查找的字符>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 比较

    方法 是否以字符开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前视图是否以所指定字符开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的字符 <类型 = 模板类型1 注释 = "提供用来检查是否以其开头的字符," 注释 = "类型为字符(Unicode)或字节(UTF-8和多字节).">
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.LeadOf (@<所欲检查的字符>, @<是否区分大小写>)
    }

    方法 是否以字符结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前视图是否以所指定字符结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的字符 <类型 = 模板类型1 注释 = "提供用来检查是否以其结束的字符," 注释 = "类型为字符(Unicode)或字节(UTF-8和多字节).">
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.EndOf (@<所欲检查的字符>, @<是否区分大小写>)
    }

    # 输出

    方法 到字节集 <公开 静态 类型 = 字节集类 注释 = "返回一个包含当前视图内容的字节集,本方法会产生内存复制." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否添加结束零字符 <类型 = 逻辑型 注释 = "指定返回的文本字节集中是否包括结束零字符" @默认值 = 假>
    {
        @ @<所欲操作本视图>.ToVolMem (@<是否添加结束零字符>)
    }

    方法 到整数 <公开 静态 类型 = 整数 注释 = "将当前文本的整数值文本转换到整数并返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 进制 <类型 = 整数 注释 = "  提供整数文本的进制类型,范围为2到36进制." 注释 = "  默认值0表示根据数值前缀自动识别进制,如\"0x\"为16进制,"
            注释 = "\'0\'开头为8进制,1-9开头为10进制." @默认值 = 0>
    {
        @ @<所欲操作本视图>.ToInt (@<进制>)
    }

    方法 到长整数 <公开 静态 类型 = 长整数 注释 = "将当前文本的长整数值文本转换到长整数并返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 进制 <类型 = 整数 注释 = "  提供整数文本的进制类型,范围为2到36进制." 注释 = "  默认值0表示根据数值前缀自动识别进制,如\"0x\"为16进制,"
            注释 = "\'0\'开头为8进制,1-9开头为10进制." @默认值 = 0>
    {
        @ @<所欲操作本视图>.ToInt64 (@<进制>)
    }

    方法 到小数 <公开 静态 类型 = 小数 注释 = "将当前文本的双精度浮点数文本转换到小数并返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图模板类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.ToDouble ()
    }
}

类 文本视图类 <公开 基础类 = 文本视图模板类 注释 = "UTF-16LE编码(与\"文本型\"相同编码)的文本视图类."
        注释 = "文本视图(wstring_view)本身不拥有数据,而是指向其他文本的字符缓冲区." 注释 = "使用文本视图内存开销小,速度快,缺点是视图不能修改文本数据." 折叠
        @文档 = "category = \"文本操作\"" @模板实现类 = "字符" @别名 = "PivStringViewW">
{

    # 设置文本 ---

    方法 创建视图 <公开 静态 类型 = 文本视图类 注释 = "创建一个文本视图,并将它指向填入的一段字符串字面量." 注释 = "另外有作用相同的全局方法\"创建文本视图W\"."
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类> {L@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 置字面量 <公开 静态 注释 = "  将文本视图指向填入的一段字符串字面量." 注释 = "  注: 字符串字面量存储在全局的只读存储区中,在程序的整个" 注释 = "生命周期中可用."
            注释 = "  因此我们无需考虑填入的文本是否会被销毁." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<所欲操作本视图>.data () = L@sn<quot>@pvpt<文本字面量>@sn<quot>
    }

    方法 置文本 <公开 静态 类型 = 文本视图类 注释 = "将当前的文本视图指向提供的UTF-16LE编码文本数据变量,返回文本视图自身."
            注释 = "支持类型: 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_cpp_bool = true"
            @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本数据 <注释 = "  支持类型: 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 注释 = "  只能提供含UTF-16LE编码文本数据的变量,如果不缓存"
            注释 = "文本数据,该变量的生命周期不能比本视图类短." @需求类型 = 可写入变量 @匹配类型 = 通用型>
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "默认为假,文本视图将指向\"文本数据\"变量,必须保证" 注释 = "该变量的生命周期不能比本视图短;"
            注释 = "为真时,将使用智能指针缓存所提供的文本数据,文本" 注释 = "视图与提供的文本数据变量不再关联." @默认值 = 假>
    {
        @ @<所欲操作本视图>.SetText (@<文本数据>, @<缓存文本数据>)
    }

    方法 置文本指针 <公开 静态 类型 = 文本视图类 注释 = "将文本视图指向所指定的文本指针,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲指向的文本指针,文本编码必须跟文本视图一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度;" 注释 = "参数为-1时会自动识别长度,但指向的文本必须带结束零字符."
            注释 = "如果文本不含结束零字符或者要置入部分文本,则必须提供正确的字符长度." @默认值 = -1>
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "默认为假,文本视图将指向提供的\"文本指针\",必须" 注释 = "保证文本指针的生命周期不能比本文本视图短;"
            注释 = "为真时,将使用智能指针缓存所提供的文本数据," 注释 = "文本视图与提供的文本指针不再关联." @默认值 = 假>
    {
        @ @<所欲操作本视图>.SetText (@<文本指针>, static_cast<size_t>(@<文本长度>), @<缓存文本数据>)
    }

    # 删除 ---

    方法 后移起点 <公开 静态 类型 = 文本视图类 注释 = "  从文本视图的起点向后移动所指定的字符数,以收缩视图的长度," 注释 = "返回文本视图自身."
            注释 = "  本方法只改动指针值,不会修改视图所指向的文本数据." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲移除字符数 <类型 = 变整数 注释 = "所欲从视图起始移除的字符数,大于等于视图长度会将视图删空.">
    {
        @ @<所欲操作本视图>.RemovePrefix (static_cast<size_t>(@<所欲移除字符数>))
    }

    方法 前移终点 <公开 静态 类型 = 文本视图类 注释 = "  从文本视图的终点向前移动所指定的字符数,以收缩视图的长度," 注释 = "返回文本视图自身."
            注释 = "  本方法只改动指针值,不会修改视图所指向的文本数据." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲移除字符数 <类型 = 变整数 注释 = "所欲从视图终点移除的字符数,大于等于视图长度会将视图删空.">
    {
        @ @<所欲操作本视图>.RemoveSuffix (static_cast<size_t>(@<所欲移除字符数>))
    }

    方法 删首空 <公开 静态 类型 = 文本视图类 注释 = "删除文本视图首部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.TrimLeft ()
    }

    方法 删尾空 <公开 静态 类型 = 文本视图类 注释 = "删除文本视图尾部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.TrimRight ()
    }

    方法 删首尾空 <公开 静态 类型 = 文本视图类 注释 = "删除文本视图首部和尾部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.TrimAll ()
    }

    方法 清空视图 <公开 静态 类型 = 文本视图类 注释 = "  清空文本视图,返回文本视图自身." 注释 = "  清空后文本视图将不再指向任何的文本数据,如果有"
            注释 = "缓存的文本数据,会将智能指针的引用计数减1." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.Clear ()
    }

    # 寻找 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在视图中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、字节集类、文本视图类、标准文本类" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.SearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、字节集类、文本视图类、标准文本类" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.ReverseSearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类、标准文本类" 注释 = "  字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindFirstOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类、标准文本类" 注释 = "  字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindLastOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类、标准文本类" 注释 = "  寻找并返回不等于字符集合中任意字符的首个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindFirstNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类、标准文本类" 注释 = "  寻找并返回不等于字符集合中任意字符的最后一个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindLastNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 分割 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类、标准文本类" 注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其"
            注释 = "中任何一个字符时均认为发现了一个分割点)." 注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三"
            注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.SplitStrings (@<分割字符集合>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、字节集类、文本视图类、标准文本类" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.SplitSubStrings (@<分割用子文本>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 取文本中间 <公开 静态 类型 = 文本视图类 注释 = "返回一个文本视图,其中包含本视图中从指定位置算起指定数量的字符." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写." 编辑时信息 = "D725, 0, 0, 0">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将返回索引位置后面" 注释 = "的全部剩余字符." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本视图>.Middle (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本左边 <公开 静态 类型 = 文本视图类 注释 = "返回一个文本视图,其中包含本视图中从左边算起指定数量的字符." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.Left (static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本右边 <公开 静态 类型 = 文本视图类 注释 = "返回一个文本视图,其中包含本视图中从右边算起指定数量的字符." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.Right (static_cast<size_t>(@<欲取出字符的数目>))
    }

    # ---

    方法 取中间文字 <公开 静态 类型 = 文本视图类 注释 = "  返回一个文本视图,其中包含本视图中从指定位置算起指定数量的文字."
            注释 = "  注: 跟\"取文本中间\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写." 编辑时信息 = "D725, 0, 0, 0">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首文字位置,如果大于视图的文字数量会返回空文本." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(文字数目-索引位置),将返回索引位置后面" 注释 = "的全部剩余文字." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本视图>.MiddleWords (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取左边文字 <公开 静态 类型 = 文本视图类 注释 = "  返回一个文本视图,其中包含本视图中从左边算起指定数量的文字."
            注释 = "  注: 跟\"取文本左边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图文字长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.LeftWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取右边文字 <公开 静态 类型 = 文本视图类 注释 = "  返回一个文本视图,其中包含本视图中从右边算起指定数量的文字."
            注释 = "  注: 跟\"取文本右边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图文字长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.RightWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    # ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 子文本数组 <类型 = 文本视图容器类 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.GetMiddle (@<子文本数组>.data (), @<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                                                 @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 文本视图类 注释 = "取出两段文本中间的内容,返回为文本视图." 注释 = "本方法不会产生文本复制." 返回值注释 = "返回的文本视图仍指向相同的文本数据"
            折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本视图>.GetMiddle (@<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                              @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 文本视图类 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为文本视图." 注释 = "本方法不会产生文本复制."
            返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本视图>.GetLeft (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                            @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 文本视图类 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为文本视图." 注释 = "本方法不会产生文本复制."
            返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本视图>.GetRight (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                             @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较 ---

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.compare (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本的内容是否相同" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.IsEqual (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本开头" 折叠 编辑时信息 = "3F25E, 0, 0, 0"
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写." 编辑时信息 = "3F25E, 0, 0, 0">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)"
            编辑时信息 = "3F25E, 0, 0, 0" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" 编辑时信息 = "3F25E, 0, 0, 0" @默认值 = 真>
    {
        @ @<所欲操作本视图>.LeadOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类、文本视图类、字节集类(UTF-16LE)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.EndOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 取文本MD5 <公开 静态 类型 = 标准文本类 注释 = "计算并返回文本的MD5数据摘要(32个字符)." 折叠 @嵌入式方法 = "req_cpp_bool = true"
            @强制依赖 = "MD5校验类">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ @dt<标准文本类> {piv::GetStringMd5 (@<所欲操作本视图>.data (), @<是否大写>)}
    }

    # 输出 ---

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本视图指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "  复制文本的目标位置,支持类型: 变整数、文本型、字节集类、标准文本类" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.CopyStr (@<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回一个包含当前视图内容的文本型,本方法会产生内存复制." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.ToVolString ()
    }

    方法 到标准文本 <公开 静态 类型 = 标准文本类 注释 = "返回一个包含当前视图内容的标准文本类(std::wstring),本方法会产生内存复制." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.ToString ()}
    }

    方法 到十六进制 <公开 静态 类型 = 标准文本类 注释 = "将本文本的内容转换为十六进制格式的连续文本" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.ToHex (@<是否分隔字符>)}
    }

    方法 到十六进制文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为十六进制格式的连续文本,返回火山的文本型." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @<所欲操作本视图>.ToHexStr (@<是否分隔字符>)
    }

    方法 到USC2 <公开 静态 类型 = 标准文本类 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.ToUsc2 (@<编码ASCII字符>)}
    }

    方法 到USC2文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本,返回火山的文本型."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @<所欲操作本视图>.ToUsc2Str (@<编码ASCII字符>)
    }

    # 转换 ---

    方法 到小写 <公开 静态 类型 = 标准文本类 注释 = "将当前文本中的所有英文字母转换为小写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.MakeLower ()}
    }

    方法 到大写 <公开 静态 类型 = 标准文本类 注释 = "将当前文本中的所有英文字母转换为大写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.MakeUpper ()}
    }

    方法 到半角 <公开 静态 类型 = 标准文本类 注释 = "将文本中所有的全角ASCII字符转换为对应的半角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换全角字符,默认转换全部全角ASCII字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "  可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.ToHalfWidth (@<转换选项>)}
    }

    方法 到全角 <公开 静态 类型 = 标准文本类 注释 = "将文本中所有的半角ASCII字符转换为对应的全角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换半角字符,默认转换全部半角字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "  可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.ToFullWidth (@<转换选项>)}
    }

    方法 到UTF8 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本的编码转换到UTF-8并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类U> {*PivW2U {@<所欲操作本视图>.data ()}}
    }

    方法 到多字节 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本的编码转换到ANSI本地多字节并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类A> {*PivW2A {@<所欲操作本视图>.data ()}}
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类 注释 = "将当前文本进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8方式编码,否则为多字节." @默认值 = 真>
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.UrlEncode (@<是否UTF8>, @<不编码保留字符>)}
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类 注释 = "将当前文本进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否UTF8 <类型 = 逻辑型 注释 = "将文本内容以UTF-8方式编码,否则为多字节." @默认值 = 真>
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.UrlDecode (@<是否UTF8>)}
    }

    # ---

    方法 BASE64编码 <公开 静态 类型 = 标准文本类 注释 = "返回当前文本数据所对应的BASE64编码格式文本内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 每行最大字符数 <类型 = 整数 注释 = "指定每行编码文本的最大字符数,小于0表示无限制,等于0表示使用默认每行字符数(76)." @默认值 = 0>
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.EncodeBase64 (@<每行最大字符数>)}
    }

    方法 BASE64解码 <公开 静态 类型 = 标准文本类 注释 = "  将当前的BASE64编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE64到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.DecodeBase64 ()}
    }

    方法 BASE64到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE64编码格式文本解码为对应的字节集后返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.DecodeBase64Bin ()
    }

    # ---

    方法 BASE85编码 <公开 静态 类型 = 标准文本类 注释 = "返回当前文本数据所对应的BASE85编码格式文本内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 自动填充 <类型 = 逻辑型 注释 = "为真时将自动在临时文本后填充0字符,以满足字节对齐为4的倍数." 注释 = "如果为假,文本长度必须为4的倍数,否则将失败返回空文本." @默认值 = 真>
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.EncodeBase85 (@<自动填充>)}
    }

    方法 BASE85解码 <公开 静态 类型 = 标准文本类 注释 = "  将当前的BASE85编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE85到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.DecodeBase85 ()}
    }

    方法 BASE85到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE85编码格式文本解码为对应的字节集后返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.DecodeBase85Bin ()
    }

    # ---

    方法 BASE91编码 <公开 静态 类型 = 标准文本类 注释 = "返回当前文本数据所对应的BASE91编码格式文本内容." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.EncodeBase91 ()}
    }

    方法 BASE91解码 <公开 静态 类型 = 标准文本类 注释 = "  将当前的BASE91编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE91到字节集\"." 注释 = "  保留ASCII字符为{<>\"}." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类> {@<所欲操作本视图>.DecodeBase91 ()}
    }

    方法 BASE91到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE91编码格式文本解码为对应的字节集后返回." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.DecodeBase91Bin ()
    }
}

类 文本视图类U <公开 基础类 = 文本视图模板类 注释 = "UTF-8编码的文本视图类." 注释 = "文本视图(string_view)本身不拥有数据,而是指向其他文本的字符缓冲区."
        注释 = "使用文本视图内存开销小,速度快,缺点是视图不能修改文本数据." 折叠 @文档 = "category = \"文本操作\"" @模板实现类 = "字节"
        @别名 = "PivStringViewU">
{

    # 设置文本 ---

    方法 创建视图 <公开 静态 类型 = 文本视图类U 注释 = "创建一个文本视图,并将它指向填入的一段字符串字面量." 注释 = "另外有作用相同的全局方法\"创建文本视图U\"."
            返回值注释 = "返回所创建的文本视图(支持链式语法)" 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类U> {u8@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 置字面量 <公开 静态 注释 = "  将文本视图指向填入的一段字符串字面量." 注释 = "  注: 字符串字面量存储在全局的只读存储区中,在程序的整个" 注释 = "生命周期中可用."
            注释 = "  因此我们无需考虑填入的文本是否会被销毁." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<所欲操作本视图>.data () = u8@sn<quot>@pvpt<文本字面量>@sn<quot>
    }

    方法 置文本 <公开 静态 类型 = 文本视图类U 注释 = "将当前的文本视图指向提供的UTF-8编码文本数据变量,返回文本视图自身." 注释 = "支持类型: 字节集类、标准文本类U、文本视图类U"
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本数据 <注释 = "  支持类型: 字节集类、标准文本类U、文本视图类U" 注释 = "  只能提供含UTF-8编码文本数据的变量,如果不缓存"
            注释 = "文本数据,该变量的生命周期不能比本视图类短." @需求类型 = 可写入变量 @匹配类型 = 通用型>
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "默认为假,文本视图将指向\"文本数据\"变量,必须保证" 注释 = "该变量的生命周期不能比本视图短;"
            注释 = "为真时,将使用智能指针缓存所提供的文本数据,文本" 注释 = "视图与提供的文本数据变量不再关联." @默认值 = 假>
    {
        @ @<所欲操作本视图>.SetText (@<文本数据>, @<缓存文本数据>)
    }

    方法 置文本指针 <公开 静态 类型 = 文本视图类U 注释 = "将文本视图指向所指定的文本指针,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲指向的文本指针,文本编码必须跟文本视图一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度;" 注释 = "参数为-1时会自动识别长度,但指向的文本必须带结束零字符."
            注释 = "如果文本不含结束零字符或者要置入部分文本,则必须提供正确的字符长度." @默认值 = -1>
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "默认为假,文本视图将指向提供的\"文本指针\",必须" 注释 = "保证文本指针的生命周期不能比本文本视图短;"
            注释 = "为真时,将使用智能指针缓存所提供的文本数据," 注释 = "文本视图与提供的文本指针不再关联." @默认值 = 假>
    {
        @ @<所欲操作本视图>.SetText (@<文本指针>, static_cast<size_t>(@<文本长度>), @<缓存文本数据>)
    }

    # 删除 ---

    方法 后移起点 <公开 静态 类型 = 文本视图类U 注释 = "  从文本视图的起点向后移动所指定的字符数,以收缩视图的长度," 注释 = "返回文本视图自身."
            注释 = "  本方法只改动指针值,不会修改视图所指向的文本数据." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲移除字符数 <类型 = 变整数 注释 = "所欲从视图起始移除的字符数,大于等于视图长度会将视图删空.">
    {
        @ @<所欲操作本视图>.RemovePrefix (static_cast<size_t>(@<所欲移除字符数>))
    }

    方法 前移终点 <公开 静态 类型 = 文本视图类U 注释 = "  从文本视图的终点向前移动所指定的字符数,以收缩视图的长度," 注释 = "返回文本视图自身."
            注释 = "  本方法只改动指针值,不会修改视图所指向的文本数据." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲移除字符数 <类型 = 变整数 注释 = "所欲从视图终点移除的字符数,大于等于视图长度会将视图删空.">
    {
        @ @<所欲操作本视图>.RemoveSuffix (static_cast<size_t>(@<所欲移除字符数>))
    }

    方法 删首空 <公开 静态 类型 = 文本视图类U 注释 = "删除文本视图首部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.TrimLeft ()
    }

    方法 删尾空 <公开 静态 类型 = 文本视图类U 注释 = "删除文本视图尾部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.TrimRight ()
    }

    方法 删首尾空 <公开 静态 类型 = 文本视图类U 注释 = "删除文本视图首部和尾部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.TrimAll ()
    }

    方法 清空视图 <公开 静态 类型 = 文本视图类U 注释 = "  清空文本视图,返回文本视图自身." 注释 = "  清空后文本视图将不再指向任何的文本数据,如果有"
            注释 = "缓存的文本数据,会将智能指针的引用计数减1." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.Clear ()
    }

    # 寻找 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在视图中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、字节集类、文本视图类U、标准文本类U" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.SearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、字节集类、文本视图类U、标准文本类U" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.ReverseSearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类U、标准文本类U" 注释 = "  字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置." @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindFirstOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类U、标准文本类U" 注释 = "  字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindLastOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类U、标准文本类U" 注释 = "  寻找并返回不等于字符集合中任意字符的首个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindFirstNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类U、标准文本类U" 注释 = "  寻找并返回不等于字符集合中任意字符的最后一个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindLastNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 分割 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类U、标准文本类U" 注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其"
            注释 = "中任何一个字符时均认为发现了一个分割点)." 注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三"
            注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类U 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.SplitStrings (@<分割字符集合>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = "文本型、字节集类、文本视图类U、标准文本类U" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类U 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.SplitSubStrings (@<分割用子文本>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 取文本中间 <公开 静态 类型 = 文本视图类U 注释 = "返回一个文本视图,其中包含本视图中从指定位置算起指定数量的字符." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写." 编辑时信息 = "D725, 0, 0, 0">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将返回索引位置后面" 注释 = "的全部剩余字符." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本视图>.Middle (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本左边 <公开 静态 类型 = 文本视图类U 注释 = "返回一个文本视图,其中包含本视图中从左边算起指定数量的字符." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.Left (static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本右边 <公开 静态 类型 = 文本视图类U 注释 = "返回一个文本视图,其中包含本视图中从右边算起指定数量的字符." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.Right (static_cast<size_t>(@<欲取出字符的数目>))
    }

    # ---

    方法 取中间文字 <公开 静态 类型 = 文本视图类U 注释 = "  返回一个文本视图,其中包含本视图中从指定位置算起指定数量的文字."
            注释 = "  注: 跟\"取文本中间\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写." 编辑时信息 = "D725, 0, 0, 0">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首文字位置,如果大于视图的文字数量会返回空文本." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(文字数目-索引位置),将返回索引位置后面" 注释 = "的全部剩余文字." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本视图>.MiddleWords (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取左边文字 <公开 静态 类型 = 文本视图类U 注释 = "  返回一个文本视图,其中包含本视图中从左边算起指定数量的文字."
            注释 = "  注: 跟\"取文本左边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图文字长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.LeftWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取右边文字 <公开 静态 类型 = 文本视图类U 注释 = "  返回一个文本视图,其中包含本视图中从右边算起指定数量的文字."
            注释 = "  注: 跟\"取文本右边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图文字长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.RightWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    # ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 子文本数组 <类型 = 文本视图容器类U 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.GetMiddle (@<子文本数组>.data (), @<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                                                 @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 文本视图类U 注释 = "取出两段文本中间的内容,返回为文本视图." 注释 = "本方法不会产生文本复制."
            返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本视图>.GetMiddle (@<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                              @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 文本视图类U 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为文本视图." 注释 = "本方法不会产生文本复制."
            返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本视图>.GetLeft (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                            @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 文本视图类U 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为文本视图." 注释 = "本方法不会产生文本复制."
            返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本视图>.GetRight (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                             @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较 ---

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.compare (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本的内容是否相同" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.IsEqual (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.LeadOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类U、文本视图类U、字节集类(UTF-8)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.EndOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 取文本MD5 <公开 静态 类型 = 标准文本类U 注释 = "计算并返回文本的MD5数据摘要(32个字符)." 折叠 @嵌入式方法 = "req_cpp_bool = true"
            @强制依赖 = "MD5校验类">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ @dt<标准文本类U> {piv::GetStringMd5 (@<所欲操作本视图>.data (), @<是否大写>)}
    }

    # 输出 ---

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本视图指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "  复制文本的目标位置,支持类型: 变整数、字节集类、标准文本类U" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.CopyStr (@<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回一个包含当前视图内容的UTF-16LE文本型,本方法会产生内存复制和文本编码转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ *PivU2Ws {@<所欲操作本视图>.data()}
    }

    方法 到标准文本 <公开 静态 类型 = 标准文本类U 注释 = "返回一个包含当前视图内容的标准文本类U(std::string),本方法会产生内存复制." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.ToString ()}
    }

    方法 到十六进制 <公开 静态 类型 = 标准文本类U 注释 = "将本文本的内容转换为十六进制格式的连续文本" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.ToHex (@<是否分隔字符>)}
    }

    方法 到十六进制文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为十六进制格式的连续文本,返回火山的文本型." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @<所欲操作本视图>.ToHexStr (@<是否分隔字符>)
    }

    方法 到USC2 <公开 静态 类型 = 标准文本类U 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.ToUsc2 (@<编码ASCII字符>)}
    }

    方法 到USC2文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本,返回火山的文本型."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @<所欲操作本视图>.ToUsc2Str (@<编码ASCII字符>)
    }

    # 转换 ---

    方法 到小写 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本中的所有英文字母转换为小写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.MakeLower ()}
    }

    方法 到大写 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本中的所有英文字母转换为大写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.MakeUpper ()}
    }

    方法 到半角 <公开 静态 类型 = 标准文本类U 注释 = "将文本中所有的全角ASCII字符转换为对应的半角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换全角字符,默认转换全部全角ASCII字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "  可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.ToHalfWidth (@<转换选项>)}
    }

    方法 到全角 <公开 静态 类型 = 标准文本类U 注释 = "将文本中所有的半角ASCII字符转换为对应的全角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换半角字符,默认转换全部半角字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "  可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.ToFullWidth (@<转换选项>)}
    }

    方法 到UTF16 <公开 静态 类型 = 标准文本类 注释 = "将当前文本的编码转换到UTF-16LE并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类> {*PivU2W {@<所欲操作本视图>.data ()}}
    }

    方法 到多字节 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本的编码转换到ANSI本地多字节并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类A> {*PivU2A {@<所欲操作本视图>.data ()}}
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.UrlEncode (true, @<不编码保留字符>)}
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.UrlDecode (true)}
    }

    # ---

    方法 BASE64编码 <公开 静态 类型 = 标准文本类U 注释 = "返回当前文本数据所对应的BASE64编码格式文本内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 每行最大字符数 <类型 = 整数 注释 = "指定每行编码文本的最大字符数,小于0表示无限制,等于0表示使用默认每行字符数(76)." @默认值 = 0>
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.EncodeBase64 (@<每行最大字符数>)}
    }

    方法 BASE64解码 <公开 静态 类型 = 标准文本类U 注释 = "  将当前的BASE64编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE64到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.DecodeBase64 ()}
    }

    方法 BASE64到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE64编码格式文本解码为对应的字节集后返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.DecodeBase64Bin ()
    }

    # ---

    方法 BASE85编码 <公开 静态 类型 = 标准文本类U 注释 = "返回当前文本数据所对应的BASE85编码格式文本内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 自动填充 <类型 = 逻辑型 注释 = "为真时将自动在临时文本后填充0字符,以满足字节对齐为4的倍数." 注释 = "如果为假,文本长度必须为4的倍数,否则将失败返回空文本." @默认值 = 真>
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.EncodeBase85 (@<自动填充>)}
    }

    方法 BASE85解码 <公开 静态 类型 = 标准文本类U 注释 = "  将当前的BASE85编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE85到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.DecodeBase85 ()}
    }

    方法 BASE85到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE85编码格式文本解码为对应的字节集后返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.DecodeBase85Bin ()
    }

    # ---

    方法 BASE91编码 <公开 静态 类型 = 标准文本类U 注释 = "返回当前文本数据所对应的BASE91编码格式文本内容." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.EncodeBase91 ()}
    }

    方法 BASE91解码 <公开 静态 类型 = 标准文本类U 注释 = "  将当前的BASE91编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE91到字节集\"." 注释 = "  保留ASCII字符为{<>\"}." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类U> {@<所欲操作本视图>.DecodeBase91 ()}
    }

    方法 BASE91到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE91编码格式文本解码为对应的字节集后返回." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类U 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.DecodeBase91Bin ()
    }
}

类 文本视图类A <公开 基础类 = 文本视图模板类 注释 = "ANSI本地多字节编码的文本视图类." 注释 = "文本视图(string_view)本身不拥有数据,而是指向其他文本的字符缓冲区."
        注释 = "使用文本视图内存开销小,速度快,缺点是视图不能修改文本数据." 折叠 @文档 = "category = \"文本操作\"" @模板实现类 = "字节"
        @别名 = "PivStringViewA">
{

    # 设置文本 ---

    方法 创建视图 <公开 静态 类型 = 文本视图类A 注释 = "创建一个文本视图,并将它指向填入的一段字符串字面量." 注释 = "另外有作用相同的全局方法\"创建文本视图A\"."
            返回值注释 = "返回所创建的文本视图(支持链式语法)." 折叠 @嵌入式方法 = "">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @dt<文本视图类A> {@sn<quot>@pvpt<文本字面量>@sn<quot>}
    }

    方法 置字面量 <公开 静态 注释 = "  将文本视图指向填入的一段字符串字面量." 注释 = "  注: 字符串字面量存储在全局的只读存储区中,在程序的整个" 注释 = "生命周期中可用."
            注释 = "  因此我们无需考虑填入的文本是否会被销毁." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本字面量 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量;" 注释 = "要置入文本变量的请用\"置文本\"方法." @需求类型 = 立即数或常量>
    {
        @ @<所欲操作本视图>.data () = @sn<quot>@pvpt<文本字面量>@sn<quot>
    }

    方法 置文本 <公开 静态 类型 = 文本视图类A 注释 = "将当前的文本视图指向提供的ANSI多字节编码文本数据变量,返回文本视图自身." 注释 = "支持类型: 字节集类、标准文本类A、文本视图类A"
            返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本数据 <注释 = "  支持类型: 字节集类、标准文本类A、文本视图类A" 注释 = "  只能提供含ANSI多字节编码文本数据的变量,如果不缓存"
            注释 = "文本数据,该变量的生命周期不能比本视图类短." @需求类型 = 可写入变量 @匹配类型 = 通用型>
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "默认为假,文本视图将指向\"文本数据\"变量,必须保证" 注释 = "该变量的生命周期不能比本视图短;"
            注释 = "为真时,将使用智能指针缓存所提供的文本数据,文本" 注释 = "视图与提供的文本数据变量不再关联." @默认值 = 假>
    {
        @ @<所欲操作本视图>.SetText (@<文本数据>, @<缓存文本数据>)
    }

    方法 置文本指针 <公开 静态 类型 = 文本视图类A 注释 = "将文本视图指向所指定的文本指针,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠
            @嵌入式方法 = "req_cpp_bool = true" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 文本指针 <类型 = 变整数 注释 = "所欲指向的文本指针,文本编码必须跟文本视图一致.">
    参数 文本长度 <类型 = 变整数 注释 = "提供文本的字符长度;" 注释 = "参数为-1时会自动识别长度,但指向的文本必须带结束零字符;"
            注释 = "如果文本不含结束零字符或者要置入部分文本,则必须提供正确的字符长度." @默认值 = -1>
    参数 缓存文本数据 <类型 = 逻辑型 注释 = "默认为假,文本视图将指向提供的\"文本指针\",必须" 注释 = "保证文本指针的生命周期不能比本文本视图短;"
            注释 = "为真时,将使用智能指针缓存所提供的文本数据," 注释 = "文本视图与提供的文本指针不再关联." @默认值 = 假>
    {
        @ @<所欲操作本视图>.SetText (@<文本指针>, static_cast<size_t>(@<文本长度>), @<缓存文本数据>)
    }

    # 删除 ---

    方法 后移起点 <公开 静态 类型 = 文本视图类A 注释 = "  从文本视图的起点向后移动所指定的字符数,以收缩视图的长度," 注释 = "返回文本视图自身."
            注释 = "  本方法只改动指针值,不会修改视图所指向的文本数据." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲移除字符数 <类型 = 变整数 注释 = "所欲从视图起始移除的字符数,大于等于视图长度会将视图删空.">
    {
        @ @<所欲操作本视图>.RemovePrefix (static_cast<size_t>(@<所欲移除字符数>))
    }

    方法 前移终点 <公开 静态 类型 = 文本视图类A 注释 = "  从文本视图的终点向前移动所指定的字符数,以收缩视图的长度," 注释 = "返回文本视图自身."
            注释 = "  本方法只改动指针值,不会修改视图所指向的文本数据." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲移除字符数 <类型 = 变整数 注释 = "所欲从视图终点移除的字符数,大于等于视图长度会将视图删空.">
    {
        @ @<所欲操作本视图>.RemoveSuffix (static_cast<size_t>(@<所欲移除字符数>))
    }

    方法 删首空 <公开 静态 类型 = 文本视图类A 注释 = "删除文本视图首部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.TrimLeft ()
    }

    方法 删尾空 <公开 静态 类型 = 文本视图类A 注释 = "删除文本视图尾部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.TrimRight ()
    }

    方法 删首尾空 <公开 静态 类型 = 文本视图类A 注释 = "删除文本视图首部和尾部的所有空白字符,返回文本视图自身." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.TrimAll ()
    }

    方法 清空视图 <公开 静态 类型 = 文本视图类A 注释 = "  清空文本视图,返回文本视图自身." 注释 = "  清空后文本视图将不再指向任何的文本数据,如果有"
            注释 = "缓存的文本数据,会将智能指针的引用计数减1." 返回值注释 = "返回自身(支持链式语法)" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.Clear ()
    }

    # 寻找 ---

    方法 寻找文本 <公开 静态 类型 = 变整数 注释 = "在视图中寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、字节集类、文本视图类A、标准文本类A" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.SearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 倒找文本 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找所指定文本的索引位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、字节集类、文本视图类A、标准文本类A" @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否不区分英文字母的大小写" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.ReverseSearchText (@<欲寻找的文本>, static_cast<size_t>(@<起始搜寻位置>), @<是否不区分大小写>))
    }

    方法 寻找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找指定字符集合中任意字符的首次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类A、标准文本类A" 注释 = "  字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的首次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindFirstOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找指定字符集合中任意字符的最后一次出现位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类A、标准文本类A" 注释 = "  字符集合中的所有字符都会不分次序地单独查找,返回其中任意字符"
            注释 = "的最后一次出现位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindLastOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 寻找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中寻找首个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类A、标准文本类A" 注释 = "  寻找并返回不等于字符集合中任意字符的首个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置" @默认值 = 0>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindFirstNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    方法 倒找不符合字符集合 <公开 静态 类型 = 变整数 注释 = "在视图中逆向寻找最后一个不等于指定字符集合中任意字符的字符位置,未找到则返回-1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲寻找的字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类A、标准文本类A" 注释 = "  寻找并返回不等于字符集合中任意字符的最后一个字符的位置." @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,如果小于0表示从文本尾部开始查找." @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.FindLastNotOf (@<欲寻找的字符集合>, static_cast<size_t>(@<起始搜寻位置>)))
    }

    # 分割 ---

    方法 分割文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的字符集合进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割字符集合 <注释 = "  支持类型: 文本型、字节集类、文本视图类A、标准文本类A" 注释 = "  提供进行分割时所基于的所有字符,其中的每个字符均在分割时被使用(即遇到其"
            注释 = "中任何一个字符时均认为发现了一个分割点)." 注释 = "  譬如: \",;\\n\", 即指定了基于逗号/分号/换行符三个字符进行分割,遇到了这三"
            注释 = "个字符中的任何一个,均进行一次分割." @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类A 注释 = "用作提供存放所有分割结果文本用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.SplitStrings (@<分割字符集合>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 分割子文本 <公开 静态 类型 = 变整数 注释 = "  将视图基于所指定的子文本进行分割,然后将分割结果存放到所指定的数组中,"
            注释 = "返回存放到所指定数组中的成员数目(即所分割出来的结果文本数目)." 注释 = "  分割结果数组也是指向视图引用的文本数据,请注意维持文本数据的生命周期."
            返回值注释 = "返回所分割出来的结果文本数目." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 分割用子文本 <注释 = "提供进行分割时所基于的子文本,支持类型:" 注释 = " 文本型、字节集类、文本视图类A、标准文本类A" @匹配类型 = 通用型>
    参数 结果存放数组 <类型 = 文本视图容器类A 注释 = "用作提供存放所有分割结果文本视图用的数组,其中的原有内容将被覆盖.">
    参数 是否删除首尾空 <类型 = 逻辑型 注释 = "是否自动删除所有分割结果文本的首尾空白" @默认值 = 真>
    参数 是否忽略空白结果 <类型 = 逻辑型 注释 = "是否自动去除所有为空或全部为空白字符的分割结果文本" @默认值 = 真>
    参数 最大分割数 <类型 = 变整数 注释 = "指定最大的分割次数,达到指定的分割次数后不再继续分割,将剩余的文本存放在" 注释 = "最后一个数组成员中;" 注释 = "默认值-1表示不限制分割次数."
            @默认值 = -1>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.SplitSubStrings (@<分割用子文本>, @<结果存放数组>.data (), @<是否删除首尾空>, @<是否忽略空白结果>, static_cast<size_t>(@<最大分割数>)))
    }

    方法 取文本中间 <公开 静态 类型 = 文本视图类A 注释 = "返回一个文本视图,其中包含本视图中从指定位置算起指定数量的字符." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写." 编辑时信息 = "D725, 0, 0, 0">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将返回索引位置后面" 注释 = "的全部剩余字符." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本视图>.Middle (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本左边 <公开 静态 类型 = 文本视图类A 注释 = "返回一个文本视图,其中包含本视图中从左边算起指定数量的字符." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.Left (static_cast<size_t>(@<欲取出字符的数目>))
    }

    方法 取文本右边 <公开 静态 类型 = 文本视图类A 注释 = "返回一个文本视图,其中包含本视图中从右边算起指定数量的字符." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出字符的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.Right (static_cast<size_t>(@<欲取出字符的数目>))
    }

    # ---

    方法 取中间文字 <公开 静态 类型 = 文本视图类A 注释 = "  返回一个文本视图,其中包含本视图中从指定位置算起指定数量的文字."
            注释 = "  注: 跟\"取文本中间\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写." 编辑时信息 = "D725, 0, 0, 0">
    参数 起始取出索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首文字位置,如果大于视图的文字数量会返回空文本." 编辑时信息 = "D725, 0, 0, 0">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于等于(文字数目-索引位置),将返回索引位置后面" 注释 = "的全部剩余文字." 编辑时信息 = "D725, 0, 0, 0">
    {
        @ @<所欲操作本视图>.MiddleWords (static_cast<size_t>(@<起始取出索引位置>), static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取左边文字 <公开 静态 类型 = 文本视图类A 注释 = "  返回一个文本视图,其中包含本视图中从左边算起指定数量的文字."
            注释 = "  注: 跟\"取文本左边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图文字长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.LeftWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    方法 取右边文字 <公开 静态 类型 = 文本视图类A 注释 = "  返回一个文本视图,其中包含本视图中从右边算起指定数量的文字."
            注释 = "  注: 跟\"取文本右边\"不同,本方法以实际显示的文字为单位(一个文字" 注释 = "可能对应单个或多个字符)." 返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲取出文字的数目 <类型 = 变整数 注释 = "如果提供的值大于大于等于视图文字长度,将返回完整的文本视图.">
    {
        @ @<所欲操作本视图>.RightWords (static_cast<size_t>(@<欲取出文字的数目>))
    }

    # ---

    方法 取所有子文本中间 <公开 静态 类型 = 变整数 注释 = "循环取出所有位于两段指定文本中间的内容,并保存在数组中,返回数组的成员数." 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本对象,本参数无需填写." 编辑时信息 = "2D723, 0, 0, 0">
    参数 子文本数组 <类型 = 文本视图容器类A 注释 = "所有获取的中间子文本会保存在此数组中">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.GetMiddle (@<子文本数组>.data (), @<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                                                 @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>))
    }

    方法 取子文本中间 <公开 静态 类型 = 文本视图类A 注释 = "取出两段文本中间的内容,返回为文本视图." 注释 = "本方法不会产生文本复制."
            返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 开始文本 <注释 = "提供所欲查找的开始文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 结束文本 <注释 = "提供所欲查找的结束文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,必须大于等于0且小于等于文本长度." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含开始文本 <类型 = 逻辑型 注释 = "返回的内容是否包含开始文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含结束文本 <类型 = 逻辑型 注释 = "返回的内容是否包含结束文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本视图>.GetMiddle (@<开始文本>, @<结束文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                              @<是否不区分大小写>, @<是否包含开始文本>, @<是否包含结束文本>, @<失败返回原文本>)
    }

    方法 取子文本左边 <公开 静态 类型 = 文本视图类A 注释 = "寻找提供的文本,然后取出找到的文本左边的内容,返回为文本视图." 注释 = "本方法不会产生文本复制."
            返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本视图>.GetLeft (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                            @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    方法 取子文本右边 <公开 静态 类型 = 文本视图类A 注释 = "寻找提供的文本,然后取出找到的文本右边的内容,返回为文本视图." 注释 = "本方法不会产生文本复制."
            返回值注释 = "返回的文本视图仍指向相同的文本数据" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 要查找的文本 <注释 = "提供所欲查找的文本内容,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" 编辑时信息 = "2D723, 0, 0, 0"
            @匹配类型 = 通用型>
    参数 起始搜寻位置 <类型 = 变整数 注释 = "提供起始查找的索引位置,0为文本的起始位置,-1为文本的末尾." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 0>
    参数 是否不区分大小写 <类型 = 逻辑型 注释 = "默认为假,区分大小写." 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否包含查找文本 <类型 = 逻辑型 注释 = "返回的内容是否包含查找文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    参数 是否反向查找 <类型 = 逻辑型 注释 = "是否从右到左寻找文本,反向查找时请将起始搜寻位置设置为-1." @默认值 = 假>
    参数 失败返回原文本 <类型 = 逻辑型 注释 = "如果找不到中间内容就返回原文本,默认为返回空文本" 编辑时信息 = "2D723, 0, 0, 0" @默认值 = 假>
    {
        @ @<所欲操作本视图>.GetRight (@<要查找的文本>, static_cast<size_t>(@<起始搜寻位置>),
        @                             @<是否不区分大小写>, @<是否包含查找文本>, @<是否反向查找>, @<失败返回原文本>)
    }

    # 比较 ---

    方法 文本比较 <公开 静态 类型 = 整数 注释 = "比较两个文本,返回比较结果." 返回值注释 = "如果返回值小于0,表示本文本小于所比较文本;"
            返回值注释 = "如果等于0,表示本文本等于所比较文本;" 返回值注释 = "如果大于0,表示本文本大于所比较文本." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "提供所欲比较的文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.compare (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 是否相同 <公开 静态 类型 = 逻辑型 注释 = "判断两个文本的内容是否相同" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲比较的文本 <注释 = "所欲比较的另一个文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.IsEqual (@<所欲比较的文本>, @<是否区分大小写>)
    }

    方法 是否以文本开头 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本开头" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其开头的文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.LeadOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 是否以文本结束 <公开 静态 类型 = 逻辑型 注释 = "返回当前文本视图是否以所指定文本结束" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 所欲检查的文本 <注释 = "提供用来检查是否以其结束的文本,支持类型:" 注释 = " 文本型、标准文本类A、文本视图类A、字节集类(多字节)" @匹配类型 = 通用型>
    参数 是否区分大小写 <类型 = 逻辑型 注释 = "指定比较时是否区分英文字母的大小写" @默认值 = 真>
    {
        @ @<所欲操作本视图>.EndOf (@<所欲检查的文本>, @<是否区分大小写>)
    }

    方法 取文本MD5 <公开 静态 类型 = 标准文本类A 注释 = "计算并返回文本的MD5数据摘要(32个字符)." 折叠 @嵌入式方法 = "req_cpp_bool = true"
            @强制依赖 = "MD5校验类">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本对象,本参数无需填写.">
    参数 是否大写 <类型 = 逻辑型 注释 = "默认返回大写字符,为假时返回小写字符." @默认值 = 真>
    {
        @ @dt<标准文本类A> {piv::GetStringMd5 (@<所欲操作本视图>.data (), @<是否大写>)}
    }

    # 输出 ---

    方法 复制文本 <公开 静态 类型 = 变整数 注释 = "将文本视图指定的部分字符复制到提供的缓冲区中,返回复制的字符数." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 欲复制到的目标 <注释 = "  复制文本的目标位置,支持类型: 变整数、字节集类、标准文本类A" 注释 = "  其中变整数为文本指针,必须提前分配好足够的内存空间,"
            注释 = "其余类型会自动分配内存,如实际的复制字符数为0,将清空内容." @匹配类型 = 通用型>
    参数 欲复制的起始索引位置 <类型 = 变整数 注释 = "索引值从0开始,即0代表首字符位置,不能大于视图长度,否则报错.">
    参数 欲复制的字符数目 <类型 = 变整数 注释 = "如果提供的值大于等于(视图长度-索引位置),将复制索引位置" 注释 = "后面的全部剩余字符.">
    {
        @ static_cast<INT_P>(@<所欲操作本视图>.CopyStr (@<欲复制到的目标>, static_cast<size_t>(@<欲复制的起始索引位置>), static_cast<size_t>(@<欲复制的字符数目>)))
    }

    方法 到文本型 <公开 静态 类型 = 文本型 注释 = "返回一个包含当前视图内容的UTF-16LE文本型,本方法会产生内存复制和文本编码转换." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ *PivA2Ws {@<所欲操作本视图>.data ()}
    }

    方法 到标准文本 <公开 静态 类型 = 标准文本类A 注释 = "返回一个包含当前视图内容的标准文本类A(std::string),本方法会产生内存复制." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.ToString ()}
    }

    方法 到十六进制 <公开 静态 类型 = 标准文本类A 注释 = "将本文本的内容转换为十六进制格式的连续文本" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.ToHex (@<是否分隔字符>)}
    }

    方法 到十六进制文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为十六进制格式的连续文本,返回火山的文本型." 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 是否分隔字符 <类型 = 逻辑型 注释 = "是否用空格分隔十六进制字符" @默认值 = 假>
    {
        @ @<所欲操作本视图>.ToHexStr (@<是否分隔字符>)
    }

    方法 到USC2 <公开 静态 类型 = 标准文本类A 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.ToUsc2 (@<编码ASCII字符>)}
    }

    方法 到USC2文本 <公开 静态 类型 = 文本型 注释 = "将本文本的内容转换为以\"\\u\"开头的Unicode编码文本,返回火山的文本型."
            注释 = "例: \"你好,火山!\"编码为\"\\u4f60\\u597d,\\u706b\\u5c71!\"" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "是否编码ASCII字符" @默认值 = 假>
    {
        @ @<所欲操作本视图>.ToUsc2Str (@<编码ASCII字符>)
    }

    # 转换 ---

    方法 到小写 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本中的所有英文字母转换为小写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.MakeLower ()}
    }

    方法 到大写 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本中的所有英文字母转换为大写,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.MakeUpper ()}
    }

    方法 到半角 <公开 静态 类型 = 标准文本类A 注释 = "将文本中所有的全角ASCII字符转换为对应的半角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换全角字符,默认转换全部全角ASCII字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "  可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.ToHalfWidth (@<转换选项>)}
    }

    方法 到全角 <公开 静态 类型 = 标准文本类A 注释 = "将文本中所有的半角ASCII字符转换为对应的全角字符,返回转换后的结果文本." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 转换选项 <类型 = 整数 注释 = "选择要转换半角字符,默认转换全部半角字符,可选参数如下:" 注释 = "  1 = 标点符号;" 注释 = "  2 = 数字(0-9);"
            注释 = "  4 = 英文字母(a-z/A-Z);" 注释 = "  可以使用\"位或\"组合多种选项." @默认值 = 7>
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.ToFullWidth (@<转换选项>)}
    }

    方法 到UTF8 <公开 静态 类型 = 标准文本类U 注释 = "将当前文本的编码转换到UTF-8并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类U> {*PivA2U {@<所欲操作本视图>.data ()}}
    }

    方法 到UTF16 <公开 静态 类型 = 标准文本类 注释 = "将当前文本的编码转换到UTF-16LE并返回." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类> {*PivA2W {@<所欲操作本视图>.data ()}}
    }

    方法 URL编码 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本进行URL编码,返回编码后的文本对象." 返回值注释 = "返回编码后的文本对象" 折叠
            @嵌入式方法 = "req_cpp_bool = true">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 不编码保留字符 <类型 = 逻辑型 注释 = "是否不编码保留字符(;/?:@=&),保留字符在URL中有特殊含义" @默认值 = 假>
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.UrlEncode (false, @<不编码保留字符>)}
    }

    方法 URL解码 <公开 静态 类型 = 标准文本类A 注释 = "将当前文本进行URL解码,返回解码后的文本对象." 返回值注释 = "返回解码后的文本对象" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.UrlDecode (false)}
    }

    # ---

    方法 BASE64编码 <公开 静态 类型 = 标准文本类A 注释 = "返回当前文本数据所对应的BASE64编码格式文本内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 每行最大字符数 <类型 = 整数 注释 = "指定每行编码文本的最大字符数,小于0表示无限制,等于0表示使用默认每行字符数(76)." @默认值 = 0>
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.EncodeBase64 (@<每行最大字符数>)}
    }

    方法 BASE64解码 <公开 静态 类型 = 标准文本类A 注释 = "  将当前的BASE64编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE64到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.DecodeBase64 ()}
    }

    方法 BASE64到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE64编码格式文本解码为对应的字节集后返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.DecodeBase64Bin ()
    }

    # ---

    方法 BASE85编码 <公开 静态 类型 = 标准文本类A 注释 = "返回当前文本数据所对应的BASE85编码格式文本内容" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    参数 自动填充 <类型 = 逻辑型 注释 = "为真时将自动在临时文本后填充0字符,以满足字节对齐为4的倍数." 注释 = "如果为假,文本长度必须为4的倍数,否则将失败返回空文本." @默认值 = 真>
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.EncodeBase85 (@<自动填充>)}
    }

    方法 BASE85解码 <公开 静态 类型 = 标准文本类A 注释 = "  将当前的BASE85编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE85到字节集\"." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.DecodeBase85 ()}
    }

    方法 BASE85到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE85编码格式文本解码为对应的字节集后返回" 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.DecodeBase85Bin ()
    }

    # ---

    方法 BASE91编码 <公开 静态 类型 = 标准文本类A 注释 = "返回当前文本数据所对应的BASE91编码格式文本内容." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.EncodeBase91 ()}
    }

    方法 BASE91解码 <公开 静态 类型 = 标准文本类A 注释 = "  将当前的BASE91编码格式文本解码为对应的文本后返回," 注释 = "由于解码出来的数据可能不是文本数据,或文本编码与当前"
            注释 = "文本对象不一致,因此可能会出现乱码,这种情况下建议使" 注释 = "用\"BASE91到字节集\"." 注释 = "  保留ASCII字符为{<>\"}." 折叠 @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @dt<标准文本类A> {@<所欲操作本视图>.DecodeBase91 ()}
    }

    方法 BASE91到字节集 <公开 静态 类型 = 字节集类 注释 = "将所当前的BASE91编码格式文本解码为对应的字节集后返回." 注释 = "保留ASCII字符为{<>\"}." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本视图 <类型 = 文本视图类A 注释 = "所欲操作的文本视图,本参数无需填写.">
    {
        @ @<所欲操作本视图>.DecodeBase91Bin ()
    }
}

# ===

类 二维文本数组类 <公开 基础类 = 对象数组模板类 注释 = "二维的文本数组类" @文档 = "category = \"数据类型\"" @模板实现类 = "文本数组类">

# OpenCC ====

类 OpenCC简繁转换类 <公开 注释 = "  中文简繁转换开源项目,支持词汇级别的转换、异体字转换" 注释 = "和地区习惯用词转换(中国大陆、台湾、香港、日本新字体)."
        注释 = "  源码: https://github.com/BYVoid/OpenCC" 注释 = "  版本: 1.1.6" 折叠 @文档 = "category = \"文本操作\""
        @视窗.外部头文件 = "OpenCC\\include\\opencc.h" @视窗.外部库 = "OpenCC\\$(p)\\opencc.lib"
        @视窗.附属文件 = "OpenCC\\$(p)\\opencc.dll" @视窗.附属文件 = "附属文件\\opencc > opencc">
{
    方法 类_清理 <折叠>
    {
        销毁 ()
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "初始化OpenCC并选择使用的配置文件,配置文件决定了转换的类型." 注释 = "注意: 本方法可能会耗时2秒以上."
            返回值注释 = "返回是否成功,失败时可用\"取错误信息\"获取失败原因." 折叠 @禁止流程检查 = 真>
    参数 配置文件 <类型 = OpenCC配置文件 注释 = "  提供中文简体转换的配置文件名,配置文件决定转换方式," 注释 = "  比如\"简体到繁体\"和\"繁体到简体\"等."
            @默认值 = OpenCC配置文件.简体到繁体>
    参数 配置路径 <类型 = 文本型 注释 = "  提供OpenCC配置文件所在位置的绝对路径,默认为\"运行目录\\opencc\\\","
            注释 = "如果你需要自定义该路径,请更改本参数并在编译后手动移动opencc文件夹." @默认值 = 空对象>
    {
        销毁 ()
        @ @an<CVolString> szConfigFileName;
        @ if (@<配置路径>.IsEmpty ()) {
        @     GetInstancePath (szConfigFileName);
        @     szConfigFileName.AddText (L"opencc\\");
        @ } else {
        @     szConfigFileName.AddText (@<配置路径>.GetText ());
        @ }
        @ szConfigFileName.CheckAddPathChar ();
        @ szConfigFileName.AddText (@<配置文件>.GetText ());
        @ m_opencc = opencc_open_w (szConfigFileName.GetText ());
        @ return (m_opencc != (opencc_t)-1);
    }

    方法 转换字节集 <公开 类型 = 字节集类 注释 = "根据\"初始化\"提供的配置类型进行UTF8文本数据的转换." 返回值注释 = "成功返回UTF8编码的转换结果,失败返回空字节集." 折叠
            @禁止流程检查 = 真>
    参数 欲转换文本数据 <类型 = 字节集类 注释 = "提供所欲转换的文本数据,必须为UTF8编码">
    参数 是否包括结束零字符 <类型 = 逻辑型 注释 = "指定在所转换到的结果文本字节集中是否包括结束零字符" @默认值 = 假>
    {
        @ if (m_opencc == (opencc_t)-1) return @an<CVolMem> ();
        @ @an<CVolMem> out;
        @ char* converted = opencc_convert_utf8 (m_opencc,
        @                   reinterpret_cast<const char*>(@<欲转换文本数据>.GetPtr ()), @<欲转换文本数据>.GetSize ());
        @ if (converted) {
        @     out.Append (converted, strlen (converted) + (@<是否包括结束零字符> ? 1 : 0));
        @     opencc_convert_utf8_free (converted);
        @ }
        @ return out;
    }

    方法 转换文本 <公开 类型 = 文本型 注释 = "根据\"初始化\"提供的配置类型进行文本数据的转换." 返回值注释 = "成功返回转换结果,失败返回空文本." 折叠 @禁止流程检查 = 真>
    参数 欲转换文本 <类型 = 文本型 注释 = "提供所欲转换的文本">
    {
        返回 (UTF8到文本 (本对象.转换字节集 (文本到UTF8 (欲转换文本, 假), 假)))
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "释放OpenCC,释放后必须重新初始化才能进行转换." 注释 = "类析构时会自动销毁,一般无需手动调用." 折叠 @禁止流程检查 = 真>
    {
        @ if (m_opencc != (opencc_t)-1) {
        @     if (opencc_close (m_opencc) == 0)
        @         m_opencc = (opencc_t)-1;
        @     else
        @         return FALSE;
        @ }
        @ return TRUE;
    }

    方法 取错误信息 <公开 类型 = 文本型 注释 = "获取OpenCC最后一次返回的错误信息." 注释 = "注意: 本方法非线程安全,为OpenCC全局返回的错误." 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString> ((const CHAR*)opencc_error())
    }

    # @begin
    # <> <include>
    # opencc_t m_opencc = (opencc_t) -1;
    # <> </include>
    # @end
}

类 OpenCC配置文件 <公开 注释 = "中文简繁转换的类型" 折叠 @文档 = "category = \"文本操作.辅助类\"" @常量类 = 文本型>
{
    常量 简体到繁体 <公开 值 = "s2t.json">
    常量 繁体到简体 <公开 值 = "t2s.json">
    常量 简体到台湾正体 <公开 值 = "s2tw.json">
    常量 台湾正体到简体 <公开 值 = "tw2s.json">
    常量 简体到香港繁体 <公开 值 = "s2hk.json">
    常量 香港繁体到简体 <公开 值 = "hk2s.json">
    常量 简体到台湾正体词汇 <公开 值 = "s2twp.json" 注释 = "简体到繁体(台湾正体标准)并转换为台湾常用词汇">
    常量 台湾正体到简体词汇 <公开 值 = "tw2sp.json" 注释 = "繁体(台湾正体标准)到简体并转换为中国大陆常用词汇">
    常量 繁体到台湾正体 <公开 值 = "t2tw.json" 注释 = "繁体(OpenCC标准)到台湾正体">
    常量 香港繁体到繁体 <公开 值 = "hk2t.json" 注释 = "香港繁体到繁体(OpenCC标准)">
    常量 繁体到香港繁体 <公开 值 = "t2hk.json" 注释 = "繁体(OpenCC标准)到香港繁体">
    常量 繁体到日文新字体 <公开 值 = "t2jp.json" 注释 = "繁体(OpenCC标准,旧字体)到日文新字体">
    常量 日文新字体到繁体 <公开 值 = "jp2t.json" 注释 = "日文新字体到繁体(OpenCC标准,旧字体)">
    常量 台湾正体到繁体 <公开 值 = "tw2t.json" 注释 = "台湾正体到繁体(OpenCC标准)">

    #
}

#
