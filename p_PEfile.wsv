<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "PE文件解析与操作" 注释 = "https://github.com/SaierMe/piv" @视窗.外部头文件 = "src\\PEfile.hpp">

类 PE文件操作类 <公开 注释 = "解析可执行文件的各种数据." 折叠 @文档 = "category = \"PE文件操作\"">
{

    # @ @m<DECLARE_REF_OBJECT_CLASS_WITH_DATA> (CPeFileInfo)

    方法 打开文件 <公开 类型 = 逻辑型 注释 = "打开并解析指定文件路径的可执行文件." 返回值注释 = "返回是否解析成功." 折叠 @嵌入式方法 = "">
    参数 文件名 <类型 = 文本型 注释 = "请提供包含完整路径的文件名.">
    {
        @ (BOOL)@sn<this>.data ().OpenPeFile (@<文件名>.GetText ())
    }

    方法 打开数据 <公开 类型 = 逻辑型 注释 = "打开并解析内存中的可执行数据." 返回值注释 = "返回是否解析成功." 折叠 @嵌入式方法 = "">
    参数 数据指针 <类型 = 变整数 注释 = "可执行数据的首地址(基址)">
    参数 数据大小 <类型 = 整数 注释 = "可执行文件的字节大小">
    参数 是否已对齐 <类型 = 逻辑型 注释 = "  请确定可执行数据是否已经内存对齐." 注释 = "  如果是原始的PE文件,请设置为假." 注释 = "  如果节区已经被对齐,请设置为真."
            @默认值 = 假>
    参数 是否已加载 <类型 = 逻辑型 注释 = "  请确定可执行数据是否已经被加载运行." 注释 = "  如果是原始的PE文件,请设置为假."
            注释 = "  如果是系统已经加载运行的模块,请设置为真." @默认值 = 假>
    {
        @ (BOOL)@sn<this>.data ().OpenPeData ((void*)@<数据指针>, (DWORD)@<数据大小>, @<是否已对齐>, @<是否已加载>)
    }

    方法 打开模块 <公开 类型 = 逻辑型 注释 = "打开并解析系统中已加载的模块." 返回值注释 = "返回是否解析成功." 折叠 @禁止流程检查 = 真>
    参数 进程ID <类型 = 整数 注释 = "  0为当前进程" @默认值 = 0>
    参数 模块名称 <类型 = 文本型 注释 = "  请提供模块的文件名称(区分大小写)." 注释 = "  如省略扩展名则默认为\".dll\". 结尾为\".\"则表示模块名称没有扩展名."
            注释 = "  该名称可以不包含路径,如果指定路径,必须用反斜杠\"\\\\\"." 注释 = "  留空为打开进程的exe文件." @默认值 = 空对象>
    {
        变量 进程操作 <类型 = 进程操作类>
        变量 模块信息 <类型 = 模块信息类>
        变量 模块句柄 <类型 = 变整数>
        如果 (进程操作.打开进程 (进程ID) == 真)
        {
            模块句柄 = 进程操作.取模块句柄 (模块名称)
            如果 (进程操作.取模块信息 (模块句柄, 模块信息) == 真)
            {
                @ return (BOOL)data ().OpenPeData ((void*)@<模块信息.lpBaseOfDll>, (DWORD)@<模块信息.SizeOfImage>, TRUE, TRUE);

            }

        }
        返回 (假)
    }

    方法 关闭数据 <公开 注释 = "关闭文件并释放数据,类析构时会自动执行." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data ().ClosePeData ()
    }

    方法 保存数据 <公开 类型 = 逻辑型 注释 = "将当前打开的可执行数据保存到新文件中." 返回值注释 = "返回是否保存成功." 折叠 @嵌入式方法 = "">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲写到文件的路径名称">
    参数 是否修复PE结构 <类型 = 逻辑型 注释 = "是否将已加载到内存中运行的PE数据还原成PE文件结构." @默认值 = 真>
    {
        @ (BOOL)@sn<this>.data ().SavePeDatas (@<文件名>.GetText(), @<是否修复PE结构>)
    }

    方法 是否可写 <公开 类型 = 逻辑型 注释 = "返回当前的PE数据是否处于可写的内存区域中." 返回值注释 = "返回真表示数据可写." 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data ().IsWriteable ()
    }

    方法 复制到新内存 <公开 类型 = 变整数 注释 = "  将可执行数据复制到新的内存地址,本类默认以只读方式打开PE数据," 注释 = "如果要进行改写操作,必须执行本方法."
            注释 = "  新的内存尺寸跟\"取映像尺寸\"的返回值一样." 返回值注释 = "  成功返回新的内存地址,失败返回0." 返回值注释 = "  成功后将关闭之前打开的文件句柄和内存映射文件." 折叠
            @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data ().CopyToNewMem (TRUE)
    }

    方法 加载内存PE <公开 类型 = 逻辑型 注释 = "将PE数据复制到可执行可读写的新内存,并进行内存对齐、地址重定位和绑定导入表函数地址." 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data ().MemLoadPE ()
    }

    方法 取最后错误 <公开 类型 = 整数 注释 = "  返回本类最后一次的操作结果,0表示操作成功,其他值表示有错误," 注释 = "可以调用\"取错误信息\"得知具体的中文错误信息." 折叠
            @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data ().GetErrorCode ()
    }

    方法 取最后错误信息 <公开 类型 = 文本型 注释 = "返回本类最后一次的操作结果." 返回值注释 = "返回的是含错误代码和中文错误描述的文本型." 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString> (@sn<this>.data ().GetErrorMessage ())
    }

    方法 取数据指针 <公开 类型 = 变整数 注释 = "  获取可执行文件在内存中的基址,请勿对不可写的内存区域进行写操作," 注释 = "可能会导致程序崩溃,进行写操作前请先用\"是否可写\"方法判断."
            返回值注释 = "必须先\"解析文件\"成功才能返回有效数据." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data ().GetBaseAddress ()
    }

    方法 取数据尺寸 <公开 类型 = 整数 注释 = "获取可执行文件当前占用的内存大小." 返回值注释 = "成功返回内存大小,失败返回0." 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data ().GetDataSize ()
    }

    方法 取映像尺寸 <公开 类型 = 整数 注释 = "计算出可执行文件被系统加载到内存之后的映像尺寸." 返回值注释 = "成功返回映像文件大小,失败返回0." 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data ().CalcTotalImageSize ()
    }

    方法 取文件尺寸 <公开 类型 = 整数 注释 = "计算出可执行文件的原始文件尺寸." 返回值注释 = "成功返回文件尺寸,失败返回0." 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data ().CalcPeFileSize ()
    }

    方法 是否为64位 <公开 类型 = 逻辑型 注释 = "返回可执行文件是否为64位." 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data ().Is64Pe ()
    }

    方法 是否为DLL <公开 注释 = "返回可执行文件是否为DLL文件." 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data ().IsDllData ()
    }

    方法 是否为EXE <公开 注释 = "返回可执行文件是否为EXE文件." 折叠 @嵌入式方法 = "">
    {
        @ (BOOL)@sn<this>.data ().IsExeData ()
    }

    方法 取映像基址 <公开 类型 = 长整数 注释 = "获取可执行文件的映像基址(ImageBase),32位PE可强制转换到整数." 返回值注释 = "失败返回0." 折叠 @嵌入式方法 = "">
    {
        @ (INT64)@sn<this>.data ().GetImageBase ()
    }

    方法 取入口点 <公开 类型 = 整数 注释 = "获取可执行文件的代码入口点(EntryPoint)." 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data ().GetEntryPoint ()
    }

    方法 取DOS头 <公开 类型 = IMAGE_DOS_HEADER 注释 = "获取可执行文件的DOS头数据." 折叠 @禁止流程检查 = 真>
    {
        变量 DOS头部 <类型 = IMAGE_DOS_HEADER>
        @ PIMAGE_DOS_HEADER pDos = data ().GetDosHeader ();
        @ if (pDos)
        @     @<DOS头部>.SetStruct ((@dt<IMAGE_DOS_HEADER>::S*)pDos);
        返回 (DOS头部)
    }

    方法 取NT头32 <公开 类型 = IMAGE_NT_HEADERS32 注释 = "获取32位可执行文件的NT头数据." 折叠>
    {
        变量 NT头部32 <类型 = IMAGE_NT_HEADERS32 注释 = "成功在此返回NT头信息">
        @ if (data ().Is64Pe () == FALSE)
        @ {
        @     PIMAGE_NT_HEADERS32 pNt32 = data ().GetNtHeader ();
        @     if (pNt32)
        @         @<NT头部32>.SetStruct ((@dt<IMAGE_NT_HEADERS32>::S*)pNt32);
        @ }
        返回 (NT头部32)
    }

    方法 取NT头64 <公开 类型 = IMAGE_NT_HEADERS64 注释 = "获取64位可执行文件的NT头数据." 折叠>
    {
        变量 NT头部64 <类型 = IMAGE_NT_HEADERS64 注释 = "成功在此返回NT头信息">
        @ if (data ().Is64Pe ())
        @ {
        @     PIMAGE_NT_HEADERS64 pNt64 = (PIMAGE_NT_HEADERS64)data ().GetNtHeader ();
        @     if (pNt64)
        @         @<NT头部64>.SetStruct ((@dt<IMAGE_NT_HEADERS64>::S*)pNt64);
        @ }
        返回 (NT头部64)
    }

    方法 取节区表 <公开 类型 = 整数 注释 = "获取可执行文件的节区表." 返回值注释 = "成功返回节区数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 节区表数组 <类型 = 节区表数组类 注释 = "成功在此返回节区表数组">
    {
        @ @<节区表数组>.ResetToNullObject ();
        @ DWORD dwSectionCount;
        @ PIMAGE_SECTION_HEADER pSection = data ().GetSectionHeader (&dwSectionCount);
        @ if (dwSectionCount > 0)
        @ {
        @     for (DWORD i = 0; i < dwSectionCount; ++i) // 解析节区表
        @     {
        @         @dt<IMAGE_SECTION_HEADER> Section;
        @         Section.SetStruct ((@dt<IMAGE_SECTION_HEADER>::S*)&pSection[i]);
        @         @<节区表数组>.Add (Section, NULL);
        @     }
        @     return (INT)@<节区表数组>.GetCount ();
        @ }
        @ return 0;
    }

    方法 取导出表头 <公开 类型 = IMAGE_EXPORT_DIRECTORY 注释 = "获取DLL文件的函数导出表头数据,EXE文件没有导出表." 返回值注释 = "返回是否成功." 折叠>
    {
        变量 导出表头 <类型 = IMAGE_EXPORT_DIRECTORY>
        @ PIMAGE_EXPORT_DIRECTORY pExport = data ().GetExportHeader();
        @ if (pExport)
        @     @<导出表头>.SetStruct ((@dt<IMAGE_EXPORT_DIRECTORY>::S*)pExport);
        返回 (导出表头)
    }

    方法 取导入表描述符 <公开 类型 = 整数 注释 = "获取可执行文件的导入表头数据." 返回值注释 = "成功返回导入表描述符数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 导入表描述符数组 <类型 = 导入表描述符数组类 注释 = "成功在此返回导入表描述符数组">
    {
        @ @<导入表描述符数组>.ResetToNullObject ();
        @ PIMAGE_IMPORT_DESCRIPTOR pImport = data ().GetImportDescriptor ();
        @ if (pImport)
        @ {
        @     while (pImport->Name)
        @     {
        @         @dt<IMAGE_IMPORT_DESCRIPTOR> ImportDes;
        @         ImportDes.SetStruct ((@dt<IMAGE_IMPORT_DESCRIPTOR>::S*)pImport);
        @         @<导入表描述符数组>.Add (ImportDes, NULL);
        @         pImport++;
        @     }
        @     return (INT)@<导入表描述符数组>.GetCount ();
        @ }
        @ return 0;
    }

    # ---

    方法 取导入表 <公开 类型 = 整数 注释 = "获取可执行文件的模块导入表信息." 返回值注释 = "成功返回导入的模块数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 导入表 <类型 = 导入表数组类 注释 = "成功在此返回导入表信息">
    {
        @ @<导入表>.RemoveAll ();
        @ std::vector<CVolString> vModuleName;
        @ std::vector<std::vector<DWORD> > vFunOrdinal;
        @ std::vector<std::vector<ULONGLONG> > vFunAddress;
        @ std::vector<std::vector<CVolString> > vFunName;
        @ DWORD dwNumOfModule = data ().GetImportInfo (&vModuleName, &vFunOrdinal, &vFunAddress, &vFunName);
        @ for (DWORD i = 0; i < dwNumOfModule; i++)
        @ {
        @     @dt<导出表类> Dir;
        @     Dir.ModuleName = vModuleName[i];
        @     for (DWORD y = 0; y < vFunOrdinal[i].size(); y++)
        @     {
        @         @dt<PE函数类> Info;
        @         Info.FunctionAddress = (INT64)vFunAddress[i][y];
        @         Info.FunctionOrdinal = (INT)vFunOrdinal[i][y];
        @         Info.FunctionName = vFunName[i][y];
        @         Dir.aFunctions.Add (Info, NULL);
        @     }
        @     @<导入表>.Add (Dir, NULL);
        @ }
        @ return (INT)@<导入表>.GetCount ();
    }

    方法 取导出表 <公开 类型 = 整数 注释 = "获取DLL文件的函数导出表信息,EXE文件没有导出表." 返回值注释 = "成功返回导出的函数数量,失败返回0." 折叠 @禁止流程检查 = 真>
    参数 导出表 <类型 = 导出表类 注释 = "成功在此返回导出表信息">
    {
        @ @<导出表>.ResetToNullObject ();
        @ CVolString sModuleName;
        @ std::vector<DWORD> vFunOrdinal;
        @ std::vector<DWORD> vFunAddress;
        @ std::vector<CVolString> vFunName;
        @ DWORD dwNumOfFun = data ().GetExportInfo (&sModuleName, &vFunOrdinal, &vFunAddress, &vFunName);
        @ if (dwNumOfFun == 0) return 0;
        @ @<导出表>.ModuleName = sModuleName;
        @ for (DWORD i = 0; i < dwNumOfFun; i++)
        @ {
        @     @dt<PE函数类> Info;
        @     Info.FunctionAddress = (INT64)vFunAddress[i];
        @     Info.FunctionOrdinal = (INT)vFunOrdinal[i];
        @     Info.FunctionName = vFunName[i];
        @     @<导出表>.aFunctions.Add (Info, NULL);
        @ }
        @ return (INT)@<导出表>.aFunctions.GetCount ();
    }

    # ---

    方法 相对虚拟地址到文件偏移 <公开 类型 = 整数 注释 = "将相对虚拟地址(RVA)转换到文件偏移量(FOA)." 折叠 @嵌入式方法 = "">
    参数 相对虚拟地址 <类型 = 整数>
    {
        @ (INT)@sn<this>.data ().Rva2Foa ((DWORD)@<相对虚拟地址>)
    }

    方法 文件偏移到相对虚拟地址 <公开 类型 = 整数 注释 = "将文件偏移量(FOA)转换到相对虚拟地址(RVA)." 返回值注释 = "失败返回0" 折叠 @嵌入式方法 = "">
    参数 文件偏移 <类型 = 整数>
    {
        @ (INT)@sn<this>.data ().Foa2Rva ((DWORD)@<文件偏移>)
    }
}

# ---

类 内存DLL加载类 <公开 注释 = "  本类不使用系统的加载器载正常加载DLL模块,而是手动修改DLL的PE数据" 注释 = "并运行,因此成功加载的DLL没有模块句柄,也不会被系统API枚举出来."
        注释 = "  * 将DLL数据复制到一块新申请的可执行可读写的虚拟内存,然后对DLL的" 注释 = "PE数据进行内存对齐、地址重定位和绑定导入表函数地址,最后执行DLL模块"
        注释 = "的入口点函数." 注释 = "  * 在类析构或卸载模块之前,可以获取DLL导出表里的函数并调用." 注释 = "  * 只能在当前进程中加载,不支持注入到其他进程."
        注释 = "  * 兼容32位和64位的程序,DLL模块和进程的位数不符会返回失败." 注释 = "  * 若重建导入表时,有模块未被系统加载,会自动调用LoadLibrary加载,"
        注释 = "卸载模块时会自动FreeLibrary(例如该DLL有依赖其他非系统的DLL)." 折叠 @文档 = "category = \"内存注入\"">
{

    # @ @m<DECLARE_REF_OBJECT_CLASS_WITH_DATA> (CMemLoadDll)

    方法 保存数据 <公开 类型 = 逻辑型 注释 = "!!!功能未完成,未修复内存中的PE数据!!!" 注释 = "将当前打开的可执行数据保存到新文件中." 返回值注释 = "返回是否保存成功." 折叠
            @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "提供所欲写到文件的路径名称">
    {
        @ return (BOOL)WriteDataIntoFile (@<文件名>.GetText(), data ().GetBaseAddress (), (INT_P)data ().GetDataSize ());
    }

    方法 加载模块 <公开 类型 = 逻辑型 注释 = "  在内存中加载DLL数据,并运行DLL的入口点函数.提供的DLL数据" 注释 = "必须是未经修改的(内容跟磁盘的DLL文件一致),否则会崩溃."
            注释 = "  除非DLL已经被卸载,再次调用此方法不会重复加载DLL." 注释 = "  本方法不支持EXE."
            返回值注释 = "  返回是否加载成功.本类只支持加载DLL文件,如果程序和DLL的程序" 返回值注释 = "位数不同亦返回假." 折叠 @嵌入式方法 = "">
    参数 DLL数据地址 <类型 = 变整数 注释 = "DLL数据在内存中的地址,请提供原始的DLL数据">
    参数 DLL数据大小 <类型 = 整数 注释 = "DLL数据的字节大小">
    {
        @ @sn<this>.data ().MemLoadLibrary ((void*)@<DLL数据地址>, (DWORD)@<DLL数据大小>)
    }

    方法 卸载模块 <公开 注释 = "  卸载内存DLL,卸载后请勿再调用DLL中的函数,否则会造成崩溃." 注释 = "  类析构时会自动卸载,一般不需要手动调用." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data ().MemFreeLibrary ()
    }

    方法 函数名取地址 <公开 类型 = 变整数 注释 = "获取DLL模块中指定名称的函数地址(VA)." 返回值注释 = "成功返回函数地址,失败返回0." 折叠 @嵌入式方法 = "">
    参数 函数名称 <类型 = 文本型 注释 = "所欲取地址的函数名称">
    {
        @ (INT_P)@sn<this>.data ().MemGetProcAddress ((LPCSTR)GetMbsText(@<函数名称>.GetText (), CVolMem (), NULL))
    }

    方法 函数序号取地址 <公开 类型 = 变整数 注释 = "获取DLL模块中指定序号的函数地址(VA)." 返回值注释 = "成功返回函数地址,失败返回0." 折叠 @嵌入式方法 = "">
    参数 函数序号 <类型 = 整数 注释 = "所欲取地址的函数序号,起始序号应大于等于1.">
    {
        @ (INT_P)@sn<this>.data ().MemGetProcAddress ((LPCSTR)@<函数序号>)
    }

    方法 取模块基址 <公开 类型 = 变整数 注释 = "获取内存DLL在虚拟内存中的模块基址(VA)." 返回值注释 = "未加载时返回0." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data ().GetBaseAddress ()
    }

    方法 取模块尺寸 <公开 类型 = 整数 注释 = "  获取DLL数据在内存对齐之后的映像尺寸,该尺寸不等于DLL" 注释 = "的文件尺寸." 返回值注释 = "成功返回模块的尺寸,失败返回0." 折叠
            @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data ().CalcTotalImageSize ()
    }

    方法 是否已加载 <公开 类型 = 逻辑型 注释 = "返回是否已经成功加载了内存DLL." 返回值注释 = "已加载返回真,否则返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data ().IsLoadOk ()
    }

    方法 取最后错误 <公开 类型 = 整数 注释 = "  返回本类最后一次的操作结果,0表示操作成功,其他值表示有错误," 注释 = "可以调用\"取错误信息\"得知具体的中文错误信息." 折叠
            @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data ().GetErrorCode ()
    }

    方法 取最后错误信息 <公开 类型 = 文本型 注释 = "返回本类最后一次的操作结果." 返回值注释 = "返回的是含错误代码和中文错误描述的文本型." 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString> (@sn<this>.data ().GetErrorMessage ())
    }
}

# ------

类 IMAGE_DOS_HEADER <公开 注释 = "PE文件DOS头,64字节" 折叠 @文档 = "category = \"PE文件操作.辅助类\"" @视窗.结构类 = 0>
{
    变量 e_magic <公开 类型 = 短整数 注释 = "DOS可执行文件头标记,必定为\"MZ\"(0x5A4D 4Dh 5Ah/23117)IMAGE_DOS_SIGNATURE">
    变量 e_cblp <公开 类型 = 短整数 注释 = "文件最后页的字节数">
    变量 e_cp <公开 类型 = 短整数 注释 = "文件中的全部和部分页数">
    变量 e_crlc <公开 类型 = 短整数 注释 = "重定位表中的指针数">
    变量 e_cparhdr <公开 类型 = 短整数 注释 = "头部尺寸,以段落为单位">
    变量 e_minalloc <公开 类型 = 短整数 注释 = "所需的最小附加段">
    变量 e_maxalloc <公开 类型 = 短整数 注释 = "所需的最大附加段">
    变量 e_ss <公开 类型 = 短整数 注释 = "初始的堆栈段(SS)相对偏移量值">
    变量 e_sp <公开 类型 = 短整数 注释 = "初始的堆栈指针(SP)值">
    变量 e_csum <公开 类型 = 短整数 注释 = "校验和">
    变量 e_ip <公开 类型 = 短整数 注释 = "初始的指令指针(IP)值">
    变量 e_cs <公开 类型 = 短整数 注释 = "初始的代码段(CS)相对偏移量值">
    变量 e_lfarlc <公开 类型 = 短整数 注释 = "重定位表在文件中的偏移地址">
    变量 e_ovno <公开 类型 = 短整数 注释 = "覆盖号">
    变量 e_res <公开 类型 = "短整数 [4]" 注释 = "保留字(一般是为确保对齐而预留)">
    变量 e_oemid <公开 类型 = 短整数 注释 = "OEM标识符(相对于e_oeminfo)">
    变量 e_oeminfo <公开 类型 = 短整数 注释 = "OEM信息,即e_oemid的细节">
    变量 e_res2 <公开 类型 = "短整数 [10]" 注释 = "保留字(一般是为确保对齐而预留)">
    变量 e_lfanew <公开 类型 = 整数 注释 = "NT头(IMAGE_NT_HEADERS)在文件中的偏移地址">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        变量 i <类型 = 整数>
        展示内容 = "<IMAGE_DOS_HEADER> 总共 19 个成员:\r\n"
        加入文本 (展示内容, "1. e_magic: " + 取调试文本2 (最大展示数据尺寸, e_magic) + "\r\n")
        加入文本 (展示内容, "2. e_cblp: " + 取调试文本2 (最大展示数据尺寸, e_cblp) + "\r\n")
        加入文本 (展示内容, "3. e_cp: " + 取调试文本2 (最大展示数据尺寸, e_cp) + "\r\n")
        加入文本 (展示内容, "4. e_crlc: " + 取调试文本2 (最大展示数据尺寸, e_crlc) + "\r\n")
        加入文本 (展示内容, "5. e_cparhdr: " + 取调试文本2 (最大展示数据尺寸, e_cparhdr) + "\r\n")
        加入文本 (展示内容, "6. e_minalloc: " + 取调试文本2 (最大展示数据尺寸, e_minalloc) + "\r\n")
        加入文本 (展示内容, "7. e_maxalloc: " + 取调试文本2 (最大展示数据尺寸, e_maxalloc) + "\r\n")
        加入文本 (展示内容, "8. e_ss: " + 取调试文本2 (最大展示数据尺寸, e_ss) + "\r\n")
        加入文本 (展示内容, "9. e_sp: " + 取调试文本2 (最大展示数据尺寸, e_sp) + "\r\n")
        加入文本 (展示内容, "10. e_csum: " + 取调试文本2 (最大展示数据尺寸, e_csum) + "\r\n")
        加入文本 (展示内容, "11. e_ip: " + 取调试文本2 (最大展示数据尺寸, e_ip) + "\r\n")
        加入文本 (展示内容, "12. e_cs: " + 取调试文本2 (最大展示数据尺寸, e_cs) + "\r\n")
        加入文本 (展示内容, "13. e_lfarlc: " + 取调试文本2 (最大展示数据尺寸, e_lfarlc) + "\r\n")
        加入文本 (展示内容, "14. e_ovno: " + 取调试文本2 (最大展示数据尺寸, e_ovno) + "\r\n")
        加入文本 (展示内容, "15. e_res: {" + 到文本 (e_res [0]))
        循环 (1, 4, i, 1)
        {
            加入文本 (展示内容, ", " + 到文本 (e_res [i]))
        }
        加入文本 (展示内容, "}\r\n")
        加入文本 (展示内容, "16. e_oemid: " + 取调试文本2 (最大展示数据尺寸, e_oemid) + "\r\n")
        加入文本 (展示内容, "17. e_oeminfo: " + 取调试文本2 (最大展示数据尺寸, e_oeminfo) + "\r\n")
        加入文本 (展示内容, "18. e_res2: {" + 到文本 (e_res2 [0]))
        循环 (1, 10, i, 1)
        {
            加入文本 (展示内容, ", " + 到文本 (e_res2 [i]))
        }
        加入文本 (展示内容, "}\r\n")
        加入文本 (展示内容, "19. e_lfanew: " + 取调试文本2 (最大展示数据尺寸, e_lfanew) + "\r\n")
    }
}

类 IMAGE_NT_HEADERS32 <公开 注释 = "32位PE文件NT头"
        注释 = "https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers32" 折叠
        @文档 = "category = \"PE文件操作.辅助类\"" @视窗.结构类 = 0>
{
    变量 Signature <公开 类型 = 整数 注释 = "  PE文件的标识,固定为\"PE\\0\\0\"{50,45,00,00},整数为 0x4550/17744"
            注释 = "  IMAGE_DOS_SIGNATURE    0x5A4D      MZ" 注释 = "  IMAGE_OS2_SIGNATURE    0x454E      NE"
            注释 = "  IMAGE_OS2_SIGNATURE_LE 0x454C      LE" 注释 = "  IMAGE_VXD_SIGNATURE    0x454C      LE"
            注释 = "  IMAGE_NT_SIGNATURE     0x00004550  PE00">
    变量 FileHeader <公开 类型 = IMAGE_FILE_HEADER 注释 = "映像文件头结构体(20个字节)">
    变量 OptionalHeader <公开 类型 = IMAGE_OPTIONAL_HEADER32 注释 = "映像可选头结构体32位">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<IMAGE_NT_HEADERS32> 总共 3 个成员:\r\n"
        加入文本 (展示内容, "1. Signature: " + 取调试文本2 (最大展示数据尺寸, Signature) + "\r\n")
        加入文本 (展示内容, "2. FileHeader: " + 取调试文本2 (最大展示数据尺寸, FileHeader) + "\r\n")
        加入文本 (展示内容, "3. OptionalHeader: " + 取调试文本2 (最大展示数据尺寸, OptionalHeader) + "\r\n")
    }
}

类 IMAGE_NT_HEADERS64 <公开 注释 = "64位PE文件NT头"
        注释 = "https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64" 折叠
        @文档 = "category = \"PE文件操作.辅助类\"" @视窗.结构类 = 0>
{
    变量 Signature <公开 类型 = 整数 注释 = "  PE文件的标识,固定为\"PE\\0\\0\"{50,45,00,00},整数为 0x4550/17744"
            注释 = "  IMAGE_DOS_SIGNATURE    0x5A4D      MZ" 注释 = "  IMAGE_OS2_SIGNATURE    0x454E      NE"
            注释 = "  IMAGE_OS2_SIGNATURE_LE 0x454C      LE" 注释 = "  IMAGE_VXD_SIGNATURE    0x454C      LE"
            注释 = "  IMAGE_NT_SIGNATURE     0x00004550  PE00">
    变量 FileHeader <公开 类型 = IMAGE_FILE_HEADER 注释 = "映像文件头部结构体(20个字节)">
    变量 OptionalHeader <公开 类型 = IMAGE_OPTIONAL_HEADER64 注释 = "映像可选头部结构体64位">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<IMAGE_NT_HEADERS64> 总共 3 个成员:\r\n"
        加入文本 (展示内容, "1. Signature: " + 取调试文本2 (最大展示数据尺寸, Signature) + "\r\n")
        加入文本 (展示内容, "2. FileHeader: " + 取调试文本2 (最大展示数据尺寸, FileHeader) + "\r\n")
        加入文本 (展示内容, "3. OptionalHeader: " + 取调试文本2 (最大展示数据尺寸, OptionalHeader) + "\r\n")
    }
}

类 IMAGE_FILE_HEADER <公开 注释 = "PE文件逻辑分布信息,20字节."
        注释 = "https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_file_header" 折叠
        @文档 = "category = \"PE文件操作.辅助类\"" @视窗.结构类 = 0>
{
    变量 Machine <公开 类型 = 短整数 注释 = "  可执行文件的目标CPU类型" 注释 = "  IMAGE_FILE_MACHINE_I386   0x014c  x86"
            注释 = "  IMAGE_FILE_MACHINE_IA64   0x0200  Intel Itanium"
            注释 = "  IMAGE_FILE_MACHINE_AMD64  0x8664  x64">
    变量 NumberOfSections <公开 类型 = 短整数 注释 = "节区的数目,如果我们要在文件中增加或删除一个节区,就需要修改这个值.">
    变量 TimeDateStamp <公开 类型 = 整数 注释 = "文件创建的时间戳">
    变量 PointerToSymbolTable <公开 类型 = 整数 注释 = "COFF符号表格的文件偏移位置"
            注释 = "仅用于带有COFF类型调试信息的COFF类型的object files和PE files.">
    变量 NumberOfSymbols <公开 类型 = 整数 注释 = "如果有COFF符号表格,它代表其中的符号数目"
            注释 = "COFF符号是一个大小固定的结构,如果想找到COFF符号表的结束位置,则需要这个变量">
    变量 SizeOfOptionalHeader <公开 类型 = 短整数 注释 = "IMAGE_OPTIONAL_HEADER结构体的大小,32位和64位有差别">
    变量 Characteristics <公开 类型 = 短整数 注释 = "  文件属性标志,比如文件是exe还是dll.标志的值定义在 WINNT.H 中,是为组合值."
            注释 = "  IMAGE_FILE_RELOCS_STRIPPED     0x0001  文件中不存在重定位信息"
            注释 = "  IMAGE_FILE_EXECUTABLE_IMAGE    0x0002  文件可执行"
            注释 = "  IMAGE_FILE_LINE_NUMS_STRIPPED  0x0004  行号信息已从文件中移除"
            注释 = "  IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008  符号信息已从文件中移除"
            注释 = "  IMAGE_FILE_DLL                 0x2000  DLL文件"
            注释 = "  IMAGE_FILE_SYSTEM              0x1000  系统文件"
            注释 = "  IMAGE_FILE_32BIT_MACHINE       0x0100  目标平台为32位平台">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<IMAGE_FILE_HEADER> 总共 7 个成员:\r\n"
        加入文本 (展示内容, "1. Machine: " + 取调试文本2 (最大展示数据尺寸, Machine) + "\r\n")
        加入文本 (展示内容, "2. NumberOfSections: " + 取调试文本2 (最大展示数据尺寸, NumberOfSections) + "\r\n")
        加入文本 (展示内容, "3. TimeDateStamp: " + 取调试文本2 (最大展示数据尺寸, TimeDateStamp) + "\r\n")
        加入文本 (展示内容, "4. PointerToSymbolTable: " + 取调试文本2 (最大展示数据尺寸, PointerToSymbolTable) + "\r\n")
        加入文本 (展示内容, "5. NumberOfSymbols: " + 取调试文本2 (最大展示数据尺寸, NumberOfSymbols) + "\r\n")
        加入文本 (展示内容, "6. SizeOfOptionalHeader: " + 取调试文本2 (最大展示数据尺寸, SizeOfOptionalHeader) + "\r\n")
        加入文本 (展示内容, "7. Characteristics: " + 取调试文本2 (最大展示数据尺寸, Characteristics) + "\r\n")
    }
}

类 IMAGE_OPTIONAL_HEADER32 <公开 注释 = "32位PE文件可选头"
        注释 = "https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32" 折叠
        @文档 = "category = \"PE文件操作.辅助类\"" @视窗.结构类 = 0>
{
    变量 Magic <公开 类型 = 短整数 注释 = "  映像文件类型" 注释 = "  IMAGE_NT_OPTIONAL_HDR32_MAGIC  0x10b  32位程序"
            注释 = "  IMAGE_NT_OPTIONAL_HDR64_MAGIC  0x20b  64位程序"
            注释 = "  IMAGE_ROM_OPTIONAL_HDR_MAGIC   0x107  ROM文件">
    变量 MajorLinkerVersion <公开 类型 = 字节 注释 = "链接器的主版本号">
    变量 MinorLinkerVersion <公开 类型 = 字节 注释 = "链接器的副版本号">
    变量 SizeOfCode <公开 类型 = 整数 注释 = "可执行代码的大小,这些值(包括下面2个也是不可靠的,你可以通过查看可选头后面的各个\"节\"来获得更准确的大小.">
    变量 SizeOfInitializedData <公开 类型 = 整数 注释 = "已初始化数据的大小">
    变量 SizeOfUninitializedData <公开 类型 = 整数 注释 = "未初始化数据的大小,所谓的\"bss段\"">
    变量 AddressOfEntryPoint <公开 类型 = 整数 注释 = "代码入口点的偏移量,RVA">
    变量 BaseOfCode <公开 类型 = 整数 注释 = "代码基址,可执行代码的偏移量,RVA">
    变量 BaseOfData <公开 类型 = 整数 注释 = "数据基址,已初始化数据的偏移量,RVA">
    变量 ImageBase <公开 类型 = 整数 注释 = "PE文件的优先装载地址,提供整个二进制文件包括所有头的优先(线性)载入地址,RVA">
    变量 SectionAlignment <公开 类型 = 整数 注释 = "内存中节对齐的粒度">
    变量 FileAlignment <公开 类型 = 整数 注释 = "文件中节对齐的粒度">
    变量 MajorOperatingSystemVersion <公开 类型 = 短整数 注释 = "主操作系统最低主版本号">
    变量 MinorOperatingSystemVersion <公开 类型 = 短整数 注释 = "主操作系统最低副版本号">
    变量 MajorImageVersion <公开 类型 = 短整数 注释 = "主映像文件版本">
    变量 MinorImageVersion <公开 类型 = 短整数 注释 = "副映像文件版本">
    变量 MajorSubsystemVersion <公开 类型 = 短整数 注释 = "子系统主版本号">
    变量 MinorSubsystemVersion <公开 类型 = 短整数 注释 = "子系统副版本号">
    变量 Win32VersionValue <公开 类型 = 整数 注释 = "Win32版本值,可能为0">
    变量 SizeOfImage <公开 类型 = 整数 注释 = "内存中整个PE映像体的尺寸.它是所有头和节经过节对齐处理后的大小.">
    变量 SizeOfHeaders <公开 类型 = 整数 注释 = "所有头+节表的大小,也就等于文件尺寸减去文件中所有节的尺寸.可以以此值作为PE文件第一节的文件偏移量.">
    变量 CheckSum <公开 类型 = 整数 注释 = "校验和">
    变量 Subsystem <公开 类型 = 短整数 注释 = "  子系统,NT用来识别PE文件属于哪个子系统."
            注释 = "  IMAGE_SUBSYSTEM_WINDOWS_GUI  2  Windows graphical user interface (GUI) subsystem."
            注释 = "  IMAGE_SUBSYSTEM_WINDOWS_CUI  3  Windows character-mode user interface (CUI) subsystem.">
    变量 DllCharacteristics <公开 类型 = 短整数 注释 = "  DLL特性,指明,如果是DLL文件,何时调用DLL文件的入口点,一般不用"
            注释 = "  IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA       0x0020  Image can handle a high entropy 64-bit virtual address space."
            注释 = "  IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE          0x0040  DLL can move."
            注释 = "  IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY       0x0080  Code Integrity Image"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NX_COMPAT             0x0100  Image is NX compatible"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_ISOLATION          0x0200  Image understands isolation and doesn\'t want it"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_SEH                0x0400  Image does not use SEH.  No SE handler may reside in this image"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_BIND               0x0800  Do not bind this image."
            注释 = "  IMAGE_DLLCHARACTERISTICS_APPCONTAINER          0x1000  Image should execute in an AppContainer"
            注释 = "  IMAGE_DLLCHARACTERISTICS_WDM_DRIVER            0x2000  Driver uses WDM model"
            注释 = "  IMAGE_DLLCHARACTERISTICS_GUARD_CF              0x4000  Image supports Control Flow Guard."
            注释 = "  IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE 0x8000">
    变量 SizeOfStackReserve <公开 类型 = 整数 注释 = "保留栈的大小">
    变量 SizeOfStackCommit <公开 类型 = 整数 注释 = "初始时指定栈大小">
    变量 SizeOfHeapReserve <公开 类型 = 整数 注释 = "保留堆的大小">
    变量 SizeOfHeapCommit <公开 类型 = 整数 注释 = "指定堆大小">
    变量 LoaderFlags <公开 类型 = 整数 注释 = "加载器标志(已废弃)">
    变量 NumberOfRvaAndSizes <公开 类型 = 整数 注释 = "Rva数和大小">
    变量 DataDirectory <公开 类型 = "IMAGE_DATA_DIRECTORY [16]" 注释 = "  映像文件数据目录,索引可选:"
            注释 = "  IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table"
            注释 = "  IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory"
            注释 = " /IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)"
            注释 = "  IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data"
            注释 = "  IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP"
            注释 = "  IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers"
            注释 = "  IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table"
            注释 = "  IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors"
            注释 = "  IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<IMAGE_OPTIONAL_HEADER32> 总共 31 个成员:\r\n"
        加入文本 (展示内容, "1. Magic: " + 取调试文本2 (最大展示数据尺寸, Magic) + "\r\n")
        加入文本 (展示内容, "2. MajorLinkerVersion: " + 取调试文本2 (最大展示数据尺寸, MajorLinkerVersion) + "\r\n")
        加入文本 (展示内容, "3. MinorLinkerVersion: " + 取调试文本2 (最大展示数据尺寸, MinorLinkerVersion) + "\r\n")
        加入文本 (展示内容, "4. SizeOfCode: " + 取调试文本2 (最大展示数据尺寸, SizeOfCode) + "\r\n")
        加入文本 (展示内容, "5. SizeOfInitializedData: " + 取调试文本2 (最大展示数据尺寸, SizeOfInitializedData) + "\r\n")
        加入文本 (展示内容, "6. SizeOfUninitializedData: " + 取调试文本2 (最大展示数据尺寸, SizeOfUninitializedData) + "\r\n")
        加入文本 (展示内容, "7. AddressOfEntryPoint: " + 取调试文本2 (最大展示数据尺寸, AddressOfEntryPoint) + "\r\n")
        加入文本 (展示内容, "8. BaseOfCode: " + 取调试文本2 (最大展示数据尺寸, BaseOfCode) + "\r\n")
        加入文本 (展示内容, "9. BaseOfData: " + 取调试文本2 (最大展示数据尺寸, BaseOfData) + "\r\n")
        加入文本 (展示内容, "10. ImageBase: " + 取调试文本2 (最大展示数据尺寸, ImageBase) + "\r\n")
        加入文本 (展示内容, "11. SectionAlignment: " + 取调试文本2 (最大展示数据尺寸, SectionAlignment) + "\r\n")
        加入文本 (展示内容, "12. FileAlignment: " + 取调试文本2 (最大展示数据尺寸, FileAlignment) + "\r\n")
        加入文本 (展示内容, "13. MajorOperatingSystemVersion: " + 取调试文本2 (最大展示数据尺寸, MajorOperatingSystemVersion) + "\r\n")
        加入文本 (展示内容, "14. MinorOperatingSystemVersion: " + 取调试文本2 (最大展示数据尺寸, MinorOperatingSystemVersion) + "\r\n")
        加入文本 (展示内容, "15. MajorImageVersion: " + 取调试文本2 (最大展示数据尺寸, MajorImageVersion) + "\r\n")
        加入文本 (展示内容, "16. MinorImageVersion: " + 取调试文本2 (最大展示数据尺寸, MinorImageVersion) + "\r\n")
        加入文本 (展示内容, "17. MajorSubsystemVersion: " + 取调试文本2 (最大展示数据尺寸, MajorSubsystemVersion) + "\r\n")
        加入文本 (展示内容, "18. MinorSubsystemVersion: " + 取调试文本2 (最大展示数据尺寸, MinorSubsystemVersion) + "\r\n")
        加入文本 (展示内容, "19. Win32VersionValue: " + 取调试文本2 (最大展示数据尺寸, Win32VersionValue) + "\r\n")
        加入文本 (展示内容, "20. SizeOfImage: " + 取调试文本2 (最大展示数据尺寸, SizeOfImage) + "\r\n")
        加入文本 (展示内容, "21. SizeOfHeaders: " + 取调试文本2 (最大展示数据尺寸, SizeOfHeaders) + "\r\n")
        加入文本 (展示内容, "22. CheckSum: " + 取调试文本2 (最大展示数据尺寸, CheckSum) + "\r\n")
        加入文本 (展示内容, "23. Subsystem: " + 取调试文本2 (最大展示数据尺寸, Subsystem) + "\r\n")
        加入文本 (展示内容, "24. DllCharacteristics: " + 取调试文本2 (最大展示数据尺寸, DllCharacteristics) + "\r\n")
        加入文本 (展示内容, "25. SizeOfStackReserve: " + 取调试文本2 (最大展示数据尺寸, SizeOfStackReserve) + "\r\n")
        加入文本 (展示内容, "26. SizeOfStackCommit: " + 取调试文本2 (最大展示数据尺寸, SizeOfStackCommit) + "\r\n")
        加入文本 (展示内容, "27. SizeOfHeapReserve: " + 取调试文本2 (最大展示数据尺寸, SizeOfHeapReserve) + "\r\n")
        加入文本 (展示内容, "28. SizeOfHeapCommit: " + 取调试文本2 (最大展示数据尺寸, SizeOfHeapCommit) + "\r\n")
        加入文本 (展示内容, "29. LoaderFlags: " + 取调试文本2 (最大展示数据尺寸, LoaderFlags) + "\r\n")
        加入文本 (展示内容, "30. NumberOfRvaAndSizes: " + 取调试文本2 (最大展示数据尺寸, NumberOfRvaAndSizes) + "\r\n")
        加入文本 (展示内容, "31. DataDirectory: IMAGE_DATA_DIRECTORY [16]\r\n")
    }
}

类 IMAGE_OPTIONAL_HEADER64 <公开 注释 = "64位PE文件可选头"
        注释 = "https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header64" 折叠
        @文档 = "category = \"PE文件操作.辅助类\"" @视窗.结构类 = 0>
{
    变量 Magic <公开 类型 = 短整数 注释 = "  映像文件类型" 注释 = "  IMAGE_NT_OPTIONAL_HDR32_MAGIC  0x10b  32位程序"
            注释 = "  IMAGE_NT_OPTIONAL_HDR64_MAGIC  0x20b  64位程序"
            注释 = "  IMAGE_ROM_OPTIONAL_HDR_MAGIC   0x107  ROM文件">
    变量 MajorLinkerVersion <公开 类型 = 字节 注释 = "链接器的主版本号">
    变量 MinorLinkerVersion <公开 类型 = 字节 注释 = "链接器的副版本号">
    变量 SizeOfCode <公开 类型 = 整数 注释 = "可执行代码的大小,这些值(包括下面2个也是不可靠的,你可以通过查看可选头后面的各个\"节\"来获得更准确的大小.">
    变量 SizeOfInitializedData <公开 类型 = 整数 注释 = "已初始化数据的大小">
    变量 SizeOfUninitializedData <公开 类型 = 整数 注释 = "未初始化数据的大小,所谓的\"bss段\"">
    变量 AddressOfEntryPoint <公开 类型 = 整数 注释 = "代码入口点的偏移量,RVA">
    变量 BaseOfCode <公开 类型 = 整数 注释 = "代码基址,可执行代码的偏移值,RVA">
    变量 ImageBase <公开 类型 = 长整数 注释 = "PE文件的优先装载地址,提供整个二进制文件包括所有头的优先(线性)载入地址,RVA">
    变量 SectionAlignment <公开 类型 = 整数 注释 = "内存中节对齐的粒度">
    变量 FileAlignment <公开 类型 = 整数 注释 = "文件中节对齐的粒度">
    变量 MajorOperatingSystemVersion <公开 类型 = 短整数 注释 = "主操作系统最低主版本号">
    变量 MinorOperatingSystemVersion <公开 类型 = 短整数 注释 = "主操作系统最低副版本号">
    变量 MajorImageVersion <公开 类型 = 短整数 注释 = "主映像文件版本">
    变量 MinorImageVersion <公开 类型 = 短整数 注释 = "副映像文件版本">
    变量 MajorSubsystemVersion <公开 类型 = 短整数 注释 = "主子系统版本">
    变量 MinorSubsystemVersion <公开 类型 = 短整数 注释 = "副子系统版本">
    变量 Win32VersionValue <公开 类型 = 整数 注释 = "Win32版本值,可能为0">
    变量 SizeOfImage <公开 类型 = 整数 注释 = "内存中整个PE映像体的尺寸.它是所有头和节经过节对齐处理后的大小.">
    变量 SizeOfHeaders <公开 类型 = 整数 注释 = "所有头+节表的大小,也就等于文件尺寸减去文件中所有节的尺寸.可以以此值作为PE文件第一节的文件偏移量.">
    变量 CheckSum <公开 类型 = 整数 注释 = "校验和">
    变量 Subsystem <公开 类型 = 短整数 注释 = "  子系统,NT用来识别PE文件属于哪个子系统."
            注释 = "  IMAGE_SUBSYSTEM_WINDOWS_GUI  2  Windows graphical user interface (GUI) subsystem."
            注释 = "  IMAGE_SUBSYSTEM_WINDOWS_CUI  3  Windows character-mode user interface (CUI) subsystem.">
    变量 DllCharacteristics <公开 类型 = 短整数 注释 = "  DLL特性,指明,如果是DLL文件,何时调用DLL文件的入口点,一般不用"
            注释 = "  IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA       0x0020  Image can handle a high entropy 64-bit virtual address space."
            注释 = "  IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE          0x0040  DLL can move."
            注释 = "  IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY       0x0080  Code Integrity Image"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NX_COMPAT             0x0100  Image is NX compatible"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_ISOLATION          0x0200  Image understands isolation and doesn\'t want it"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_SEH                0x0400  Image does not use SEH.No SE handler may reside in this image"
            注释 = "  IMAGE_DLLCHARACTERISTICS_NO_BIND               0x0800  Do not bind this image."
            注释 = "  IMAGE_DLLCHARACTERISTICS_APPCONTAINER          0x1000  Image should execute in an AppContainer"
            注释 = "  IMAGE_DLLCHARACTERISTICS_WDM_DRIVER            0x2000  Driver uses WDM model"
            注释 = "  IMAGE_DLLCHARACTERISTICS_GUARD_CF              0x4000  Image supports Control Flow Guard."
            注释 = "  IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE 0x8000">
    变量 SizeOfStackReserve <公开 类型 = 长整数 注释 = "保留栈的大小">
    变量 SizeOfStackCommit <公开 类型 = 长整数 注释 = "初始时指定栈大小">
    变量 SizeOfHeapReserve <公开 类型 = 长整数 注释 = "保留堆的大小">
    变量 SizeOfHeapCommit <公开 类型 = 长整数 注释 = "指定堆大小">
    变量 LoaderFlags <公开 类型 = 整数 注释 = "加载器标志">
    变量 NumberOfRvaAndSizes <公开 类型 = 整数 注释 = "Rva数和大小">
    变量 DataDirectory <公开 类型 = "IMAGE_DATA_DIRECTORY [16]"
            注释 = "  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];"
            注释 = "  映像文件数据目录,索引可选:" 注释 = "  IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table"
            注释 = "  IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory"
            注释 = " /IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)"
            注释 = "  IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data"
            注释 = "  IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP"
            注释 = "  IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory"
            注释 = "  IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers"
            注释 = "  IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table"
            注释 = "  IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors"
            注释 = "  IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<IMAGE_OPTIONAL_HEADER64> 总共 30 个成员:\r\n"
        加入文本 (展示内容, "1. Magic: " + 取调试文本2 (最大展示数据尺寸, Magic) + "\r\n")
        加入文本 (展示内容, "2. MajorLinkerVersion: " + 取调试文本2 (最大展示数据尺寸, MajorLinkerVersion) + "\r\n")
        加入文本 (展示内容, "3. MinorLinkerVersion: " + 取调试文本2 (最大展示数据尺寸, MinorLinkerVersion) + "\r\n")
        加入文本 (展示内容, "4. SizeOfCode: " + 取调试文本2 (最大展示数据尺寸, SizeOfCode) + "\r\n")
        加入文本 (展示内容, "5. SizeOfInitializedData: " + 取调试文本2 (最大展示数据尺寸, SizeOfInitializedData) + "\r\n")
        加入文本 (展示内容, "6. SizeOfUninitializedData: " + 取调试文本2 (最大展示数据尺寸, SizeOfUninitializedData) + "\r\n")
        加入文本 (展示内容, "7. AddressOfEntryPoint: " + 取调试文本2 (最大展示数据尺寸, AddressOfEntryPoint) + "\r\n")
        加入文本 (展示内容, "8. BaseOfCode: " + 取调试文本2 (最大展示数据尺寸, BaseOfCode) + "\r\n")
        加入文本 (展示内容, "9. ImageBase: " + 取调试文本2 (最大展示数据尺寸, ImageBase) + "\r\n")
        加入文本 (展示内容, "10. SectionAlignment: " + 取调试文本2 (最大展示数据尺寸, SectionAlignment) + "\r\n")
        加入文本 (展示内容, "11. FileAlignment: " + 取调试文本2 (最大展示数据尺寸, FileAlignment) + "\r\n")
        加入文本 (展示内容, "12. MajorOperatingSystemVersion: " + 取调试文本2 (最大展示数据尺寸, MajorOperatingSystemVersion) + "\r\n")
        加入文本 (展示内容, "13. MinorOperatingSystemVersion: " + 取调试文本2 (最大展示数据尺寸, MinorOperatingSystemVersion) + "\r\n")
        加入文本 (展示内容, "14. MajorImageVersion: " + 取调试文本2 (最大展示数据尺寸, MajorImageVersion) + "\r\n")
        加入文本 (展示内容, "15. MinorImageVersion: " + 取调试文本2 (最大展示数据尺寸, MinorImageVersion) + "\r\n")
        加入文本 (展示内容, "16. MajorSubsystemVersion: " + 取调试文本2 (最大展示数据尺寸, MajorSubsystemVersion) + "\r\n")
        加入文本 (展示内容, "17. MinorSubsystemVersion: " + 取调试文本2 (最大展示数据尺寸, MinorSubsystemVersion) + "\r\n")
        加入文本 (展示内容, "18. Win32VersionValue: " + 取调试文本2 (最大展示数据尺寸, Win32VersionValue) + "\r\n")
        加入文本 (展示内容, "19. SizeOfImage: " + 取调试文本2 (最大展示数据尺寸, SizeOfImage) + "\r\n")
        加入文本 (展示内容, "20. SizeOfHeaders: " + 取调试文本2 (最大展示数据尺寸, SizeOfHeaders) + "\r\n")
        加入文本 (展示内容, "21. CheckSum: " + 取调试文本2 (最大展示数据尺寸, CheckSum) + "\r\n")
        加入文本 (展示内容, "22. Subsystem: " + 取调试文本2 (最大展示数据尺寸, Subsystem) + "\r\n")
        加入文本 (展示内容, "23. DllCharacteristics: " + 取调试文本2 (最大展示数据尺寸, DllCharacteristics) + "\r\n")
        加入文本 (展示内容, "24. SizeOfStackReserve: " + 取调试文本2 (最大展示数据尺寸, SizeOfStackReserve) + "\r\n")
        加入文本 (展示内容, "25. SizeOfStackCommit: " + 取调试文本2 (最大展示数据尺寸, SizeOfStackCommit) + "\r\n")
        加入文本 (展示内容, "26. SizeOfHeapReserve: " + 取调试文本2 (最大展示数据尺寸, SizeOfHeapReserve) + "\r\n")
        加入文本 (展示内容, "27. SizeOfHeapCommit: " + 取调试文本2 (最大展示数据尺寸, SizeOfHeapCommit) + "\r\n")
        加入文本 (展示内容, "28. LoaderFlags: " + 取调试文本2 (最大展示数据尺寸, LoaderFlags) + "\r\n")
        加入文本 (展示内容, "29. NumberOfRvaAndSizes: " + 取调试文本2 (最大展示数据尺寸, NumberOfRvaAndSizes) + "\r\n")
        加入文本 (展示内容, "30. DataDirectory: IMAGE_DATA_DIRECTORY [16]\r\n")
    }
}

类 IMAGE_DATA_DIRECTORY <公开 注释 = "PE文件数据目录"
        注释 = "https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_data_directory" 折叠
        @文档 = "category = \"PE文件操作.辅助类\"" @视窗.结构类 = 0>
{
    变量 VirtualAddress <公开 类型 = 整数 注释 = "指向的数据结构的虚拟地址(RAV)">
    变量 Size <公开 类型 = 整数 注释 = "数据结构的大小">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<IMAGE_DATA_DIRECTORY> 总共 2 个成员:\r\n"
        加入文本 (展示内容, "1. VirtualAddress: " + 取调试文本2 (最大展示数据尺寸, VirtualAddress) + "\r\n")
        加入文本 (展示内容, "2. Size: " + 取调试文本2 (最大展示数据尺寸, Size) + "\r\n")
    }
}

类 IMAGE_SECTION_HEADER <公开 注释 = "PE文件的节区表"
        注释 = "https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_section_header" 折叠
        @文档 = "category = \"PE文件操作.辅助类\"" @视窗.结构类 = 0>
{
    变量 Name <公开 类型 = "字节 [8]" 注释 = "节名称">
    变量 VirtualSize <公开 类型 = 整数 注释 = "也可是PhysicalAddress,在可执行文件中,它是内容的大小.在目标文件中,它是内容重定位到的地址.">
    变量 VirtualAddress <公开 类型 = 整数 注释 = "节的RVA(相对虚拟地址)节中数据的RVA.">
    变量 SizeOfRawData <公开 类型 = 整数 注释 = "原始数据大小,经过文件对齐处理后节尺寸,PE装载器提取本值了解需映射入内存的节字节数.">
    变量 PointerToRawData <公开 类型 = 整数 注释 = "文件偏移,这是节基于文件的偏移量,PE装载器通过本值找到节数据在文件中的位置.">
    变量 PointerToRelocations <公开 类型 = 整数 注释 = "重定位指针">
    变量 PointerToLinenumbers <公开 类型 = 整数 注释 = "行数指针">
    变量 NumberOfRelocations <公开 类型 = 短整数 注释 = "重定位数">
    变量 NumberOfLinenumbers <公开 类型 = 短整数 注释 = "行数数">
    变量 Characteristics <公开 类型 = 整数 注释 = "特性,包含标记以指示节属性,比如节是否含有可执行代码、初始化数据、未初始数据、是否可写、可读等.">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<IMAGE_SECTION_HEADER> 总共 10 个成员:\r\n"
        加入文本 (展示内容, "1. Name: " + 多字节到文本 (数组到字节集 (Name)) + "\r\n")
        加入文本 (展示内容, "2. VirtualSize: " + 取调试文本2 (最大展示数据尺寸, VirtualSize) + "\r\n")
        加入文本 (展示内容, "3. VirtualAddress: " + 取调试文本2 (最大展示数据尺寸, VirtualAddress) + "\r\n")
        加入文本 (展示内容, "4. SizeOfRawData: " + 取调试文本2 (最大展示数据尺寸, SizeOfRawData) + "\r\n")
        加入文本 (展示内容, "5. PointerToRawData: " + 取调试文本2 (最大展示数据尺寸, PointerToRawData) + "\r\n")
        加入文本 (展示内容, "6. PointerToRelocations: " + 取调试文本2 (最大展示数据尺寸, PointerToRelocations) + "\r\n")
        加入文本 (展示内容, "7. PointerToLinenumbers: " + 取调试文本2 (最大展示数据尺寸, PointerToLinenumbers) + "\r\n")
        加入文本 (展示内容, "8. NumberOfRelocations: " + 取调试文本2 (最大展示数据尺寸, NumberOfRelocations) + "\r\n")
        加入文本 (展示内容, "9. NumberOfLinenumbers: " + 取调试文本2 (最大展示数据尺寸, NumberOfLinenumbers) + "\r\n")
        加入文本 (展示内容, "10. Characteristics: " + 取调试文本2 (最大展示数据尺寸, Characteristics) + "\r\n")
    }
}

类 节区表数组类 <公开 基础类 = 对象数组模板类 注释 = "节区表数组" @文档 = "category = \"PE文件操作.辅助类\""
        @模板实现类 = "IMAGE_SECTION_HEADER">

类 IMAGE_IMPORT_DESCRIPTOR <公开 注释 = "PE文件的导入表描述符结构体" 折叠 @文档 = "category = \"PE文件操作.辅助类\"" @视窗.结构类 = 0>
{
    变量 OriginalFirstThunk <公开 类型 = 整数 注释 = "联合体{" 注释 = "  Characteristics     0为空导入表描述符的结束符"
            注释 = "  OriginalFirstThunk  原始未绑定IAT(PIMAGE_THUNK_DATA)的相对虚拟地址" 注释 = "}"
            注释 = "由于存在单桥结构的DLL,最好别用该成员进程分析">
    变量 TimeDateStamp <公开 类型 = 整数 注释 = "文件创建时间戳" 注释 = "  0    未绑定导入表"
            注释 = "  -1   如果已绑定,真实的时间戳在IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT表中"
            注释 = "  其他 导入表已绑定,该时间戳与IMAGE_FILE_HEADER.TimeDateStamp一致">
    变量 ForwarderChain <公开 类型 = 短整数 注释 = "链表的前一结构">
    变量 Name <公开 类型 = 整数 注释 = "模块的名称地址(ASCII字符串的RVA)">
    变量 FirstThunk <公开 类型 = 整数 注释 = "  导入表的IAT结构的相对虚拟地址" 注释 = "  绑定导入表后,该地址数组指向真实的函数地址(VA)">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<IMAGE_IMPORT_DESCRIPTOR> 总共 4 个成员:\r\n"
        加入文本 (展示内容, "1. OriginalFirstThunk: " + 取调试文本2 (最大展示数据尺寸, OriginalFirstThunk) + "\r\n")
        加入文本 (展示内容, "2. TimeDateStamp: " + 取调试文本2 (最大展示数据尺寸, TimeDateStamp) + "\r\n")
        加入文本 (展示内容, "3. ForwarderChain: " + 取调试文本2 (最大展示数据尺寸, ForwarderChain) + "\r\n")
        加入文本 (展示内容, "4. FirstThunk: " + 取调试文本2 (最大展示数据尺寸, FirstThunk) + "\r\n")
    }
}

类 导入表描述符数组类 <公开 基础类 = 对象数组模板类 @文档 = "category = \"PE文件操作.辅助类\"" @模板实现类 = "IMAGE_IMPORT_DESCRIPTOR">

类 IMAGE_EXPORT_DIRECTORY <公开 注释 = "PE文件的导出表结构体" 折叠 @文档 = "category = \"PE文件操作.辅助类\"" @视窗.结构类 = 0>
{
    变量 Characteristics <公开 类型 = 整数 注释 = "未使用,总为0">
    变量 TimeDateStamp <公开 类型 = 整数 注释 = "文件创建时间戳">
    变量 MajorVersion <公开 类型 = 短整数 注释 = "未使用,总为0">
    变量 MinorVersion <公开 类型 = 短整数 注释 = "未使用,总为0">
    变量 Name <公开 类型 = 整数 注释 = "模块的内部名称地址(UTF8编码字符串的RVA)" 注释 = "即使DLL文件的名称被修改,仍可以从这个字符串得知编译时的名称">
    变量 Base <公开 类型 = 整数 注释 = "函数的起始序号." 注释 = "比如一个函数的序号是4,Base是2,就表示该函数位于导出地址列表第三个成员."
            注释 = "导出地址列表中的首成员(索引0)对应序号1,而不是序号0." 注释 = "序号的起始数字可以在.DEF文件中定义.">
    变量 NumberOfFunctions <公开 类型 = 整数 注释 = "导出函数的个数">
    变量 NumberOfNames <公开 类型 = 整数 注释 = "以名称导出的函数的个数">
    变量 AddressOfFunctions <公开 类型 = 整数 注释 = "导出地址列表(Export Address Table, EAT 其实就是一个地址数组)的首地址(RVA)">
    变量 AddressOfNames <公开 类型 = 整数 注释 = "导出名称列表(Export Name Table, ENT)的首地址(RVA)">
    变量 AddressOfNameOrdinals <公开 类型 = 整数 注释 = "导出序号列表(Export Ordinal Table, EOT)的首地址(RVA)"
            注释 = "该数组的元素都是16-bit(一个字)长度的整数.">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<IMAGE_EXPORT_DIRECTORY> 总共 11 个成员:\r\n"
        加入文本 (展示内容, "1. Characteristics: " + 取调试文本2 (最大展示数据尺寸, Characteristics) + "\r\n")
        加入文本 (展示内容, "2. TimeDateStamp: " + 取调试文本2 (最大展示数据尺寸, TimeDateStamp) + "\r\n")
        加入文本 (展示内容, "3. MajorVersion: " + 取调试文本2 (最大展示数据尺寸, MajorVersion) + "\r\n")
        加入文本 (展示内容, "4. MinorVersion: " + 取调试文本2 (最大展示数据尺寸, MinorVersion) + "\r\n")
        加入文本 (展示内容, "5. Name: " + 取调试文本2 (最大展示数据尺寸, Name) + "\r\n")
        加入文本 (展示内容, "6. Base: " + 取调试文本2 (最大展示数据尺寸, Base) + "\r\n")
        加入文本 (展示内容, "7. NumberOfFunctions: " + 取调试文本2 (最大展示数据尺寸, NumberOfFunctions) + "\r\n")
        加入文本 (展示内容, "8. NumberOfNames: " + 取调试文本2 (最大展示数据尺寸, NumberOfNames) + "\r\n")
        加入文本 (展示内容, "9. AddressOfFunctions: " + 取调试文本2 (最大展示数据尺寸, AddressOfFunctions) + "\r\n")
        加入文本 (展示内容, "10. AddressOfNames: " + 取调试文本2 (最大展示数据尺寸, AddressOfNames) + "\r\n")
        加入文本 (展示内容, "11. AddressOfNameOrdinals: " + 取调试文本2 (最大展示数据尺寸, AddressOfNameOrdinals) + "\r\n")
    }
}

类 PE函数类 <公开 注释 = "PE文件导出表中的函数信息" 折叠 @文档 = "category = \"PE文件操作.辅助类\"">
{
    变量 函数名称 <公开 类型 = 文本型 @输出名 = "FunctionName">
    变量 函数地址 <公开 类型 = 长整数 @输出名 = "FunctionAddress">
    变量 函数序号 <公开 类型 = 整数 @输出名 = "FunctionOrdinal">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<PE函数类> 总共 3 个成员:\r\n"
        加入文本 (展示内容, "1. 函数名称: " + 取调试文本2 (最大展示数据尺寸, 函数名称) + "\r\n")
        加入文本 (展示内容, "2. 函数地址: " + 取调试文本2 (最大展示数据尺寸, 函数地址) + "\r\n")
        加入文本 (展示内容, "3. 函数序号: " + 取调试文本2 (最大展示数据尺寸, 函数序号) + "\r\n")
    }
}

类 PE函数数组类 <公开 基础类 = 对象数组模板类 注释 = "PE文件导出表中的函数信息数组" @文档 = "category = \"PE文件操作.辅助类\"" @模板实现类 = "PE函数类">

类 导出表类 <公开 注释 = "导出表" 折叠 @文档 = "category = \"PE文件操作.辅助类\"">
{
    变量 模块名称 <公开 类型 = 文本型 @输出名 = "ModuleName">
    变量 函数列表 <公开 类型 = PE函数数组类 @输出名 = "aFunctions">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖 @输出名 = "GetDumpString"
            @视窗.后缀文本 = "override">
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<PE函数表类> 总共 2 个成员:\r\n"
        加入文本 (展示内容, "1. 模块名称: " + 取调试文本2 (最大展示数据尺寸, 模块名称) + "\r\n")
        加入文本 (展示内容, "2. 函数列表: " + 取调试文本2 (最大展示数据尺寸, 函数列表) + "\r\n")
    }
}

类 导入表数组类 <公开 基础类 = 对象数组模板类 注释 = "导入表数组" @文档 = "category = \"PE文件操作.辅助类\"" @模板实现类 = "导出表类">

# ======

类 程序信息类 <公开 注释 = "用于获取程序文件的版本信息" 折叠2 @文档 = "category = \"PE文件操作\"" @全局类 = 真 @禁止创建对象 = 真
        @视窗.外部库 = "Version.lib">
{
    方法 取程序版本 <公开 静态 类型 = 逻辑型 注释 = "获取程序文件的完整版本信息,取自版本信息资源的StringFileInfo结构."
            注释 = "注意: 由于火山程序的版本信息比较别扭,本方法只能获取火山程序的\"版本名称\"属性," 注释 = "如果要获取\"版本号\",请使用\"取文件版本\"或\"取产品版本\"."
            返回值注释 = "返回是否成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "包含完整路径的文件名">
    参数 版本信息 <类型 = 程序版本信息类>
    {
        @ @<版本信息>.ResetToNullObject ();
        @ DWORD bufSize = ::GetFileVersionInfoSizeW (@<文件名>.GetText (), 0);
        @ if (!bufSize) return FALSE;
        @ @an<CVolMem> buffer;
        @ buffer.Alloc (bufSize, TRUE);
        @ if (::GetFileVersionInfoW (@<文件名>.GetText (), 0, bufSize, buffer.GetPtr ()) == 0)
        @     return FALSE;
        @ struct LANGANDCODEPAGE {
        @     WORD wLanguage;
        @     WORD wCodePage;
        @ } *lpTranslate;
        @ UINT cbTranslate, data_len;
        @ if (::VerQueryValueW (buffer.GetPtr (), L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
        @ {
        @     for (UINT i = 0; i < (cbTranslate / sizeof (struct LANGANDCODEPAGE)); i++)
        @     {
        @         WCHAR SubBlock[MAX_PATH] { '\0' };
        @         const WCHAR* szText = nullptr;
        @         if (::VerLanguageNameW (lpTranslate[i].wLanguage, SubBlock, MAX_PATH)) @<版本信息.语言>.SetText (SubBlock);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\Comments", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.注释>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\CompanyName", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.公司名称>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\FileDescription", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.文件说明>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\FileVersion", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.文件版本>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\InternalName", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.内部名称>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\LegalCopyright", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.版权>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\LegalTrademarks", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.法律商标>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\OriginalFilename", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.原始文件名>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\ProductName", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.产品名称>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\ProductVersion", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.产品版本>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\PrivateBuild", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.私有版本>.SetText (szText);
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\SpecialBuild", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len)) @<版本信息.特殊版本>.SetText (szText);
        @         break; // 跳出循环,只取第一个语言
        @     }
        @     return TRUE;
        @ }
        @ return FALSE;
    }

    方法 取程序文件版本 <公开 静态 类型 = 文本型 注释 = "返回程序文件的文件版本字符串,取自版本信息资源的StringFileInfo结构."
            返回值注释 = "成功返回文件版本(等同火山程序的\"版本名称\"属性)" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "包含完整路径的文件名">
    {
        @ DWORD bufSize = ::GetFileVersionInfoSizeW (@<文件名>.GetText (), 0);
        @ @an<CVolString> szFileVersion;
        @ if (!bufSize) return szFileVersion;
        @ @an<CVolMem> buffer;
        @ buffer.Alloc (bufSize, TRUE);
        @ if (::GetFileVersionInfoW (@<文件名>.GetText(), 0, bufSize, buffer.GetPtr ()) == 0)
        @     return szFileVersion;
        @ struct LANGANDCODEPAGE {
        @     WORD wLanguage;
        @     WORD wCodePage;
        @ } *lpTranslate;
        @ UINT cbTranslate, data_len;
        @ if (::VerQueryValueW (buffer.GetPtr (), L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
        @ {
        @     for (UINT i = 0; i < (cbTranslate / sizeof (struct LANGANDCODEPAGE)); i++)
        @     {
        @         WCHAR SubBlock[MAX_PATH] { 0 };
        @         const WCHAR* szText = nullptr;
        @         wsprintf (SubBlock, L"\\StringFileInfo\\%04x%04x\\FileVersion", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
        @         if (::VerQueryValueW (buffer.GetPtr (), SubBlock, (LPVOID*)&szText, &data_len))
        @             szFileVersion.SetText (szText);
        @         break; // 跳出循环,只取第一个语言
        @     }
        @ }
        @ return szFileVersion;
    }

    方法 取文件版本 <公开 静态 类型 = 长整数 注释 = "返回程序文件的文件版本,取自版本信息资源的VS_FIXEDFILEINFO结构."
            注释 = "调用失败返回-1,长整数的版本号更适合比较,但不直观." 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "包含完整路径的文件名">
    参数 返回版本格式文本 <类型 = 文本型 注释 = "在本参数中返回类似\"1.1.0.0\"格式的文本版本号,更适合于展示." @默认值 = 空对象>
    {
        @ DWORD bufSize = ::GetFileVersionInfoSizeW (@<文件名>.GetText (), 0);
        @ if (!bufSize) return -1;
        @ @an<CVolMem> buffer;
        @ buffer.Alloc (bufSize, TRUE);
        @ if (::GetFileVersionInfoW (@<文件名>.GetText(), 0, bufSize, buffer.GetPtr ()) == 0)
        @     return -1;
        @ VS_FIXEDFILEINFO* pFileInfo = nullptr;
        @ UINT cbFileInfo;
        @ if (::VerQueryValueW (buffer.GetPtr (), L"\\", (LPVOID*)&pFileInfo, &cbFileInfo))
        @ {
        @     if (!@<返回版本格式文本>.IsNullObject())
        @         @<返回版本格式文本>.Format (L"%d.%d.%d.%d", HIWORD(pFileInfo->dwFileVersionMS), LOWORD((DWORD)pFileInfo->dwFileVersionMS), HIWORD(pFileInfo->dwFileVersionLS), LOWORD((DWORD)pFileInfo->dwFileVersionLS));
        @     return (INT64)(pFileInfo->dwFileVersionMS | ((UINT64)pFileInfo->dwFileVersionLS << 32));
        @ }
        @ return -1;
    }

    方法 取产品版本 <公开 静态 类型 = 长整数 注释 = "返回程序文件的产品版本,取自版本信息资源的VS_FIXEDFILEINFO结构."
            注释 = "调用失败返回-1,长整数的版本号更适合比较,但不直观." 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "包含完整路径的文件名">
    参数 返回版本格式文本 <类型 = 文本型 注释 = "在本参数中返回类似\"1.1.0.0\"格式的文本版本号,更适合于展示." @默认值 = 空对象>
    {
        @ DWORD bufSize = ::GetFileVersionInfoSizeW (@<文件名>.GetText (), 0);
        @ if (!bufSize) return -1;
        @ @an<CVolMem> buffer;
        @ buffer.Alloc (bufSize, TRUE);
        @ if (::GetFileVersionInfoW (@<文件名>.GetText(), 0, bufSize, buffer.GetPtr ()) == 0)
        @     return -1;
        @ VS_FIXEDFILEINFO* pFileInfo = nullptr;
        @ UINT cbFileInfo;
        @ if (::VerQueryValueW (buffer.GetPtr (), L"\\", (LPVOID*)&pFileInfo, &cbFileInfo))
        @ {
        @     if (!@<返回版本格式文本>.IsNullObject())
        @         @<返回版本格式文本>.Format (L"%d.%d.%d.%d", HIWORD(pFileInfo->dwProductVersionMS), LOWORD((DWORD)pFileInfo->dwProductVersionMS), HIWORD(pFileInfo->dwProductVersionLS), LOWORD((DWORD)pFileInfo->dwProductVersionLS));
        @     return (INT64)(pFileInfo->dwProductVersionMS | ((UINT64)pFileInfo->dwProductVersionLS << 32));
        @ }
        @ return -1;
    }
}

类 程序版本信息类 <公开 基础类 = 扩展对象类 注释 = "程序文件版本信息的辅助类" 折叠 @文档 = "category = \"PE文件操作.辅助类\"">
{
    变量 注释 <公开 类型 = 文本型 注释 = "(可能为空)Comments,与文件关联的注释.">
    变量 公司名称 <公开 类型 = 文本型 注释 = "CompanyName,生成文件的公司的名称.">
    变量 文件说明 <公开 类型 = 文本型 注释 = "FileDescription,文件说明.">
    变量 文件版本 <公开 类型 = 文本型 注释 = "FileVersion,文件的版本号.">
    变量 内部名称 <公开 类型 = 文本型 注释 = "InternalName,文件的内部名称. 如果不存在内部名称,则该属性将包含文件的原始名称(不带扩展名).">
    变量 版权 <公开 类型 = 文本型 注释 = "LegalCopyright,包括所有声明的完整文本、合法符号、版权日期等.">
    变量 法律商标 <公开 类型 = 文本型 注释 = "(可能为空)LegalTrademarks,应用到文件的商标和注册商标.">
    变量 原始文件名 <公开 类型 = 文本型 注释 = "OriginalFilename,创建文件时使用的名称.">
    变量 产品名称 <公开 类型 = 文本型 注释 = "ProductName,与此文件一起发行的产品的名称.">
    变量 产品版本 <公开 类型 = 文本型 注释 = "ProductVersion,与此文件一起发行的产品的版本.">
    变量 私有版本 <公开 类型 = 文本型 注释 = "(可能为空)PrivateBuild,文件私有版本的信息.">
    变量 特殊版本 <公开 类型 = 文本型 注释 = "(可能为空)SpecialBuild,文件的特殊内部版本信息.">
    变量 语言 <公开 类型 = 文本型 注释 = "程序的语言">

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<程序版本信息类> 总共 13 个成员:\r\n"
        加入文本 (展示内容, "1. 注释: " + 取调试文本2 (最大展示数据尺寸, 注释) + "\r\n")
        加入文本 (展示内容, "2. 公司名称: " + 取调试文本2 (最大展示数据尺寸, 公司名称) + "\r\n")
        加入文本 (展示内容, "3. 文件说明: " + 取调试文本2 (最大展示数据尺寸, 文件说明) + "\r\n")
        加入文本 (展示内容, "4. 文件版本: " + 取调试文本2 (最大展示数据尺寸, 文件版本) + "\r\n")
        加入文本 (展示内容, "5. 内部名称: " + 取调试文本2 (最大展示数据尺寸, 内部名称) + "\r\n")
        加入文本 (展示内容, "6. 版权: " + 取调试文本2 (最大展示数据尺寸, 版权) + "\r\n")
        加入文本 (展示内容, "7. 法律商标: " + 取调试文本2 (最大展示数据尺寸, 法律商标) + "\r\n")
        加入文本 (展示内容, "8. 原始文件名: " + 取调试文本2 (最大展示数据尺寸, 原始文件名) + "\r\n")
        加入文本 (展示内容, "9. 产品名称: " + 取调试文本2 (最大展示数据尺寸, 产品名称) + "\r\n")
        加入文本 (展示内容, "10. 产品版本: " + 取调试文本2 (最大展示数据尺寸, 产品版本) + "\r\n")
        加入文本 (展示内容, "11. 私有版本: " + 取调试文本2 (最大展示数据尺寸, 私有版本) + "\r\n")
        加入文本 (展示内容, "12. 特殊版本: " + 取调试文本2 (最大展示数据尺寸, 特殊版本) + "\r\n")
        加入文本 (展示内容, "13. 语言: " + 取调试文本2 (最大展示数据尺寸, 语言) + "\r\n")
    }
}

类 程序版本信息数组类 <公开 基础类 = 对象数组模板类 @文档 = "category = \"PE文件操作.辅助类\"" @模板实现类 = "程序版本信息类">
