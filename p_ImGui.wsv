<火山程序 类型 = "通常" 版本 = 1 />

包 火山.ImGui <注释 = "例程下载: https://saier.lanzoul.com/b016cwvle"
        注释 = "ImGui    1.89.7     https://github.com/ocornut/imgui"
        注释 = "GLFW     3.3.8      https://www.glfw.org" 注释 = "SDL      2.26.5     https://www.libsdl.org"
        注释 = "Vulkan   1.3.246.1  https://vulkan.lunarg.com/sdk/home"
        注释 = "glad     2023-04-04 https://github.com/Dav1dde/glad"
        注释 = "freetype 2.13.0     https://www.freetype.org" @视窗.外部头文件 = "imgui\\piv_imgui.hpp"
        @视窗.外部源文件 = "imgui\\imgui.cpp\r\nimgui\\imgui_draw.cpp\r\nimgui\\imgui_tables.cpp\r\nimgui\\imgui_widgets.cpp\r\nimgui\\imgui_demo.cpp\r\nimgui\\misc\\cpp\\imgui_stdlib.cpp"
        @视窗.头文件搜寻目录 = "imgui\r\nFrameWork">

类 ImGui <公开 注释 = "ImGui是一个即时渲染UI,即每一帧都会重新计算布局和渲染,对CPU和GPU的占用比MFC/WTL高."
        注释 = "由于采用DirectX、OpenGL、Vulkan等引擎渲染界面，性能和图像质量都很高.">
{
    方法 检查版本 <公开 静态 注释 = "用于验证调用方代码和Dear ImGui编译版本之间的ABI兼容性" 折叠 @嵌入式方法 = "">
    {
        @ IMGUI_CHECKVERSION()
    }

    方法 "//高质量字体渲染" <公开 静态 @视窗.预定义宏 = "IMGUI_ENABLE_FREETYPE">

    # 上下文 | Context creation and access

    方法 创建上下文 <公开 静态 类型 = 变整数 注释 = "创建ImGUI上下文,并返回所创建的上下文指针." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)ImGui::CreateContext()
    }

    方法 销毁上下文 <公开 静态 注释 = "销毁ImGUI上下文" 折叠 @嵌入式方法 = "">
    参数 上下文指针 <类型 = 变整数 注释 = "所欲销毁的上下文指针,0为当前上下文." @默认值 = 0>
    {
        @ ImGui::DestroyContext((ImGuiContext*)@<上下文指针>)
    }

    方法 取当前上下文 <公开 静态 类型 = 变整数 注释 = "返回当前的上下文指针" 返回值注释 = "ImGuiContext*" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)ImGui::GetCurrentContext()
    }

    方法 置当前上下文 <公开 静态 注释 = "将指定的上下文指针设置为当前ImGUI上下文" 折叠 @嵌入式方法 = "">
    参数 上下文指针 <类型 = 变整数>
    {
        @ ImGui::SetCurrentContext((ImGuiContext*)@<上下文指针>)
    }

    方法 取字体图集 <公开 静态 类型 = IM字体图集类 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM字体图集类>{ImGui::GetIO().Fonts}
    }

    # 主体 | Main

    方法 取IO <公开 静态 类型 = ImGuiIO类 注释 = "返回ImGui的IO结构体(鼠标/键盘/游戏手柄的输入、时间、各种配置选项和标志)" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImGuiIO类>{&ImGui::GetIO()}
    }

    方法 取样式 <公开 静态 类型 = IM样式类 注释 = "返回当前的样式配置" 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM样式类>{ImGui::GetStyle()}
    }

    方法 新建帧 <公开 静态 注释 = "创建一个新的Dear ImGUI帧,然后在调用\"渲染/结束帧\"之前执行界面布局的相关命令." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::NewFrame()
    }

    方法 结束帧 <公开 静态 注释 = "结束当前帧,\"渲染\"会自动调用本方法,当你不需要渲染数据时可以单独调用本方法." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::EndFrame()
    }

    方法 渲染 <公开 静态 注释 = "结束当前帧并完成要绘制的数据,之后可以调用\"取渲染数据\"." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::Render()
    }

    方法 取渲染数据 <公开 静态 类型 = 变整数 注释 = "返回所渲染的数据,在执行\"渲染\"后到下一次\"新建帧\"之前可用." 返回值注释 = "ImDrawData*" 折叠
            @嵌入式方法 = "">
    {
        @ (INT_P)ImGui::GetDrawData()
    }

    # 演示、调试、信息 | Demo, Debug, Information

    方法 显示演示窗口 <公开 静态 注释 = "显示ImGUI自带的演示窗口,可以在这个窗口中体验ImGui的基础功能." 折叠 @嵌入式方法 = "">
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非将在窗口上显示一个关闭按钮,通过按钮关闭窗口后会将逻辑型设置为假." @默认值 = 空对象>
    {
        @ ImGui::ShowDemoWindow((bool*)piv::GetBaseDataPtr(@<打开状态>))
    }

    方法 字体选择器 <公开 静态 注释 = "创建一个字体选择器组件" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在字体选择器旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    {
        @ ImGui::FontSelector(*PivAny2U{@<标签文本>})
    }

    方法 取版本名称 <公开 静态 类型 = 文本型 注释 = "返回ImGui的版本名称" 折叠 @嵌入式方法 = "">
    {
        @ @an<CVolString>{ImGui::GetVersion()}
    }

    # 样式 | Styles

    方法 深色样式 <公开 静态 注释 = "将ImGui的配色主题设置为深色样式(默认值)" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::StyleColorsDark()
    }

    方法 浅色样式 <公开 静态 注释 = "将ImGui的配色主题设置为浅色样式" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::StyleColorsLight()
    }

    方法 经典样式 <公开 静态 注释 = "将ImGui的配色主题设置为经典样式" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::StyleColorsClassic()
    }

    # 窗口 | Windows

    方法 创建窗口 <公开 静态 注释 = "创建一个窗口,然后可以在子语句体中添加组件." 注释 = "如果窗口已被折叠或被完全裁剪,则子语句体中的代码不会被执行."
            注释 = "注意: 本方法是\"窗口开端\"和\"窗口末端\"的结合体." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::End();\"">
    参数 窗口名称 <注释 = "提供窗口的标题名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非空将在窗口上显示一个关闭按钮,通过按钮关闭窗口后会将本参数的逻辑值设置为假." @默认值 = 空对象>
    参数 窗口标志 <类型 = 整数 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ if (ImGui::Begin(*PivAny2U{@<窗口名称>}, (bool*)piv::GetBaseDataPtr(@<打开状态>), (ImGuiWindowFlags)@<窗口标志>) == true)
    }

    方法 创建子窗口 <公开 静态 注释 = "在窗口中创建一个子窗口,然后可以在子语句体中添加组件,子窗口也可以嵌入自己的子窗口."
            注释 = "如果子窗口已被折叠或被完全裁剪,则子语句体中的代码不会被执行." 注释 = "注意: 本方法是\"子窗口开端\"和\"子窗口末端\"的结合体." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::EndChild();\"">
    参数 文本ID <注释 = "提供子窗口的文本ID(子窗口没有可显示的标签文本);" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 子窗口尺寸 <类型 = ImVec2 注释 = "提供子窗口的尺寸,等于0.0f: 使用剩余的主窗口大小; 大于0.0f: 使用固定大小; 小于0.0f: 使用剩余窗口大小减去绝对大小"
            @默认值 = 空对象>
    参数 显示边框 <类型 = 逻辑型 注释 = "子窗口是否显示边框" @默认值 = 假>
    参数 窗口标志 <类型 = 整数 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ if (ImGui::BeginChild(*PivAny2U{@<文本ID>}, @<子窗口尺寸>, (bool)@<显示边框>, (ImGuiWindowFlags)@<窗口标志>) == true)
    }

    方法 窗口开端 <公开 静态 类型 = 逻辑型 注释 = "将窗口推送到堆栈并开始添加组件" 返回值注释 = "返回假表示窗口已被折叠或被完全裁剪,此时你可以省略往窗口中提交内容." 折叠
            @嵌入式方法 = "">
    参数 窗口名称 <注释 = "提供窗口的标题名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非空将在窗口上显示一个关闭按钮,通过按钮关闭窗口后会将本参数的逻辑值设置为假." @默认值 = 空对象>
    参数 窗口标志 <类型 = 整数 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ ImGui::Begin(*PivAny2U{@<窗口名称>}, (bool*)piv::GetBaseDataPtr(@<打开状态>), (ImGuiWindowFlags)@<窗口标志>)
    }

    方法 窗口末端 <公开 静态 注释 = "从堆栈中弹出窗口,结束窗口的布局设计." 注释 = "无论\"窗口开端\"的返回值如何,都必须成对调用本方法." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::End()
    }

    方法 子窗口开端 <公开 静态 类型 = 逻辑型 注释 = "使用子窗口开始进入主窗口内独立的滚动/剪切区域,子窗口也可以嵌入自己的子窗口."
            返回值注释 = "返回假表示子窗口已被折叠或被完全裁剪,此时你可以省略往子窗口中提交内容." 折叠 @嵌入式方法 = "">
    参数 文本ID <注释 = "提供子窗口的文本ID(子窗口没有可显示的标签文本);" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 子窗口尺寸 <类型 = ImVec2 注释 = "提供子窗口的尺寸,等于0.0f: 使用剩余的主窗口大小; 大于0.0f: 使用固定大小; 小于0.0f: 使用剩余窗口大小减去绝对大小"
            @默认值 = 空对象>
    参数 显示边框 <类型 = 逻辑型 注释 = "子窗口是否显示边框" @默认值 = 假>
    参数 窗口标志 <类型 = 整数 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ ImGui::BeginChild(*PivAny2U{@<文本ID>}, @<子窗口尺寸>, (bool)@<显示边框>, (ImGuiWindowFlags)@<窗口标志>)
    }

    方法 子窗口末端 <公开 静态 注释 = "结束子窗口的布局设计." 注释 = "无论\"子窗口开端\"的返回值如何,都必须成对调用本方法." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::EndChild()
    }

    # 窗口实用程序 | Windows Utilities

    方法 窗口是否首次显示 <公开 静态 类型 = 逻辑型 注释 = "返回当前窗口是否为首次显示状态(第一次显示窗口或从隐藏切换到显示状态)" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsWindowAppearing()
    }

    方法 窗口是否折叠 <公开 静态 类型 = 逻辑型 注释 = "返回当前窗口是否为折叠状态" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsWindowCollapsed()
    }

    方法 窗口可有焦点 <公开 静态 类型 = 逻辑型 注释 = "返回当前窗口是否具有焦点" 折叠 @嵌入式方法 = "">
    参数 焦点标志 <类型 = 整数 @默认值 = IM焦点标志.无>
    {
        @ ImGui::IsWindowFocused((ImGuiHoveredFlags)@<焦点标志>)
    }

    方法 窗口可有悬停 <公开 静态 类型 = 逻辑型 注释 = "返回当前窗口是否有鼠标悬停" 折叠 @嵌入式方法 = "">
    参数 悬停标志 <类型 = 整数 @默认值 = IM悬停标志.无>
    {
        @ ImGui::IsWindowHovered((ImGuiHoveredFlags)@<悬停标志>)
    }

    方法 取窗口绘制列表 <公开 静态 类型 = IM绘制列表类 注释 = "获取与当前窗口关联的绘制列表,可以附加你自己绘制的基本图形." 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM绘制列表类>{ImGui::GetWindowDrawList()}
    }

    方法 取窗口DPI缩放 <公开 静态 类型 = 单精度小数 注释 = "返回与当前窗口视口关联的DPI缩放" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetWindowDpiScale()
    }

    方法 取窗口位置 <公开 静态 类型 = ImVec2 注释 = "返回当前窗口的位置" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetWindowPos()}
    }

    方法 取窗口尺寸 <公开 静态 类型 = ImVec2 注释 = "返回当前窗口的尺寸" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetWindowSize()}
    }

    方法 取窗口宽度 <公开 静态 类型 = 单精度小数 注释 = "返回当前窗口的宽度" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetWindowWidth()
    }

    方法 取窗口高度 <公开 静态 类型 = 单精度小数 注释 = "返回当前窗口的高度" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetWindowHeight()
    }

    方法 取窗口视口 <公开 静态 类型 = IM视口类 注释 = "返回与当前窗口关联的视口" 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM视口类>{ImGui::GetWindowViewport()}
    }

    # 窗口操作 | Window manipulation

    方法 置下一窗口位置 <公开 静态 注释 = "设置下一个窗口的位置,请在\"窗口/窗口开端\"之前调用." 折叠 @嵌入式方法 = "">
    参数 窗口位置 <类型 = ImVec2>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    参数 窗口中心点 <类型 = ImVec2 注释 = "提供窗口的中心点位置,(0.5,0.5)为中间." @默认值 = 空对象>
    {
        @ ImGui::SetNextWindowPos(@<窗口位置>, (ImGuiCond)@<执行条件>, @<窗口中心点>)
    }

    方法 置下一窗口尺寸 <公开 静态 注释 = "设置下一个窗口的尺寸,请在\"窗口/窗口开端\"之前调用."
            注释 = "set axis to 0.0f to force an auto-fit on this axis. call before Begin()" 折叠 @嵌入式方法 = "">
    参数 窗口尺寸 <类型 = ImVec2>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetNextWindowSize(@<窗口尺寸>, (ImGuiCond)@<执行条件>)
    }

    方法 置下一窗口尺寸限制 <公开 静态 注释 = "设置下一个窗口的尺寸限制,请在\"窗口/窗口开端\"之前调用."
            注释 = "use -1,-1 on either X/Y axis to preserve the current size. Sizes will be rounded down."
            注释 = "Use callback to apply non-trivial programmatic constraints." 折叠 @嵌入式方法 = "">
    参数 最小尺寸 <类型 = ImVec2>
    参数 最大尺寸 <类型 = ImVec2>
    {
        @ ImGui::SetNextWindowSizeConstraints(@<最小尺寸>, @<最大尺寸>, nullptr, nullptr)
    }

    方法 置下一窗口内容尺寸 <公开 静态 注释 = "设置下一个窗口的内容尺寸,请在\"窗口/窗口开端\"之前调用."
            注释 = "内容尺寸即可滚动的客户区,滚动条控制的区域,不包括窗口装饰(标题栏、菜单栏等)和窗口填充." 折叠 @嵌入式方法 = "">
    参数 内容尺寸 <类型 = ImVec2 注释 = "将轴设置为0.0f以使其保持自动">
    {
        @ ImGui::SetNextWindowContentSize(@<内容尺寸>)
    }

    方法 置下一窗口折叠状态 <公开 静态 注释 = "设置下一个窗口的折叠状态,请在\"窗口/窗口开端\"之前调用." 折叠 @嵌入式方法 = "">
    参数 是否折叠 <类型 = 逻辑型>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetNextWindowCollapsed((bool)@<是否折叠>, (ImGuiCond)@<执行条件>)
    }

    方法 置下一窗口获得焦点 <公开 静态 注释 = "设置下一个窗口获得输入焦点,请在\"窗口/窗口开端\"之前调用." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::SetNextWindowFocus()
    }

    方法 置下一窗口滚动量 <公开 静态 注释 = "设置下一个窗口的滚动量,请在\"窗口/窗口开端\"之前调用." 折叠 @嵌入式方法 = "">
    参数 滚动量 <类型 = ImVec2 注释 = "值小于0.0f时将不影响对应轴">
    {
        @ ImGui::SetNextWindowScroll(@<滚动量>)
    }

    方法 置下一窗口背景透明度 <公开 静态 注释 = "设置下一个窗口的背景颜色透明度,请在\"窗口开端\"之前调用."
            注释 = "helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg."
            注释 = "you may also use ImGuiWindowFlags_NoBackground." 折叠 @嵌入式方法 = "">
    参数 Alpha值 <类型 = 单精度小数 注释 = "0.0-1.0">
    {
        @ ImGui::SetNextWindowBgAlpha(@<Alpha值>)
    }

    方法 置下一窗口视口 <公开 静态 注释 = "设置下一个窗口的视口" 折叠 @嵌入式方法 = "">
    参数 视口ID <类型 = 整数>
    {
        @ ImGui::SetNextWindowViewport((ImGuiID)@<视口ID>)
    }

    方法 置窗口位置 <公开 静态 注释 = "设置指定窗口的位置" 折叠 @嵌入式方法 = "">
    参数 窗口名称 <注释 = "提供所欲设置位置的窗口名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 窗口位置 <类型 = ImVec2>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetWindowPos(*PivAny2U{@<窗口名称>}, @<窗口位置>, (ImGuiCond)@<执行条件>)
    }

    方法 置窗口尺寸 <公开 静态 注释 = "设置指定窗口的尺寸,请在\"窗口开端\"之前调用. set axis to 0.0f to force an auto-fit on this axis." 折叠
            @嵌入式方法 = "">
    参数 窗口名称 <注释 = "提供所欲设置尺寸的窗口名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 窗口尺寸 <类型 = ImVec2>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetWindowSize(*PivAny2U{@<窗口名称>}, @<窗口尺寸>, (ImGuiCond)@<执行条件>)
    }

    方法 置窗口折叠状态 <公开 静态 注释 = "设置指定窗口的折叠状态" 折叠 @嵌入式方法 = "">
    参数 窗口名称 <注释 = "提供所欲设置折叠状态的窗口名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 是否折叠 <类型 = 逻辑型>
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetWindowCollapsed(*PivAny2U{@<窗口名称>}, (bool)@<是否折叠>, (ImGuiCond)@<执行条件>)
    }

    方法 置窗口获得焦点 <公开 静态 注释 = "设置指定窗口获得输入焦点" 折叠 @嵌入式方法 = "">
    参数 窗口名称 <注释 = "提供所欲获得焦点的窗口名称;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    {
        @ ImGui::SetWindowFocus(*PivAny2U{@<窗口名称>})
    }

    # 内容区域 | Content region

    方法 取可用内容区域 <公开 静态 类型 = ImVec2 注释 = "等同于\"取最大内容区域() - 取光标位置()\"." 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetContentRegionAvail()}
    }

    方法 取最大内容区域 <公开 静态 类型 = ImVec2
            注释 = "current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates"
            折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetContentRegionMax()}
    }

    方法 取最小窗口内容区域 <公开 静态 类型 = ImVec2
            注释 = "content boundaries min for the full window (roughly (0,0)-Scroll), in window coordinates" 折叠
            @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetWindowContentRegionMin()}
    }

    方法 取最大窗口内容区域 <公开 静态 类型 = ImVec2
            注释 = "content boundaries max for the full window (roughly (0,0)+Size-Scroll) where Size can be overridden with SetNextWindowContentSize(), in window coordinates"
            折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetWindowContentRegionMax()}
    }

    # 滚动窗口 | Windows Scrolling

    方法 取水平滚动量 <公开 静态 类型 = 单精度小数 注释 = "get scrolling amount [0 .. GetScrollMaxX()]" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetScrollX()
    }

    方法 取垂直滚动量 <公开 静态 类型 = 单精度小数 注释 = "get scrolling amount [0 .. GetScrollMaxY()]" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetScrollY()
    }

    方法 置水平滚动量 <公开 静态 注释 = "set scrolling amount [0 .. GetScrollMaxX()]" 折叠 @嵌入式方法 = "">
    参数 滚动量 <类型 = 单精度小数>
    {
        @ ImGui::SetScrollX(@<滚动量>)
    }

    方法 置垂直滚动量 <公开 静态 注释 = "set scrolling amount [0 .. GetScrollMaxY()]" 折叠 @嵌入式方法 = "">
    参数 滚动量 <类型 = 单精度小数>
    {
        @ ImGui::SetScrollY(@<滚动量>)
    }

    方法 取最大水平滚动量 <公开 静态 类型 = 单精度小数
            注释 = "get maximum scrolling amount ~~ ContentSize.x - WindowSize.x - DecorationsSize.x" 折叠
            @嵌入式方法 = "">
    {
        @ ImGui::GetScrollMaxX()
    }

    方法 取最大垂直滚动量 <公开 静态 类型 = 单精度小数
            注释 = "get maximum scrolling amount ~~ ContentSize.y - WindowSize.y - DecorationsSize.y" 折叠
            @嵌入式方法 = "">
    {
        @ ImGui::GetScrollMaxY()
    }

    方法 水平滚动至此 <公开 静态
            注释 = "adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right."
            注释 = "When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead."
            折叠 @嵌入式方法 = "">
    参数 水平中心比例 <类型 = 单精度小数 @默认值 = 0.5>
    {
        @ ImGui::SetScrollHereX(@<水平中心比例>)
    }

    方法 垂直滚动至此 <公开 静态
            注释 = "adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom."
            注释 = "When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead."
            折叠 @嵌入式方法 = "">
    参数 垂直中心比例 <类型 = 单精度小数 @默认值 = 0.5>
    {
        @ ImGui::SetScrollHereY(@<垂直中心比例>)
    }

    方法 置水平滚动位置 <公开 静态
            注释 = "adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position."
            折叠 @嵌入式方法 = "">
    参数 水平位置 <类型 = 单精度小数>
    参数 水平中心比例 <类型 = 单精度小数 @默认值 = 0.5>
    {
        @ ImGui::SetScrollFromPosX(@<水平位置>, @<水平中心比例>)
    }

    方法 置垂直滚动位置 <公开 静态
            注释 = "adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position."
            折叠 @嵌入式方法 = "">
    参数 垂直位置 <类型 = 单精度小数>
    参数 垂直中心比例 <类型 = 单精度小数 @默认值 = 0.5>
    {
        @ ImGui::SetScrollFromPosY(@<垂直位置>, @<垂直中心比例>)
    }

    # 参数堆栈(共用) | Parameters stacks (shared)

    方法 设置字体 <公开 静态 注释 = "将指定的字体压入到堆栈,然后在子语句体中更改字体的参数." 注释 = "本方法不需要手动弹出堆栈." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopFont();\"">
    参数 字体 <类型 = IM字体类>
    {
        @ ImGui::PushFont(@<字体>)
    }

    方法 压入样式颜色 <公开 静态 注释 = "在\"新建帧\"之后需要调用本方法修改一个\"整数\"类型的样式颜色,必须与\"弹出样式颜色\"成对使用." 折叠 @嵌入式方法 = "">
    参数 颜色ID <类型 = IM颜色标识符>
    参数 新颜色 <类型 = 整数>
    {
        @ ImGui::PushStyleColor((ImGuiCol)@<颜色ID>, @<新颜色>)
    }

    方法 压入样式颜色2 <公开 静态 注释 = "在\"新建帧\"之后需要调用本方法修改一个\"ImVec4\"类型的样式颜色,必须与\"弹出样式颜色\"成对使用." 折叠 @嵌入式方法 = "">
    参数 颜色ID <类型 = IM颜色标识符>
    参数 新颜色 <类型 = ImVec4>
    {
        @ ImGui::PushStyleColor((ImGuiCol)@<颜色ID>, @<新颜色>)
    }

    方法 弹出样式颜色 <公开 静态 注释 = "必须与\"压入样式颜色\"成对使用." 折叠 @嵌入式方法 = "">
    参数 弹出次数 <类型 = 整数 @默认值 = 1>
    {
        @ ImGui::PopStyleColor(@<弹出次数>)
    }

    方法 压入样式变量 <公开 静态 注释 = "在\"新建帧\"之后需要调用本方法修改一个\"小数\"变量的样式,必须与\"弹出样式变量\"成对使用." 折叠 @嵌入式方法 = "">
    参数 样式变量ID <类型 = IM样式标识符>
    参数 新值 <类型 = 单精度小数>
    {
        @ ImGui::PushStyleVar((ImGuiStyleVar)@<样式变量ID>, @<新值>)
    }

    方法 压入样式变量2 <公开 静态 注释 = "在\"新建帧\"之后需要调用本方法修改一个\"ImVec4\"变量的样式,必须与\"弹出样式变量\"成对使用." 折叠 @嵌入式方法 = "">
    参数 样式变量ID <类型 = IM样式标识符>
    参数 新值 <类型 = ImVec4>
    {
        @ ImGui::PushStyleVar((ImGuiStyleVar)@<样式变量ID>, @<新值>)
    }

    方法 弹出样式变量 <公开 静态 注释 = "必须与\"压入样式变量\"成对使用." 折叠 @嵌入式方法 = "">
    参数 弹出次数 <类型 = 整数 @默认值 = 1>
    {
        @ ImGui::PopStyleVar(@<弹出次数>)
    }

    方法 设置可停留焦点 <公开 静态 注释 = "可以选择是否让子语句体中创建的组件禁用可停留焦点(允许使用TAB/Shift+TAB循环切换焦点)." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopTabStop();\"">
    参数 是否可停留焦点 <类型 = 逻辑型 注释 = "默认情况下已启用可停留焦点">
    {
        @ ImGui::PushTabStop((bool)@<是否可停留焦点>);
    }

    方法 设置可重复按钮 <公开 静态 注释 = "可以选择是否让子语句体中创建的按钮启用\"重复\"模式." 注释 = "在\"重复\"模式下,按住\"按钮\"不放将会重复返回结果." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopButtonRepeat();\"">
    参数 是否可重复 <类型 = 逻辑型>
    {
        @ ImGui::PushButtonRepeat((bool)@<是否可重复>);
    }

    # 参数堆栈(当前窗口) | Parameters stacks (current window)

    方法 设置项目宽度 <公开 静态 注释 = "子语句体中创建的项目将统一为所指定的项目宽度."
            注释 = "push width of items for common large \"item+label\" widgets. >0.0f: width in pixels,"
            注释 = "<0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)."
            折叠 隐藏值属性 = "0" @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopItemWidth();\"">
    参数 项目宽度 <类型 = 单精度小数>
    {
        @ ImGui::PushItemWidth(@<项目宽度>);
    }

    方法 置下一项目宽度 <公开 静态
            注释 = "set width of the _next_ common large \"item+label\" widget. >0.0f: width in pixels,"
            注释 = "<0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)"
            折叠 @嵌入式方法 = "">
    参数 新项目宽度 <类型 = 单精度小数>
    {
        @ ImGui::SetNextItemWidth(@<新项目宽度>)
    }

    方法 计算项目宽度 <公开 静态 类型 = 单精度小数
            注释 = "width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most \'Item\' functions."
            折叠 @嵌入式方法 = "">
    {
        @ ImGui::CalcItemWidth()
    }

    方法 设置文本换行位置 <公开 静态 注释 = "子语句体中创建的文本框将统一按指定的位置换行." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopTextWrapPos();\"">
    参数 换行位置 <类型 = 单精度小数 注释 = "小于0.0f: 不换行; 等于0.0f: 按窗口/列边缘换行; 大于0.0f: 按提供的位置换行.">
    {
        @ ImGui::PushTextWrapPos(@<换行位置>);
    }

    # 只读访问样式 | Style read access

    方法 取当前字体 <公开 静态 类型 = IM字体类 注释 = "返回当前字体" 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM字体类>{ImGui::GetFont()}
    }

    方法 取字体大小 <公开 静态 类型 = 单精度小数 注释 = "获取基于当前字体的字体大小(等于像素高度),该大小应用了当前的缩放比例." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetFontSize()
    }

    方法 取字体白色纹理UV <公开 静态 类型 = ImVec2
            注释 = "get UV coordinate for a white pixel, useful to draw custom shapes via the ImDrawList API" 折叠
            @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetFontTexUvWhitePixel()}
    }

    方法 取32位颜色 <公开 静态 类型 = 整数
            注释 = "retrieve given style color with style alpha applied and optional extra alpha multiplier,"
            注释 = "packed as a 32-bit value suitable for ImDrawList" 折叠 @嵌入式方法 = "">
    参数 颜色ID <类型 = IM颜色标识符>
    参数 Alpha乘数 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ ImGui::GetColorU32((ImGuiCol)@<颜色ID>, @<Alpha乘数>)
    }

    方法 取32位颜色2 <公开 静态 类型 = 整数
            注释 = "retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList"
            折叠 @嵌入式方法 = "">
    参数 颜色 <类型 = ImVec4>
    {
        @ ImGui::GetColorU32(@<颜色>)
    }

    方法 取32位颜色3 <公开 静态 类型 = 整数
            注释 = "retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList"
            折叠 @嵌入式方法 = "">
    参数 颜色 <类型 = 整数>
    {
        @ ImGui::GetColorU32(@<颜色>)
    }

    方法 取样式颜色 <公开 静态 类型 = ImVec4
            注释 = "retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(),"
            注释 = "otherwise use GetColorU32() to get style color with style alpha baked in." 折叠 @嵌入式方法 = "">
    参数 颜色ID <类型 = IM颜色标识符>
    {
        @ @dt<ImVec4>{ImGui::GetStyleColorVec4((ImGuiCol)@<颜色ID>)}
    }

    # 光标、布局 | Cursor / Layout

    方法 分隔条 <公开 静态 注释 = "插入一个分隔条,通常是水平的,但在菜单栏或水平布局模式中会变成垂直分隔条." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::Separator()
    }

    方法 同一行 <公开 静态 注释 = "在小组件或分组框之间调用本方法,可以将它们水平布局." 折叠 @嵌入式方法 = "">
    参数 水平偏移位置 <类型 = 单精度小数 注释 = "等于0将位于上一项目的后面,不为0时对齐到指定的X轴坐标(窗口或分组框左边的相对坐标)" @默认值 = 0.0>
    参数 水平间距 <类型 = 单精度小数 注释 = "小于0时,若\"水平偏移位置\"等于0表示使用默认间距,若\"水平偏移位置\"不等于0则没有间距." 注释 = "本值大于等于0将强制执行指定的间距;"
            @默认值 = -1.0>
    {
        @ ImGui::SameLine(@<水平偏移位置>, @<水平间距>)
    }

    方法 换行 <公开 静态 注释 = "撤销\"同一行\",或者在水平布局上下文中强制换行." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::NewLine()
    }

    方法 添加间距 <公开 静态 注释 = "添加一个垂直间距" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::Spacing()
    }

    方法 伪项目 <公开 静态 注释 = "添加一个指定大小的伪项目,与\"隐身按钮\"不同,伪项目不能被鼠标点击或导航." 折叠 @嵌入式方法 = "">
    参数 尺寸 <类型 = ImVec2 注释 = "x为宽度,y为高度">
    {
        @ ImGui::Dummy(@<尺寸>)
    }

    方法 增加缩进 <公开 静态 注释 = "将内容的位置向右移动" 折叠 @嵌入式方法 = "">
    参数 缩进间距 <类型 = 单精度小数 注释 = "如果\"缩进间距\"小于等于0,则按\"style.IndentSpacing\"的大小移动,否则按提供的值移动." @默认值 = 0.0>
    {
        @ ImGui::Indent(@<缩进间距>)
    }

    方法 减少缩进 <公开 静态 注释 = "将内容的位置向左移动" 折叠 @嵌入式方法 = "">
    参数 缩进间距 <类型 = 单精度小数 注释 = "如果\"缩进间距\"小于等于0,则按\"style.IndentSpacing\"的大小移动,否则按提供的值移动." @默认值 = 0.0>
    {
        @ ImGui::Unindent(@<缩进间距>)
    }

    方法 分组框 <公开 静态 注释 = "创建一个分组框,在子语句体里创建的多个项目会最终被捕获为一个项目." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::EndGroup();\"">
    {
        @ ImGui::BeginGroup();
    }

    方法 取光标位置 <公开 静态 类型 = ImVec2 注释 = "返回相对于窗口坐标的光标位置" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetCursorPos()}
    }

    方法 取光标水平位置 <公开 静态 类型 = 单精度小数 注释 = "返回相对于窗口坐标的水平光标位置" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetCursorPosX()
    }

    方法 取光标垂直位置 <公开 静态 类型 = 单精度小数 注释 = "返回相对于窗口坐标的垂直光标位置" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetCursorPosY()
    }

    方法 置光标位置 <公开 静态 注释 = "设置相对于窗口坐标的光标位置" 折叠 @嵌入式方法 = "">
    参数 本地位置 <类型 = ImVec2>
    {
        @ ImGui::SetCursorPos(@<本地位置>)
    }

    方法 置光标水平位置 <公开 静态 折叠 @嵌入式方法 = "">
    参数 水平位置 <类型 = 单精度小数>
    {
        @ ImGui::SetCursorPosX(@<水平位置>)
    }

    方法 置光标垂直位置 <公开 静态 折叠 @嵌入式方法 = "">
    参数 垂直位置 <类型 = 单精度小数>
    {
        @ ImGui::SetCursorPosY(@<垂直位置>)
    }

    方法 取光标起始位置 <公开 静态 类型 = ImVec2 注释 = "返回相对于窗口坐标的初始光标位置" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetCursorStartPos()}
    }

    方法 取光标屏幕位置 <公开 静态 类型 = ImVec2 注释 = "返回绝对坐标的光标位置"
            注释 = "enerally top-left == GetMainViewport()->Pos == (0,0) in single viewport mode,"
            注释 = "and bottom-right == GetMainViewport()->Pos+Size == io.DisplaySize in single-viewport mode." 折叠
            @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetCursorScreenPos()}
    }

    方法 置光标屏幕位置 <公开 静态 注释 = "设置光标位置的绝对坐标" 折叠 @嵌入式方法 = "">
    参数 光标位置 <类型 = ImVec2>
    {
        @ ImGui::SetCursorScreenPos(@<光标位置>)
    }

    方法 文本对齐到框边距 <公开 静态 注释 = "将之后显示的文本基线与\"FramePadding.y\"垂直对齐,使其与常规带框的项目正确对齐." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::AlignTextToFramePadding()
    }

    方法 取文本行高 <公开 静态 类型 = 单精度小数 注释 = "返回文本的行高,约等于字体大小." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetTextLineHeight()
    }

    方法 取文本带间距行高 <公开 静态 类型 = 单精度小数 注释 = "返回两行连续文本之间的像素距离,约等于字体大小 + 项目垂直间距." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetTextLineHeightWithSpacing()
    }

    方法 取边框高度 <公开 静态 类型 = 单精度小数 注释 = "返回项目的框高度,约等于字体大小 + 框垂直边距 * 2." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetFrameHeight()
    }

    方法 取边框带间距高度 <公开 静态 类型 = 单精度小数 注释 = "返回两个连续行的带框窗口组件之间的像素距离,约等于字体大小 + 框垂直边距 *2 + 项目垂直间距." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetFrameHeightWithSpacing()
    }

    # ID堆栈/作用域 | ID stack/scopes

    方法 设置文本ID <公开 静态 注释 = "在子语句体内的项目中添加指定的文本ID,可用于快速区别不同项目的唯一ID." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopID();\"">
    参数 文本ID <注释 = "提供一个文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    {
        @ ImGui::PushID(*PivAny2U{@<文本ID>});
    }

    方法 设置整数ID <公开 静态 注释 = "在子语句体内的项目中添加指定的整数ID,可用于快速区别不同项目的唯一ID." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopID();\"">
    参数 整数ID <类型 = 整数>
    {
        @ ImGui::PushID(@<整数ID>);
    }

    方法 取文本ID <公开 静态 类型 = 整数 注释 = "使用所提供文本ID和整个ID堆栈的hash值,计算出唯一的ID." 折叠 @嵌入式方法 = "">
    参数 文本ID <注释 = "提供一个文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    {
        @ ImGui::GetID(@<文本ID>)
    }

    # 组件: 文本框 | Widgets: Text

    方法 无格式文本框 <公开 静态 注释 = "创建一个文本框,用于显示无格式的原生文本." 注释 = "本方法无内存复制和缓冲区大小限制,建议用于长文本." 折叠 @嵌入式方法 = "">
    参数 文本内容 <注释 = "提供显示在文本框中的文本内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    {
        @ ImGui::TextUnformatted(*PivAny2U{@<文本内容>})
    }

    方法 文本框 <公开 静态 注释 = "创建一个文本框,支持格式化文本." 折叠 隐藏值属性 = "0" @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::Text(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 彩色文本框 <公开 静态 注释 = "创建一个文本框,用于显示带颜色的格式化文本." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 文本颜色 <类型 = ImVec4>
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::TextColored(@<文本颜色>, *PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 被禁用文本框 <公开 静态 注释 = "创建一个显示为禁用状态的文本框,支持格式化文本." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::TextDisabled(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 换行文本框 <公开 静态 注释 = "创建一段可以自动换行的文本框,支持格式化文本." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::TextWrapped(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 标签文本框 <公开 静态 注释 = "创建一个带标签的文本框,支持格式化文本." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 标签文本 <注释 = "提供显示在组合框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::LabelText(*PivAny2U{@<标签文本>}, *PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 项目符号文本框 <公开 静态 注释 = "创建一个带项目符号的文本框,支持格式化文本." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::BulletText(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 分隔文本框 <公开 静态 注释 = "创建一个带水平分隔线的文本框,用于显示无格式的原生文本." 折叠 @嵌入式方法 = "">
    参数 文本内容 <注释 = "提供显示在文本框中的文本内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    {
        @ ImGui::SeparatorText(*PivAny2U{@<文本内容>})
    }

    # 组件: 主要 | Widgets: Main

    方法 按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个按钮组件,按钮被单击后返回真." 返回值注释 = "按钮被单击后返回真" 折叠 @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在按钮旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 按钮尺寸 <类型 = ImVec2 注释 = "提供按钮的宽高,留空为自动根据标签文本的长度调整宽度." @默认值 = 空对象>
    {
        @ ImGui::Button(*PivAny2U{@<标签文本>}, @<按钮尺寸>)
    }

    方法 小按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个框边距为0的小按钮组件,按钮被单击后返回真." 注释 = "小按钮适合嵌入到文本行中." 返回值注释 = "按钮被单击后返回真"
            @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在按钮旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    {
        @ ImGui::SmallButton(*PivAny2U{@<标签文本>})
    }

    方法 隐身按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个不可见的按钮组件,但它仍会占用窗口位置和响应按钮行为." 返回值注释 = "本返回值受\"按钮标志\"影响" @嵌入式方法 = "">
    参数 文本ID <注释 = "提供组件的唯一文本ID,本ID不会显示在按钮中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 按钮尺寸 <类型 = ImVec2 注释 = "提供按钮的宽高">
    参数 按钮标志 <类型 = 整数 注释 = "按钮标志将影响返回值的结果" @默认值 = IM按钮标志.无>
    {
        @ ImGui::InvisibleButton(*PivAny2U{@<文本ID>}, @<按钮尺寸>, (ImGuiButtonFlags)@<按钮标志>)
    }

    方法 箭头按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个箭头形状的按钮,可以选择箭头的方向." 返回值注释 = "按钮被单击后返回真" @嵌入式方法 = "">
    参数 文本ID <注释 = "提供组件的唯一文本ID,本ID不会显示在按钮中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 箭头方向 <类型 = IM基本方向 注释 = "提供箭头的方向">
    {
        @ ImGui::ArrowButton(*PivAny2U{@<文本ID>}, (ImGuiDir)@<箭头方向>)
    }

    方法 复选框 <公开 静态 类型 = 逻辑型 注释 = "创建一个复选框" 返回值注释 = "复选框被单击后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在复选框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 选中状态 <类型 = 逻辑型 注释 = "必须提供一个逻辑型变量,表示复选框的选中状态." @需求类型 = 可写入变量>
    {
        @ ImGui::Checkbox(*PivAny2U{@<标签文本>}, (bool*)&@<选中状态>)
    }

    方法 标志复选框 <公开 静态 类型 = 逻辑型 注释 = "创建一个复选框,复选框被选中后,在\"当前标志\"中设置标志值,否则为取消设置标志值." 返回值注释 = "复选框被单击后返回真"
            @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在复选框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 当前标志 <类型 = 整数 注释 = "必须提供一个整数变量,复选框被单击后可能会更改变量的值." @需求类型 = 可写入变量>
    参数 标志值 <类型 = 整数 注释 = "提供一个标志值,复选框被选中时按位或赋值(当前标志 |= 标志值),取消选中时按位异或赋值(当前标志 ^= 标志值).">
    {
        @ ImGui::CheckboxFlags(*PivAny2U{@<标签文本>}, &@<当前标志>, @<标志值>)
    }

    方法 单选按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个单选按钮" 返回值注释 = "按钮被单击后返回真" @嵌入式方法 = "req_cpp_bool = true">
    参数 标签文本 <注释 = "提供显示在按钮旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 是否选中 <类型 = 逻辑型>
    {
        @ ImGui::RadioButton(*PivAny2U{@<标签文本>}, @<是否选中>)
    }

    方法 单选按钮Ex <公开 静态 类型 = 逻辑型 注释 = "创建一个单选按钮,提供提供的整数变量决定选中项." 返回值注释 = "按钮被单击后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在按钮旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 现行选中项目 <类型 = 整数 注释 = "必须提供一个整数变量,用来指定选中的单选按钮." @需求类型 = 可写入变量>
    参数 索引值 <类型 = 整数 注释 = "当前单选按钮的自定义索引值,当\"现行选中项目 == 索引值\",则选中当前按钮.">
    {
        @ ImGui::RadioButton(*PivAny2U{@<标签文本>}, &@<现行选中项目>, @<索引值>)
    }

    方法 进度条 <公开 静态 注释 = "创建一个进度条组件" @嵌入式方法 = "">
    参数 进度 <类型 = 单精度小数 注释 = "提供当前的进度位置,范围[0.0-1.0].">
    参数 尺寸 <类型 = ImVec2 注释 = "提供进度条的像素尺寸,小于0.0将使用全部可用宽度/高度," 注释 = "等于0.0为默认的项目宽度/高度,大于0.0则使用提供的宽度/高度."
            @默认值 = 空对象>
    参数 覆盖文本 <类型 = 标准文本类U 注释 = "默认在进度条上显示如\"95%\"的当前进度文本,若提供了自定义的文本,将覆盖原来的进度文本." @默认值 = 空对象>
    {
        @ [](@dt<ImVec2>& size_arg, PivStringU& overlay) {
        @     ImGui::ProgressBar(@<进度>, size_arg.IsNullObject() ? ImVec2(-FLT_MIN, 0) : size_arg.data(),
        @                        overlay.IsNullObject() ? nullptr : overlay.GetText());
        @ } (@<尺寸>, @<覆盖文本>)
    }

    方法 项目符号 <公开 静态 注释 = "绘制一个小圆点并将光标保持在同一行." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::Bullet()
    }

    # 组件: 图片 | Widgets: Images

    方法 图片框 <公开 静态 注释 = "创建一个图片框组件" @嵌入式方法 = "">
    参数 图片纹理ID <类型 = 变整数 注释 = "提供图片纹理ID,请使用\"IM_×××渲染器.加载图片××()\".">
    参数 图片尺寸 <类型 = ImVec2 注释 = "提供纹理图片的显示尺寸,单位为像素,本参数可以缩放图片.">
    参数 左上纹理坐标 <类型 = ImVec2 注释 = "提供纹理的左上坐标,默认的(0.0, 0.0)表示最左上角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 右下纹理坐标 <类型 = ImVec2 注释 = "提供纹理的右下坐标,默认的(1.0, 1.0)表示最右下角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 色调 <类型 = ImVec4 注释 = "默认为不添加色调" @默认值 = 空对象>
    参数 边框颜色 <类型 = ImVec4 注释 = "默认为黑色边框" @默认值 = 空对象>
    {
        @ [&](@dt<ImVec2>& uv0, @dt<ImVec2>& uv1, @dt<ImVec4>& tint_col) {
        @     ImGui::Image((ImTextureID)@<图片纹理ID>, @<图片尺寸>, uv0.IsNullObject() ? ImVec2(0, 0) : uv0.data(), uv1.IsNullObject() ? ImVec2(1, 1) : uv1.data(),
        @                  tint_col.IsNullObject() ? ImVec4(1, 1, 1, 1) : tint_col.data(), @<边框颜色>);
        @ } (@<左上纹理坐标>, @<右下纹理坐标>, @<色调>)
    }

    方法 图片按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个图片按钮组件" 返回值注释 = "按钮被单击后返回真" @嵌入式方法 = "">
    参数 文本ID <注释 = "提供组件的唯一文本ID,本ID不会显示在按钮中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 图片纹理ID <类型 = 变整数 注释 = "提供图片纹理ID,请使用\"IM_×××渲染器.加载图片××()\".">
    参数 图片尺寸 <类型 = ImVec2 注释 = "提供纹理图片的显示尺寸,单位为像素,本参数可以缩放图片.">
    参数 左上纹理坐标 <类型 = ImVec2 注释 = "提供纹理的左上坐标,默认的(0.0, 0.0)表示最左上角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 右下纹理坐标 <类型 = ImVec2 注释 = "提供纹理的右下坐标,默认的(1.0, 1.0)表示最右下角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 背景颜色 <类型 = ImVec4 注释 = "默认为黑色背景" @默认值 = 空对象>
    参数 色调 <类型 = ImVec4 注释 = "默认为不添加色调" @默认值 = 空对象>
    {
        @ [&](const char* str_id, @dt<ImVec2>& uv0, @dt<ImVec2>& uv1, @dt<ImVec4>& tint_col) {
        @     return ImGui::ImageButton(str_id, (ImTextureID)@<图片纹理ID>, @<图片尺寸>, uv0.IsNullObject() ? ImVec2(0, 0) : uv0.data(), uv1.IsNullObject() ? ImVec2(1, 1) : uv1.data(),
        @                               @<背景颜色>, tint_col.IsNullObject() ? ImVec4(1, 1, 1, 1) : tint_col.data());
        @ } (*PivAny2U{@<文本ID>}, @<左上纹理坐标>, @<右下纹理坐标>, @<色调>)
    }

    # 组件: 组合框(下拉) | Widgets: Combo Box (Dropdown)

    方法 创建组合框 <公开 静态 注释 = "创建一个组合框(下拉列表框)组件,可以在子语句体中使用\"可选项\"自定义内容." 注释 = "创建失败将不执行子语句体中的代码." 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndCombo();\\r\\n}\"">
    参数 标签文本 <注释 = "提供显示在组合框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 预览项目 <注释 = "提供组合框的默认项目文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 组合框标志 <类型 = 整数 注释 = "设置组合框的标志" @默认值 = IM组合框标志.无>
    {
        @ if (ImGui::BeginCombo(*PivAny2U{@<标签文本>}, *PivAny2U{@<预览项目>}, (ImGuiComboFlags)@<组合框标志>) == true)
    }

    方法 组合框 <公开 静态 类型 = 逻辑型 注释 = "创建一个组合框(下拉列表框)组件" 返回值注释 = "返回是否创建成功" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在组合框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 现行选中项 <类型 = 整数 注释 = "必须提供一个整数变量(必须确保其生命周期),用于返回当前选中的项目." 注释 = "如果值是\"项目数组\"的有效索引,则自动选中对应的项目."
            注释 = "变量值为-1或大于\"项目数组\"的成员数则不选中任何项目." @需求类型 = 可写入变量>
    参数 项目数组 <类型 = IM文本数组类 注释 = "提供所创建组合框的项目文本数组">
    参数 弹出框高度 <类型 = 整数 注释 = "提供组合框弹出列表框的高度,以项目数量为单位." 注释 = "比如8指的是8个项目的高度,实际项目数超过本值将显示滚动条." @默认值 = -1>
    {
        @ ImGui::Combo(*PivAny2U{@<标签文本>}, &@<现行选中项>, &@dt<IM文本数组类>::ItemGetter, IM_STRARRAY_PTR_AND_SIZE(@<项目数组>.pdata()), @<弹出框高度>)
    }

    # 组件: 拖动滑块 | Widgets: Drag Sliders

    方法 单浮点拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个单精度小数变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 单精度小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 单精度小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragFloat(*PivAny2U{@<标签文本>}, &@<值变量>, @<速度>, @<最小值>, @<最大值>,
        @                  u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 小数拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个双精度小数变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 小数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarT<double>(*PivAny2U{@<标签文本>}, ImGuiDataType_Double, &@<值变量>, @<速度>, @<最小值>,
        @                            @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 字节拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个8位字节变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 字节 注释 = "必须提供一个字节变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 字节 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 字节 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarT<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, &@<值变量>, @<速度>, @<最小值>,
        @                          @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 短整数拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个16位短整数变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 短整数 注释 = "必须提供一个短整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 短整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 短整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarT<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, &@<值变量>, @<速度>, @<最小值>,
        @                           @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 整数拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 整数 注释 = "必须提供一个整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragInt(*PivAny2U{@<标签文本>}, &@<值变量>, @<速度>, @<最小值>,
        @                @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 长整数拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一个拖动框,可以拖动更改一个64位长整数变量的值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 长整数 注释 = "必须提供一个长整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarT<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, &@<值变量>, @<速度>, @<最小值>,
        @                           @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 单浮点数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个单精度小数数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "单精度小数 []" 注释 = "必须提供单精度小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 单精度小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 单精度小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                            @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 小数数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个双精度小数数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "小数 []" 注释 = "必须提供一个小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<double>(*PivAny2U{@<标签文本>}, ImGuiDataType_Double, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                             @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 字节数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个字节数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "字节 []" 注释 = "必须提供一个字节基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 字节 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 字节 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                           @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 短整数数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个短整数数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "短整数 []" 注释 = "必须提供一个短整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 短整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 短整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                            @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 整数数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个整数数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "整数 []" 注释 = "必须提供一个整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<int>(*PivAny2U{@<标签文本>}, ImGuiDataType_S32, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                          @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 长整数数组拖动框 <公开 静态 类型 = 逻辑型 注释 = "提供一个长整数数组,在一行内创建跟数组成员数相同数量的拖动框." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "长整数 []" 注释 = "必须提供一个长整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 长整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 长整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, IM_ARRAY_AND_SIZE(@<数组变量>), @<速度>,
        @                            @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 ImVec2拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一行两个拖动框,可以拖动更改ImVec2中两个成员值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数据变量 <类型 = ImVec2 注释 = "必须提供一个ImVec2变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 单精度小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 单精度小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, (float*)@<数据变量>.pdata(), 2, @<速度>,
        @                            @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 ImVec4拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一行四个拖动框,可以拖动更改ImVec4中四个成员值." 注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值."
            返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数据变量 <类型 = ImVec4 注释 = "必须提供一个ImVec4变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 单精度小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 单精度小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::DragScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, (float*)@<数据变量>.pdata(), 4, @<速度>,
        @                            @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 单浮点范围拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一组两个拖动框,可以拖动更改两个单精度小数变量的值,其中第一个值始终不大于第二个值."
            注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值." 返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 当前较小值 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 当前较大值 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 单精度小数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0.0>
    参数 最大值 <类型 = 单精度小数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0.0>
    参数 较小值格式 <类型 = 文本型 注释 = "较小值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 较大值格式 <类型 = 文本型 注释 = "较大值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.始终限制范围>
    {
        @ ImGui::DragFloatRange2(*PivAny2U{@<标签文本>}, &@<当前较小值>, &@<当前较大值> @<速度>, @<最小值>, @<最大值>,
        @                        u8@sn<quot>@pvpt<较小值格式>@sn<quot>, u8@sn<quot>@pvpt<较大值格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 整数范围拖动框 <公开 静态 类型 = 逻辑型 注释 = "创建一组两个拖动框,可以拖动更改两个整数变量的值,其中第一个值始终不大于第二个值."
            注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值." 返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖动框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 当前较小值 <类型 = 整数 注释 = "必须提供一个整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 当前较大值 <类型 = 整数 注释 = "必须提供一个整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 速度 <类型 = 单精度小数 注释 = "速度为鼠标每移动1像素的变动量,默认为每移动1像素增减1.0f" @默认值 = 1.0>
    参数 最小值 <类型 = 整数 注释 = "若\"最小值 < 最大值\"则限制拖动更改数值的范围,但Ctrl+单击手动输入时不受限." @默认值 = 0>
    参数 最大值 <类型 = 整数 注释 = "若\"最小值 >= 最大值\"将不限制拖动更改数值的范围." @默认值 = 0>
    参数 较小值格式 <类型 = 文本型 注释 = "较小值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 较大值格式 <类型 = 文本型 注释 = "较大值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.始终限制范围>
    {
        @ ImGui::DragIntRange2(*PivAny2U{@<标签文本>}, &@<当前较小值>, &@<当前较大值>, @<速度>, @<最小值>, @<最大值>,
        @                      u8@sn<quot>@pvpt<较小值格式>@sn<quot>, u8@sn<quot>@pvpt<较大值格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    # 组件: 常规滑块条 | Widgets: Regular Sliders

    方法 单浮点滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个单精度小数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 单精度小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 单精度小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderFloat(*PivAny2U{@<标签文本>}, &@<值变量>, @<最小值>, @<最大值>,
        @                    u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 小数滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个双精度小数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 小数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarT<double>(*PivAny2U{@<标签文本>}, ImGuiDataType_Double, &@<值变量>, @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 字节滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个8位字节变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 字节 注释 = "必须提供一个字节变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 字节 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 字节 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarT<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, &@<值变量>, @<最小值>,
        @                            @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 短整数滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个16位短整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 短整数 注释 = "必须提供一个短整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 短整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 短整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarT<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, &@<值变量>, @<最小值>,
        @                             @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 整数滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 整数 注释 = "必须提供一个整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderInt(*PivAny2U{@<标签文本>}, &@<值变量>, @<最小值>, @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 长整数滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个64位长整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 长整数 注释 = "必须提供一个长整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 长整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 长整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarT<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, &@<值变量>, @<最小值>,
        @                             @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 角度滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个滑块条,可以在指定的的范围内拖动更改一个单精度小数角度的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小角度 <类型 = 单精度小数 注释 = "滑块位于最左边时的数值" @默认值 = -360.0>
    参数 最大角度 <类型 = 单精度小数 注释 = "滑块位于最右边时的数值" @默认值 = +360.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.0f°">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderAngle(*PivAny2U{@<标签文本>}, &@<值变量>, @<最小角度>, @<最大角度>,
        @                    u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 单浮点数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个单精度小数数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "单精度小数 []" 注释 = "必须提供单精度小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 单精度小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 单精度小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 小数数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个双精度小数数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "小数 []" 注释 = "必须提供一个小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<double>(*PivAny2U{@<标签文本>}, ImGuiDataType_Double, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>,
        @                               @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 字节数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个字节数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "字节 []" 注释 = "必须提供一个字节基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 字节 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 字节 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>,
        @                             @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 短整数数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个短整数数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "短整数 []" 注释 = "必须提供一个短整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 短整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 短整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 整数数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个整数数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "整数 []" 注释 = "必须提供一个整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<int>(*PivAny2U{@<标签文本>}, ImGuiDataType_S32, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>,
        @                            @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 长整数数组滑块条 <公开 静态 类型 = 逻辑型 注释 = "提供一个长整数数组,在一行内创建跟数组成员数相同数量的滑块,可以在指定的的范围内拖动更改成员值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "长整数 []" 注释 = "必须提供一个长整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 长整数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 长整数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, IM_ARRAY_AND_SIZE(@<数组变量>), @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 ImVec2滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一行两个滑块,可以在指定的的范围内拖动更改ImVec2中两个成员值."
            注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在拖滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数据变量 <类型 = ImVec2 注释 = "必须提供一个ImVec2变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 单精度小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 单精度小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, (float*)@<数据变量>.pdata(), 2, @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 ImVec4滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一行四个滑块,可以在指定的的范围内拖动更改ImVec4中四个成员值."
            注释 = "注: Ctrl+点击拖动框可以切换到手动输入数值." 返回值注释 = "数组变量的值被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数据变量 <类型 = ImVec4 注释 = "必须提供一个ImVec4变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 单精度小数 注释 = "滑块位于最左边时的数值">
    参数 最大值 <类型 = 单精度小数 注释 = "滑块位于最右边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::SliderScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, (float*)@<数据变量>.pdata(), 4, @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 单浮点垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 单精度小数 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 单精度小数 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderFloat(*PivAny2U{@<标签文本>}, @<尺寸>, &@<值变量>, @<最小值>, @<最大值>,
        @                     u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 小数垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 小数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 小数 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 小数 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderScalarT<double>(*PivAny2U{@<标签文本>}, @<尺寸>, ImGuiDataType_Double, &@<值变量>, @<最小值>,
        @                               @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 字节垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个8位字节变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 字节 注释 = "必须提供一个字节变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 字节 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 字节 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderScalarT<char>(*PivAny2U{@<标签文本>}, @<尺寸>, ImGuiDataType_S8, &@<值变量>, @<最小值>,
        @                             @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 短整数垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个16位短整数变量的值."
            注释 = "注: Ctrl+点击滑块可以切换到手动输入数值." 返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 短整数 注释 = "必须提供一个短整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 短整数 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 短整数 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderScalarT<short>(*PivAny2U{@<标签文本>}, @<尺寸>, ImGuiDataType_S16, &@<值变量>, @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 整数垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 整数 注释 = "必须提供一个整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 整数 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 整数 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderInt(*PivAny2U{@<标签文本>}, @<尺寸>, &@<值变量>, @<最小值>, @<最大值>,
        @                   u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    方法 长整数垂直滑块条 <公开 静态 类型 = 逻辑型 注释 = "创建一个垂直滑块条,可以在指定的的范围内拖动更改一个32位整数变量的值." 注释 = "注: Ctrl+点击滑块可以切换到手动输入数值."
            返回值注释 = "值变量被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在滑块旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供滑块的宽度和高度">
    参数 值变量 <类型 = 长整数 注释 = "必须提供一个长整数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 最小值 <类型 = 长整数 注释 = "滑块位于最上边时的数值">
    参数 最大值 <类型 = 长整数 注释 = "滑块位于最下边时的数值">
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 滑块标志 <类型 = 整数 注释 = "请使用\"IM滑块标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM滑块标志.无>
    {
        @ ImGui::VSliderScalarT<INT64>(*PivAny2U{@<标签文本>}, @<尺寸>, ImGuiDataType_S64, &@<值变量>, @<最小值>,
        @                              @<最大值>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiSliderFlags)@<滑块标志>)
    }

    # 组件: 键盘输入  | Widgets: Input with Keyboard

    方法 文本输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个文本输入框,输入的UTF-8编码内容将保存在\"文本内容\"参数中."
            注释 = "注: \"标准文本类U\"封装了大量文本操作功能,若想转换到文本型,可以调用\"到文本型\"." 返回值注释 = "文本内容被更改时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 文本内容 <类型 = 标准文本类U 注释 = "必须提供一个\"标准文本类U\"变量,并确保其生命周期,输入的内容将保存在此变量中." @需求类型 = 可写入变量>
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputText(*PivAny2U{@<标签文本>}, @<文本内容>.pdata(), (ImGuiInputTextFlags)@<输入框标志>, nullptr, nullptr)
    }

    方法 多行文本输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个多行文本输入框,输入的UTF-8编码内容将保存在\"文本内容\"参数中."
            注释 = "注: \"标准文本类U\"封装了大量文本操作功能,若想转换到文本型,可以调用\"到文本型\"." 返回值注释 = "文本内容被更改时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 文本内容 <类型 = 标准文本类U 注释 = "必须提供一个\"标准文本类U\"变量,并确保其生命周期,输入的内容将保存在此变量中." @需求类型 = 可写入变量>
    参数 尺寸 <类型 = ImVec2 注释 = "提供输入框的尺寸" @默认值 = 空对象>
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputTextMultiline(*PivAny2U{@<标签文本>}, @<文本内容>.pdata(), @<尺寸>, (ImGuiInputTextFlags)@<输入框标志>, nullptr, nullptr)
    }

    方法 提示输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个文本输入框,未输入内容时将以灰色显示提示文本,输入的UTF-8编码内容将保存在\"文本内容\"参数中."
            注释 = "注: \"标准文本类U\"封装了大量文本操作功能,若想转换到文本型,可以调用\"到文本型\"." 返回值注释 = "文本内容被更改时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 提示文本 <注释 = "如果输入框未输入任何内容,则显示本提示内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型." @匹配类型 = 通用型>
    参数 文本内容 <类型 = 标准文本类U 注释 = "必须提供一个\"标准文本类U\"变量,并确保其生命周期,输入的内容将保存在此变量中." @需求类型 = 可写入变量>
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputTextWithHint(*PivAny2U{@<标签文本>}, *PivAny2U{@<提示文本>}, @<文本内容>.pdata(), (ImGuiInputTextFlags)@<输入框标志>, nullptr, nullptr)
    }

    方法 单浮点输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入单精度小数值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 单精度小数 注释 = "必须提供单精度小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 单精度小数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0.0>
    参数 快速增减量 <类型 = 单精度小数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputFloat(*PivAny2U{@<标签文本>}, &@<值变量>, @<增减量>, @<快速增减量>,
        @                   u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    方法 小数输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入双精度小数值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 小数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 小数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0.0>
    参数 快速增减量 <类型 = 小数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputDouble(*PivAny2U{@<标签文本>}, &@<值变量>, @<增减量>, @<快速增减量>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    方法 字节输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入8位字节值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 字节 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 字节 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarT<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, &@<值变量>, @<增减量>, @<快速增减量>,
        @                           u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    方法 短整数输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入16位短整数值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 整数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarT<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, &@<值变量>, @<增减量>, @<快速增减量>,
        @                            u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    方法 整数输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入32位整数值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 整数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." 注释 = "输入十六进制文本时请使用\"%08X\""
            @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputInt(*PivAny2U{@<标签文本>}, &@<值变量>, @<增减量>, @<快速增减量>, u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    方法 长整数输入框 <公开 静态 类型 = 逻辑型 注释 = "创建一个输入框,用于输入62位长整数值,可选添加两个增加按钮." 返回值注释 = "值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 值变量 <类型 = 长整数 注释 = "必须提供一个小数变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 长整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 长整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarT<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, &@<值变量>, @<增减量>, @<快速增减量>,
        @                            u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    方法 单浮点数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个单精度小数数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "单精度小数 []" 注释 = "必须提供单精度小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 单精度小数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0.0>
    参数 快速增减量 <类型 = 单精度小数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.3f">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<float>(*PivAny2U{@<标签文本>}, ImGuiDataType_Float, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                             u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    方法 小数数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个双精度小数数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "小数 []" 注释 = "必须提供一个小数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 小数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0.0>
    参数 快速增减量 <类型 = 小数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0.0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%.6f">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<double>(*PivAny2U{@<标签文本>}, ImGuiDataType_Double, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                              u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    方法 字节数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个字节数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "字节 []" 注释 = "必须提供一个字节基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 字节 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 字节 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<char>(*PivAny2U{@<标签文本>}, ImGuiDataType_S8, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                            u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    方法 短整数数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个短整数数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "短整数 []" 注释 = "必须提供一个短整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 短整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 短整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<short>(*PivAny2U{@<标签文本>}, ImGuiDataType_S16, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                             u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    方法 整数数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个整数数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "整数 []" 注释 = "必须提供一个整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<int>(*PivAny2U{@<标签文本>}, ImGuiDataType_S32, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                           u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    方法 长整数数组输入框 <公开 静态 类型 = 逻辑型 注释 = "提供一个长整数数组,在一行内创建跟数组成员数相同数量的输入框." 返回值注释 = "成员值被改变时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在输入框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 数组变量 <类型 = "长整数 []" 注释 = "必须提供一个长整数基本数组变量,而且要确保数组的生命周期." @需求类型 = 可写入变量>
    参数 增减量 <类型 = 长整数 注释 = "如果大于0,会在输入框显示\"-/+\"两个按钮,每单击一次就会增加或减少本参数的值." @默认值 = 0>
    参数 快速增减量 <类型 = 长整数 注释 = "Ctrl+单击\"-/+\"按钮时的增减值." @默认值 = 0>
    参数 显示格式 <类型 = 文本型 注释 = "数值在界面中的显示格式(请参考\"取格式文本\"),本参数不能提供变量,只能填立即数和常量." @需求类型 = 立即数或常量 @默认值 = "%I64d">
    参数 输入框标志 <类型 = 整数 注释 = "请使用\"IM输入框标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM输入框标志.无>
    {
        @ ImGui::InputScalarTN<INT64>(*PivAny2U{@<标签文本>}, ImGuiDataType_S64, IM_ARRAY_AND_SIZE(@<数组变量>), @<增减量>, @<快速增减量>,
        @                             u8@sn<quot>@pvpt<显示格式>@sn<quot>, (ImGuiInputTextFlags)@<输入框标志>)
    }

    # 组件: 颜色编辑器/拾色器 | Widgets: Color Editor/Picker

    方法 颜色编辑器RGB <公开 静态 类型 = 逻辑型 注释 = "创建一个颜色编辑框,可以设置RGB颜色."
            注释 = "注: 本方法采用ImVec4来表示颜色,内含4个单精度小数,每个值的有效范围是(0.0-1.0),对应0-255的色值." 返回值注释 = "颜色被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在颜色编辑器旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 颜色 <类型 = ImVec4 注释 = "必须提供一个变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM颜色编辑标志.无>
    {
        @ ImGui::ColorEdit3(*PivAny2U{@<标签文本>}, (float*)@<颜色>.pdata(), (ImGuiColorEditFlags)@<颜色编辑标志>)
    }

    方法 颜色编辑器RGBA <公开 静态 类型 = 逻辑型 注释 = "创建一个颜色编辑框,可以设置RGBA颜色."
            注释 = "注: 本方法采用ImVec4来表示颜色,内含4个单精度小数,每个值的有效范围是(0.0-1.0),对应0-255的色值." 返回值注释 = "颜色被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在颜色编辑器旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 颜色 <类型 = ImVec4 注释 = "必须提供一个变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM颜色编辑标志.无>
    {
        @ ImGui::ColorEdit4(*PivAny2U{@<标签文本>}, (float*)@<颜色>.pdata(), (ImGuiColorEditFlags)@<颜色编辑标志>)
    }

    方法 颜色选取器RGB <公开 静态 类型 = 逻辑型 注释 = "创建一个颜色选取器,可以选取RGB颜色."
            注释 = "注: 本方法采用ImVec4来表示颜色,内含4个单精度小数,每个值的有效范围是(0.0-1.0),对应0-255的色值." 返回值注释 = "颜色被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在颜色选取器旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 选取颜色 <类型 = ImVec4 注释 = "必须提供一个变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM颜色编辑标志.无>
    {
        @ ImGui::ColorPicker3(*PivAny2U{@<标签文本>}, (float*)@<选取颜色>.pdata(), (ImGuiColorEditFlags)@<颜色编辑标志>)
    }

    方法 颜色选取器RGBA <公开 静态 类型 = 逻辑型 注释 = "创建一个颜色选取器,可以选取RGBA颜色."
            注释 = "注: 本方法采用ImVec4来表示颜色,内含4个单精度小数,每个值的有效范围是(0.0-1.0),对应0-255的色值." 返回值注释 = "颜色被更改后返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在颜色选取器旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 选取颜色 <类型 = ImVec4 注释 = "选取的颜色保存在此参数中,必须提供一个变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 参考颜色 <类型 = ImVec4 注释 = "提供一个参考颜色,例如原来的颜色,可以留空." @默认值 = 空对象>
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM颜色编辑标志.无>
    {
        @ ImGui::ColorPicker4(*PivAny2U{@<标签文本>}, (float*)@<选取颜色>.pdata(), (ImGuiColorEditFlags)@<颜色编辑标志>, (float*)@<参考颜色>.GetPtr())
    }

    方法 色板按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个色板按钮,鼠标在按钮上悬停时会显示颜色的详细信息."
            注释 = "注: 本方法采用ImVec4来表示颜色,内含4个单精度小数,每个值的有效范围是(0.0-1.0),对应0-255的色值." 返回值注释 = "按钮被单击后返回真" @嵌入式方法 = "">
    参数 描述文本 <注释 = "提供色板的描述文本,会显示在悬停提示框中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 颜色 <类型 = ImVec4 注释 = "选取的颜色保存在此参数中,必须提供一个变量,而且要确保变量的生命周期." @需求类型 = 可写入变量>
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM颜色编辑标志.无>
    参数 尺寸 <类型 = ImVec2 注释 = "提供按钮的尺寸,留空使用默认尺寸." @默认值 = 空对象>
    {
        @ ImGui::ColorButton(*PivAny2U{@<描述文本>}, @<颜色>, (ImGuiColorEditFlags)@<颜色编辑标志>, @<尺寸>)
    }

    方法 置颜色编辑选项 <公开 静态 注释 = "如果你想自定义默认格式和选取类型,请在新建帧之前初始化当前选项." 折叠 @嵌入式方法 = "">
    参数 颜色编辑标志 <类型 = 整数 注释 = "请使用\"IM颜色编辑标志\"中的常量,可以使用\"连续位或\"组合多个标志.">
    {
        @ ImGui::SetColorEditOptions((ImGuiColorEditFlags)@<颜色编辑标志>)
    }

    # 组件: 树结构 | Widgets: Trees

    方法 创建树节点 <公开 静态 注释 = "创建一个可以展开和折叠的树节点,可以在子语句体内添加组件." 注释 = "树节点被折叠时不执行子语句体中的代码." 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::TreePop();\\r\\n}\"">
    参数 标签文本 <注释 = "提供显示在树节点上的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 树节点标志 <类型 = 整数 注释 = "请使用\"IM树节点标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM树节点标志.无>
    {
        @ if (ImGui::TreeNodeEx(*PivAny2U{@<标签文本>}, (ImGuiTreeNodeFlags)@<树节点标志>) == true)
    }

    方法 创建树节点Ex <公开 静态 注释 = "创建一个可以展开和折叠的树节点,可以在子语句体内添加组件." 注释 = "树节点被折叠时不执行子语句体中的代码." 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::TreePop();\\r\\n}\"">
    参数 文本ID <注释 = "提供组件的唯一文本ID,本ID不会显示在组件标签中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 树节点标志 <类型 = 整数 注释 = "请使用\"IM树节点标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM树节点标志.无>
    参数 格式文本 <注释 = "提供显示在树节点标签中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ if (ImGui::TreeNodeEx(*PivAny2U{@<文本ID>}, (ImGuiTreeNodeFlags)@<树节点标志>, *PivAny2U{@<格式文本>}, @<替换数据>) == true)
    }

    方法 取树节点和标签间距 <公开 静态 类型 = 单精度小数 注释 = "获取\"树节点/项目符号\"和标签之间的距离" @嵌入式方法 = "">
    {
        @ ImGui::GetTreeNodeToLabelSpacing()
    }

    方法 可折叠标题 <公开 静态 类型 = 逻辑型 注释 = "创建一个可折叠的标题,鼠标经过会有高亮显示." 返回值注释 = "当标题被展开时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在折叠式标题上的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非空将在标题右边显示一个关闭按钮,单击按钮会删掉本标题并将本参数的逻辑值设置为假." @默认值 = 空对象>
    参数 树节点标志 <类型 = 整数 注释 = "请使用\"IM树节点标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM树节点标志.无>
    {
        @ ImGui::CollapsingHeader(*PivAny2U{@<标签文本>}, (bool*)piv::GetBaseDataPtr(@<打开状态>), (ImGuiTreeNodeFlags)@<树节点标志>)
    }

    方法 置下一项目展开 <公开 静态 注释 = "设置下一个\"树节点/可折叠标题\"的展开/折叠状态." 折叠 @嵌入式方法 = "">
    参数 是否展开 <类型 = 逻辑型 注释 = "真为展开,假为折叠">
    参数 执行条件 <类型 = IM执行条件 注释 = "设置本方法的执行条件" @默认值 = IM执行条件.无>
    {
        @ ImGui::SetNextItemOpen((bool)@<是否展开>, (ImGuiCond)@<执行条件>)
    }

    # 组件: 可选项 | Widgets: Selectables

    方法 可选项 <公开 静态 类型 = 逻辑型 注释 = "创建一个可选择的项目(悬停时会高亮显示,选中后会变成另一种颜色)." 注释 = "本方法创建的选项,单击后不能切换选中状态,需要另外写代码实现."
            返回值注释 = "项目被单击时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供可选项的文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 是否选中 <类型 = 逻辑型 注释 = "指定当前是否被选中" @默认值 = 假>
    参数 可选项标志 <类型 = 整数 注释 = "请使用\"IM可选项标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM可选项标志.无>
    参数 尺寸 <类型 = ImVec2 注释 = "x等于0.0：使用剩余宽度,x大于0.0：使用指定宽度;" 注释 = "y等于0.0: 使用标签文本高度,y大于0.0: 使用指定高度;"
            @默认值 = 空对象>
    {
        @ ImGui::Selectable(*PivAny2U{@<标签文本>}, (bool)@<是否选中>, (ImGuiSelectableFlags)@<可选项标志>, @<尺寸>)
    }

    方法 可选项Ex <公开 静态 类型 = 逻辑型 注释 = "创建一个可选择的项目(悬停时会高亮显示,选中后会变成另一种颜色)." 注释 = "本方法创建的选项,单击后可以自动切换选中状态."
            返回值注释 = "项目被单击时返回真" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供可选项的文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 是否选中 <类型 = 逻辑型 注释 = "必须提供一个逻辑型变量,并确保它的生命周期." @需求类型 = 可写入变量>
    参数 可选项标志 <类型 = 整数 注释 = "请使用\"IM可选项标志\"中的常量,可以使用\"连续位或\"组合多个标志." @默认值 = IM可选项标志.无>
    参数 尺寸 <类型 = ImVec2 注释 = "x等于0.0：使用剩余宽度,x大于0.0：使用指定宽度;" 注释 = "y等于0.0: 使用标签文本高度,y大于0.0: 使用指定高度;"
            @默认值 = 空对象>
    {
        @ ImGui::Selectable(*PivAny2U{@<标签文本>}, (bool*)&@<是否选中>, (ImGuiSelectableFlags)@<可选项标志>, @<尺寸>)
    }

    # 组件: 列表框 | Widgets: List Boxes

    方法 创建列表框 <公开 静态 注释 = "创建一个列表框,可以在子语句体中使用\"可选项\"自定义内容." 注释 = "创建失败将不执行子语句体中的代码." 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndListBox();\\r\\n}\"">
    参数 标签文本 <注释 = "提供显示在列表框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 尺寸 <类型 = ImVec2 注释 = "提供列表框的尺寸" @默认值 = 空对象>
    {
        @ if (ImGui::BeginListBox(*PivAny2U{@<标签文本>}, @<尺寸>) == true)
    }

    方法 列表框 <公开 静态 类型 = 逻辑型 注释 = "创建一个列表框组件" 返回值注释 = "返回是否创建成功" @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供显示在组合框旁边的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 现行选中项 <类型 = 整数 注释 = "必须提供一个整数变量(必须确保其生命周期),用于返回当前选中的项目." 注释 = "如果值是\"项目数组\"的有效索引,则自动选中对应的项目."
            注释 = "变量值为-1或大于\"项目数组\"的成员数则不选中任何项目." @需求类型 = 可写入变量>
    参数 项目数组 <类型 = IM文本数组类 注释 = "提供所创建列表框的项目文本数组">
    参数 列表框高度 <类型 = 整数 注释 = "提供列表框的高度,以项目数量为单位." 注释 = "比如8指的是8个项目的高度,实际项目数超过本值将显示滚动条." @默认值 = -1>
    {
        @ ImGui::ListBox(*PivAny2U{@<标签文本>}, &@<现行选中项>, &@dt<IM文本数组类>::ItemGetter, IM_STRARRAY_PTR_AND_SIZE(@<项目数组>.pdata()), @<列表框高度>)
    }

    # 组件: 菜单 | Widgets: Menus

    方法 创建主菜单栏 <公开 静态 注释 = "在整个窗口框架上创建和添加菜单栏." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"MainMenuBar\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndMainMenuBar();\\r\\n}\"">
    {
        @ if (ImGui::BeginMainMenuBar() == true)
    }

    方法 创建菜单栏 <公开 静态 注释 = "在当前ImGui窗口上添加一个菜单栏,窗口必须设置了\"IM窗口标志.菜单栏\"才会显示菜单栏." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"MenuBar\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndMenuBar();\\r\\n}\"">
    {
        @ if (ImGui::BeginMenuBar() == true)
    }

    方法 创建菜单 <公开 静态 注释 = "但菜单栏中创建一个子菜单,可以在子语句体中添加\"菜单项\"." 注释 = "注: 子菜单被打开时才执行子语体中的代码." 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndMenu();\\r\\n}\"\r\nparent = \"MainMenuBar, MenuBar\"">
    参数 标签文本 <注释 = "提供子菜单的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 是否启用 <类型 = 逻辑型 注释 = "设置当前的子菜单是否可用" @默认值 = 真>
    {
        @ if (ImGui::BeginMenu(*PivAny2U{@<标签文本>}, (bool)@<是否启用>) == true)
    }

    方法 菜单项 <公开 静态 类型 = 逻辑型 注释 = "在菜单中创建一个菜单项,参数中的快捷键仅用于显示,本方法不会实现对应的快捷键功能." 返回值注释 = "菜单项被单击时返回真"
            隐藏值属性 = "0" @嵌入式方法 = "parent = \"MainMenuBar, MenuBar\"">
    参数 标签文本 <注释 = "提供菜单项的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 快捷键 <注释 = "提供菜单项的快捷键(仅作显示),留空时不显示快捷键;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 是否选中 <类型 = 逻辑型 注释 = "设置当前的菜单项是否为选中状态" @默认值 = 假>
    参数 是否启用 <类型 = 逻辑型 注释 = "设置当前的菜单项是否可用" @默认值 = 真>
    {
        @ ImGui::MenuItem(*PivAny2U{@<标签文本>}, PivAny2U{@<快捷键>}.GetPtr(), (bool)@<是否选中>, (bool)@<是否启用>)
    }

    方法 菜单项Ex <公开 静态 类型 = 逻辑型 注释 = "在菜单中创建一个菜单项,参数中的快捷键仅用于显示,本方法不会实现对应的快捷键功能." 返回值注释 = "菜单项被单击时返回真"
            隐藏值属性 = "0" @嵌入式方法 = "parent = \"MainMenuBar, MenuBar\"">
    参数 标签文本 <注释 = "提供菜单项的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 快捷键 <注释 = "提供菜单项的快捷键(仅作显示),留空时不显示快捷键;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 是否选中 <类型 = 逻辑型 注释 = "必须提供一个变量,可以设置和返回当前的菜单项是否为选中状态." @需求类型 = 可写入变量>
    参数 是否启用 <类型 = 逻辑型 注释 = "设置当前的菜单项是否可用" @默认值 = 真>
    {
        @ ImGui::MenuItem(*PivAny2U{@<标签文本>}, PivAny2U{@<快捷键>}.GetPtr(), (bool*)&@<是否选中>, (bool)@<是否启用>)
    }

    # 工具提示 | Tooltips

    方法 创建工具提示 <公开 静态 注释 = "创建一个功能齐全的工具提示窗口,可以在子语句体中使用任意项目." 注释 = "工具提示窗口将跟随鼠标显示,它不会获得焦点." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndTooltip();\\r\\n}\"">
    参数 是否显示 <类型 = 逻辑型 注释 = "设置是否显示工具提示窗口,建议使用\"可有悬停项目\"来判断" @默认值 = 真>
    {
        @ if (@<是否显示> && ImGui::BeginTooltip())
    }

    方法 置工具提示 <公开 静态 注释 = "创建一个仅显示文本的工具提示窗口,通常配合\"可有悬停项目\"使用." 注释 = "工具提示窗口将跟随鼠标显示,它不会获得焦点." @嵌入式方法 = "">
    参数 格式文本 <注释 = "提供显示在工具提示窗口中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::SetTooltip(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 创建项目工具提示 <公开 静态 注释 = "创建一个功能齐全的工具提示窗口,可以在子语句体中使用任意项目." 注释 = "跟\"创建工具提示\"不同,只要有项目悬停它就会自动弹出." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndTooltip();\\r\\n}\"">
    {
        @ if (ImGui::BeginItemTooltip())
    }

    方法 置项目工具提示 <公开 静态 注释 = "创建一个仅显示文本的工具提示窗口,只要有项目悬停它就会自动弹出." 注释 = "工具提示窗口将跟随鼠标显示,它不会获得焦点." @嵌入式方法 = "">
    参数 格式文本 <注释 = "提供显示在工具提示窗口中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::SetItemTooltip(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    方法 提示文本框 <公开 静态 注释 = "创建一个文本框,鼠标悬停时可以弹出工具提示窗口." @嵌入式方法 = "">
    参数 标签文本 <注释 = "提供标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 帮助文本 <注释 = "提供帮助的文本内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    {
        @ ImGui::TextTooltip(*PivAny2U{@<标签文本>}, *PivAny2U{@<帮助文本>})
    }

    # 弹出项目,模态 | Popups, Modals

    方法 创建弹出菜单 <公开 静态 注释 = "创建一个弹出菜单,被打开时才会执行子语句体中的代码,子语体中可以调用\"关闭当前弹出项\"." 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"Popup\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndPopup();\\r\\n}\"">
    参数 文本ID <注释 = "设置弹出项的唯一文本ID,本ID不会显示在弹出项中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 窗口标志 <类型 = 整数 注释 = "本标志会转发给当前窗口;" 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ if (ImGui::BeginPopup(*PivAny2U{@<文本ID>}, (ImGuiWindowFlags)@<窗口标志>) == true)
    }

    方法 创建弹出模态窗口 <公开 静态 注释 = "创建一个弹出模态窗口,被打开时才会执行子语句体中的代码,子语体中可以调用\"关闭当前弹出项\"." 注释 = "注: 点击其他位置不会自动关闭模态窗口"
            隐藏值属性 = "0"
            @嵌入式方法 = "name = \"PopupModal\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndPopup();\\r\\n}\"">
    参数 名称 <注释 = "设置弹出窗口的标题,同时也是它的唯一文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非空将在模态窗口上显示一个关闭按钮,通过按钮关闭后会将本参数的逻辑值设置为假." @默认值 = 空对象>
    参数 窗口标志 <类型 = 整数 注释 = "本标志会转发给当前窗口;" 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ if (ImGui::BeginPopupModal(*PivAny2U{@<名称>}, (bool*)piv::GetBaseDataPtr(@<打开状态>), (ImGuiWindowFlags)@<窗口标志>) == true)
    }

    方法 弹出 <公开 静态 注释 = "弹出指定文本ID的弹出项,请勿在每一帧调用本方法!" @嵌入式方法 = "">
    参数 文本ID <注释 = "提供所欲打开弹出项的唯一文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.无>
    {
        @ ImGui::OpenPopup(*PivAny2U{@<文本ID>}, (ImGuiPopupFlags)@<弹出标志>)
    }

    方法 单击项目弹出 <公开 静态 注释 = "(右键)单击最后一个项目时,弹出指定文本ID的弹出项." @嵌入式方法 = "">
    参数 文本ID <注释 = "提供所欲打开弹出项的唯一文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.鼠标右键>
    {
        @ ImGui::OpenPopupOnItemClick(*PivAny2U{@<文本ID>}, (ImGuiPopupFlags)@<弹出标志>)
    }

    方法 关闭当前弹出项 <公开 静态 注释 = "手动关闭当前的弹出项,必须在\"创建弹出菜单/创建弹出模态窗口/单击××弹出菜单\"的子语句体中调用." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"Popup, PopupModal\"">
    {
        @ ImGui::CloseCurrentPopup()
    }

    方法 单击项目创建弹出菜单 <公开 静态 注释 = "(右键)单击最后一个项目时,弹出一个上下文菜单,可在子语句体中自定义菜单项." 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndPopup();\\r\\n}\"">
    参数 文本ID <注释 = "设置弹出项的唯一文本ID,本ID不会显示在弹出项中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.鼠标右键>
    {
        @ if (ImGui::BeginPopupContextItem(PivAny2U{@<文本ID>}.GetPtr(), (ImGuiPopupFlags)@<弹出标志>) == true)
    }

    方法 单击窗口创建弹出菜单 <公开 静态 注释 = "(右键)单击当前窗口的任意位置时,弹出一个上下文菜单,可在子语句体中自定义菜单项." 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndPopup();\\r\\n}\"">
    参数 文本ID <注释 = "设置弹出项的唯一文本ID,本ID不会显示在弹出项中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.鼠标右键>
    {
        @ if (ImGui::BeginPopupContextWindow(PivAny2U{@<文本ID>}.GetPtr(), (ImGuiPopupFlags)@<弹出标志>) == true)
    }

    方法 单击背景创建弹出菜单 <公开 静态 注释 = "(右键)单击背景(没有窗口的区域)的任意位置时,弹出一个上下文菜单,可在子语句体中自定义菜单项." 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndPopup();\\r\\n}\"">
    参数 文本ID <注释 = "设置弹出项的唯一文本ID,本ID不会显示在弹出项中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.鼠标右键>
    {
        @ if (ImGui::BeginPopupContextVoid(PivAny2U{@<文本ID>}.GetPtr(), (ImGuiPopupFlags)@<弹出标志>) == true)
    }

    方法 是否已弹出 <公开 静态 类型 = 逻辑型 注释 = "返回指定的弹出项是否已经弹出显示,返回结果因标志而异." @嵌入式方法 = "">
    参数 文本ID <注释 = "提供所欲检查的弹出项唯一文本ID;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 弹出标志 <类型 = 整数 注释 = "请参考\"IM弹出标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM弹出标志.鼠标右键>
    {
        @ ImGui::IsPopupOpen(*PivAny2U{@<文本ID>}, (ImGuiPopupFlags)@<弹出标志>)
    }

    # 选项卡栏 | Tab Bars, Tabs

    方法 选项卡栏 <公开 静态 注释 = "创建一个选项卡栏,可以在子语句体中添加选项卡." 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"TabBar\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndTabBar();\\r\\n}\"">
    参数 文本ID <注释 = "设置选项卡栏的唯一文本ID,本ID不会显示在界面中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型 @默认值 = 0>
    参数 标志 <类型 = 整数 注释 = "请参考\"IM选项卡栏标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM选项卡栏标志.无>
    {
        @ if (ImGui::BeginTabBar(*PivAny2U{@<文本ID>}, (ImGuiTabBarFlags)@<标志>) == true)
    }

    方法 选项卡 <公开 静态 注释 = "创建一个选项卡项目,可以在子语句体中添加组件." 注释 = "注: 只有选项卡被选中时才会执行子语句体中的代码." 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"ImGui::EndTabItem();\\r\\n}\"\r\nparent = \"TabBar\"">
    参数 标签文本 <注释 = "提供选项卡项目的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 打开状态 <类型 = 逻辑型类 注释 = "本参数非空将在选项卡项标题右边显示一个关闭按钮,单击按钮会关闭选项卡并将本参数的逻辑值设置为假." @默认值 = 空对象>
    参数 标志 <类型 = 整数 注释 = "请参考\"IM选项卡项标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM选项卡项标志.无>
    {
        @ if (ImGui::BeginTabItem(*PivAny2U{@<标签文本>}, (bool*)piv::GetBaseDataPtr(@<打开状态>), (ImGuiTabItemFlags)@<标志>) == true)
    }

    方法 选项卡按钮 <公开 静态 类型 = 逻辑型 注释 = "创建一个行为类似按钮的选项卡项目,本项目不能在选项卡栏中切换选择." 返回值注释 = "按钮被单击时返回真" 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"TabBar\"">
    参数 标签文本 <注释 = "提供选项卡按钮的标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 标志 <类型 = 整数 注释 = "请参考\"IM选项卡项标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM选项卡项标志.无>
    {
        @ ImGui::TabItemButton(PivAny2U{@<标签文本>}.GetPtr(), (ImGuiTabItemFlags)@<标志>)
    }

    方法 置选项卡关闭 <公开 静态 注释 = "通知指定的选项卡已关闭" @嵌入式方法 = "">
    参数 标签文本 <注释 = "所欲关闭的选项卡标签;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    {
        @ ImGui::SetTabItemClosed(*PivAny2U{@<标签文本>})
    }

    # 停靠 | Docking

    方法 停靠空间 <公开 静态 类型 = 整数 注释 = "创建一个停靠空间"
            注释 = "create an explicit dock node _within_ an existing window. See Docking demo for details." 折叠
            @嵌入式方法 = "">
    参数 ID <类型 = 整数>
    参数 尺寸 <类型 = ImVec2 @默认值 = 空对象>
    参数 标志 <类型 = 整数 @默认值 = IM停靠节点标志.无>
    参数 窗口类 <类型 = IM窗口类 @默认值 = 空对象>
    {
        @ (INT)ImGui::DockSpace((ImGuiID)@<ID>, @<尺寸>, (ImGuiDockNodeFlags)@<标志>, @<窗口类>.GetPtr())
    }

    方法 覆盖视口的停靠空间 <公开 静态 类型 = 整数 注释 = "创建一个覆盖屏幕或特定视口的显式停靠节点。" 折叠 @嵌入式方法 = "">
    参数 视口 <类型 = IM视口类 @默认值 = 空对象>
    参数 标志 <类型 = 整数 @默认值 = IM停靠节点标志.无>
    参数 窗口类 <类型 = IM窗口类 @默认值 = 空对象>
    {
        @ (INT)ImGui::DockSpaceOverViewport(@<视口>.GetPtr(), (ImGuiDockNodeFlags)@<标志>, @<窗口类>.GetPtr())
    }

    方法 置下一窗口停靠ID <公开 静态 折叠 @嵌入式方法 = "">
    参数 停靠ID <类型 = 整数 "">
    参数 执行条件 <类型 = IM执行条件 @默认值 = IM执行条件.无>
    {
        @ ImGui::SetNextWindowDockID((ImGuiID)@<停靠ID>, (ImGuiCond)@<执行条件>)
    }

    方法 置下一窗口类 <公开 静态 注释 = "set next window class (control docking compatibility +"
            注释 = "provide hints to platform backend via custom viewport flags and platform parent/child relationship)"
            @嵌入式方法 = "">
    参数 窗口类 <类型 = IM窗口类 @默认值 = 空对象>
    {
        @ ImGui::SetNextWindowClass(@<窗口类>.GetPtr())
    }

    方法 取窗口停靠ID <公开 静态 类型 = 整数 折叠 @嵌入式方法 = "">
    {
        @ (INT)ImGui::GetWindowDockID()
    }

    方法 窗口是否停靠 <公开 静态 类型 = 逻辑型 注释 = "is current window docked into another window?" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsWindowDocked()
    }

    # 日志记录 | Logging/Capture

    方法 记录到控制台 <公开 静态 注释 = "开始记录日志,之后会记录界面中显示的文本数据,直到执行\"结束记录\"后一并输出到控制台(stdout)." 折叠 @嵌入式方法 = "">
    参数 自动展开深度 <类型 = 整数 @默认值 = -1>
    {
        @ ImGui::LogToTTY(@<自动展开深度>)
    }

    方法 记录到文件 <公开 静态 注释 = "开始记录日志,之后会记录界面中显示的文本数据,直到执行\"结束记录\"后一并输出到指定的文件." 折叠 @嵌入式方法 = "">
    参数 自动展开深度 <类型 = 整数 @默认值 = -1>
    参数 文件名 <类型 = 文本型>
    {
        @ ImGui::LogToFile(@<自动展开深度>, PivW2U{@<文件名>})
    }

    方法 记录到剪贴板 <公开 静态 注释 = "开始记录日志,之后会记录界面中显示的文本数据,直到执行\"结束记录\"后一并输出到剪贴板" 折叠 @嵌入式方法 = "">
    参数 自动展开深度 <类型 = 整数 @默认值 = -1>
    {
        @ ImGui::LogToClipboard(@<自动展开深度>)
    }

    方法 结束记录 <公开 静态 注释 = "结束日志记录并输出数据,前面要执行\"记录到×××\"." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::LogFinish()
    }

    方法 记录文本 <公开 静态 注释 = "将文本数据直接传递到日志(界面上不显示),需要在\"记录到×××\"和\"结束记录\"之间调用." 隐藏值属性 = "0"
            @嵌入式方法 = "req_str_param_text_pointer_u8 = true">
    参数 格式文本 <注释 = "提供显示在文本框中的格式文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" 注释 = "文本格式请参考\"取格式文本()\""
            @匹配类型 = 通用型>
    参数 替换数据 <注释 = "用作给格式文本中的格式替换符提供替换数据,格式替换符的数目和数据类型必须与替换数据保持一致." @匹配类型 = 通用基本型 @可扩展 = "" @默认值 = 0>
    {
        @ ImGui::LogText(*PivAny2U{@<格式文本>}, @<替换数据>)
    }

    # 拖放 | Drag and Drop

    方法 拖放来源 <公开 静态 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"DragDropSource\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndDragDropSource();\\r\\n}\"">
    参数 标志 <类型 = 整数 注释 = "请参考\"IM拖放标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM拖放标志.无>
    {
        @ if (ImGui::BeginDragDropSource((ImGuiDragDropFlags)@<标志>) == true)
    }

    方法 设置拖放负载 <公开 静态 类型 = 逻辑型 注释 = "提供的数据会被ImGui复制保存,接受有效载荷后返回真." 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"DragDropSource\"">
    参数 类型 <注释 = "类型是用户定义的文本,最多32个UTF-8字符,字符\'_\'开头的是ImGui的内部保留类型." 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            @匹配类型 = 通用型>
    参数 数据指针 <类型 = 变整数 注释 = "提供数据指针">
    参数 数据尺寸 <类型 = 变整数 注释 = "提供数据尺寸">
    参数 执行条件 <类型 = IM执行条件 注释 = "提供本方法的执行条件" @默认值 = IM执行条件.无>
    {
        @ ImGui::SetDragDropPayload(*PivAny2U{@<类型>}, (void*)@<数据指针>, (size_t)@<数据尺寸>, (ImGuiCond)@<执行条件>)
    }

    方法 拖放目标 <公开 静态 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"DragDropTarget\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndDragDropTarget();\\r\\n}\"">
    {
        @ if (ImGui::BeginDragDropTarget() == true)
    }

    方法 接收拖放负载 <公开 静态 类型 = IM负载类 注释 = "接收指定类型的负载" 隐藏值属性 = "0" @嵌入式方法 = "parent = \"DragDropTarget\"">
    参数 类型 <注释 = "类型是用户定义的文本,最多32个UTF-8字符,字符\'_\'开头的是ImGui的内部保留类型." 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            @匹配类型 = 通用型>
    参数 标志 <类型 = 整数 注释 = "请参考\"IM拖放标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM拖放标志.无>
    {
        @ @dt<IM负载类>{ImGui::AcceptDragDropPayload(*PivAny2U{@<类型>},  (ImGuiDragDropFlags)@<标志>)}
    }

    方法 取拖放负载 <公开 静态 类型 = IM负载类 注释 = "从任何位置直接查看当前有效负载." @嵌入式方法 = "">
    {
        @ @dt<IM负载类>{ImGui::GetDragDropPayload()}
    }

    # 剪切 | Clipping

    方法 剪切矩形 <公开 静态 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::PopClipRect();\"">
    参数 左上剪切矩形 <类型 = ImVec2>
    参数 右下剪切矩形 <类型 = ImVec2>
    参数 与当前剪切矩形交叉 <类型 = 逻辑型>
    {
        @ ImGui::PushClipRect(@<左上剪切矩形>, @<右下剪切矩形>, @<与当前剪切矩形交叉>);
    }

    # 焦点、激活 | Focus, Activation

    方法 置项目为默认焦点 <公开 静态 注释 = "将最后一个项目成为窗口的默认焦点项目." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::SetItemDefaultFocus()
    }

    方法 置键盘焦点 <公开 静态 注释 = "将键盘的输入焦点设置到下一个窗口组件上." 注释 = "使用正\"偏移量\"可以访问窗口组件中的子组件,使用-1可访问上一个窗口组件." 折叠
            @嵌入式方法 = "">
    参数 偏移量 <类型 = 整数 @默认值 = 0>
    {
        @ ImGui::SetKeyboardFocusHere(@<偏移量>)
    }

    # 项目/窗口组件的实用工具和查询功能 | Item/Widgets Utilities and Query Functions

    方法 项目可有悬停 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否有鼠标悬停" 折叠 @嵌入式方法 = "">
    参数 标志 <类型 = 整数 @默认值 = IM悬停标志.无>
    {
        @ ImGui::IsItemHovered((ImGuiHoveredFlags)@<标志>)
    }

    方法 项目是否活动 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否为活动状态.例如按住按钮、编辑文本等." 注释 = "在项目上按住鼠标按钮时会持续返回真,不交互的项目是在返回假." 折叠
            @嵌入式方法 = "">
    {
        @ ImGui::IsItemActive()
    }

    方法 项目可有焦点 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否有键盘或游戏手柄的输入焦点" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemFocused()
    }

    方法 项目被单击 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否已经被鼠标悬停和单击." 折叠 @嵌入式方法 = "">
    参数 鼠标按钮 <类型 = IM鼠标按钮 @默认值 = IM鼠标按钮.左键>
    {
        @ ImGui::IsItemClicked((ImGuiMouseButton)@<鼠标按钮>)
    }

    方法 项目是否可见 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否为可见状态,项目也可能会被剪切或滚动而离开可见范围." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemVisible()
    }

    方法 项目被编辑 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否在当前帧被编辑了值,或被按下." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemEdited()
    }

    方法 项目被激活 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否刚被激活(上一帧为停用状态)." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemActivated()
    }

    方法 项目被停用 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否刚被停用(上一帧为激活状态)." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemDeactivated()
    }

    方法 项目被编辑后停用 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否刚被停用,而且在激活时被修改过值." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemDeactivatedAfterEdit()
    }

    方法 项目被展开 <公开 静态 类型 = 逻辑型 注释 = "返回最后一个项目是否切换到展开状态(树节点)." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsItemToggledOpen()
    }

    方法 可有悬停项目 <公开 静态 类型 = 逻辑型 注释 = "返回是否有任意一个项目有鼠标悬停" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsAnyItemHovered()
    }

    方法 可有活动项目 <公开 静态 类型 = 逻辑型 注释 = "返回是否有任意一个项目为活动状态" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsAnyItemActive()
    }

    方法 可有焦点项目 <公开 静态 类型 = 逻辑型 注释 = "返回是否有任意一个项目有输入焦点" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::IsAnyItemFocused()
    }

    方法 取项目ID <公开 静态 类型 = 整数 注释 = "获取最后一个项目的唯一ID" 折叠 @嵌入式方法 = "">
    {
        @ (INT)ImGui::GetItemID()
    }

    方法 取项目左上矩形 <公开 静态 类型 = ImVec2 注释 = "获取最后一个项目的左上角边界矩形(屏幕空间)" @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetItemRectMin()}
    }

    方法 取项目右下矩形 <公开 静态 类型 = ImVec2 注释 = "获取最后一个项目的右下角边界矩形(屏幕空间)" @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetItemRectMax()}
    }

    方法 取项目尺寸 <公开 静态 类型 = ImVec2 注释 = "获取最后一个项目的尺寸(宽度和高度)" @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetItemRectSize()}
    }

    方法 允许项目重叠 <公开 静态 注释 = "将最后一个项目设置为允许和后面的项目重叠." 注释 = "有时与\"隐身按钮\"、\"可选项\"等配合使用,可以捕获未使用的区域." 折叠
            @嵌入式方法 = "">
    {
        @ ImGui::SetItemAllowOverlap()
    }

    # 视口 | Viewports

    方法 取主视口 <公开 静态 类型 = IM视口类 注释 = "返回主视口" @嵌入式方法 = "">
    {
        @ @dt<IM视口类>{ImGui::GetMainViewport()}
    }

    # 背景/前景绘制列表 | Background/Foreground Draw Lists

    方法 取背景绘制列表 <公开 静态 类型 = IM绘制列表类 注释 = "此为第一个渲染的绘制列表,用于在ImGui内容后面快速绘制形状与文本." @嵌入式方法 = "">
    {
        @ @dt<IM绘制列表类>{ImGui::GetBackgroundDrawList()}
    }

    方法 取前景绘制列表 <公开 静态 类型 = IM绘制列表类 注释 = "此为最后一个渲染的绘制列表,用于在ImGui内容上快速绘制形状与文本." @嵌入式方法 = "">
    {
        @ @dt<IM绘制列表类>{ImGui::GetForegroundDrawList()}
    }

    # 杂项实用工具 | Miscellaneous Utilities

    方法 矩形是否可见 <公开 静态 类型 = 逻辑型 注释 = "检查指定矩形(从光标位置开始的给定大小)是否可见和未被剪切." 折叠 @嵌入式方法 = "">
    参数 尺寸 <类型 = ImVec2>
    {
        @ ImGui::IsRectVisible(@<尺寸>)
    }

    方法 矩形是否可见2 <公开 静态 类型 = 逻辑型 注释 = "检查指定两个矩形(屏幕空间)的范围是否可见和未被剪切." 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    {
        @ ImGui::IsRectVisible(@<左上矩形>, @<右下矩形>)
    }

    方法 取启动时间 <公开 静态 类型 = 小数 注释 = "获取ImGui自启动以来的计时(单位为秒)." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetTime()
    }

    方法 取总帧数 <公开 静态 类型 = 整数 注释 = "获取ImGui自启动以来渲染的总帧数" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetFrameCount()
    }

    方法 "// 取绘制列表共享数据" <公开 静态 类型 = 整数 注释 = "可以在创建自己的绘制列表实例时使用此选项" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::ImDrawListSharedData()
    }

    方法 取样式颜色名 <公开 静态 类型 = 文本视图类U 注释 = "获取与IM颜色标识符(ImGuiCol)枚举值对应的文本(用于显示、保存)." @嵌入式方法 = "">
    参数 颜色标识符 <类型 = IM颜色标识符>
    {
        @ @dt<文本视图类U>{ImGui::GetStyleColorName((ImGuiCol)@<颜色标识符>)}
    }

    方法 创建子框架 <公开 静态 注释 = "在窗口中创建一个看起来和普通组件一样的子窗口或滚动区域." 注释 = "如果子窗口已被折叠或被完全裁剪,则子语句体中的代码不会被执行." 折叠
            隐藏值属性 = "0" @嵌入式方法 = "has_body = true\r\nbody_tail = \"}\\r\\nImGui::EndChildFrame();\"">
    参数 ID值 <类型 = 整数 注释 = "提供自定义的子窗口的ID">
    参数 尺寸 <类型 = ImVec2 注释 = "提供子窗口的尺寸,等于0.0f: 使用剩余的主窗口大小; 大于0.0f: 使用固定大小; 小于0.0f: 使用剩余窗口大小减去绝对大小"
            @默认值 = 空对象>
    参数 窗口标志 <类型 = 整数 注释 = "请参考\"IM窗口标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM窗口标志.无>
    {
        @ if (ImGui::BeginChildFrame((ImGuiID)@<ID值>, @<尺寸>, (ImGuiWindowFlags)@<窗口标志>) == true)
    }

    # 文本实用工具 | Text Utilities

    方法 计算文本尺寸 <公开 静态 类型 = ImVec2 注释 = "计算所提供文本渲染后的尺寸" @嵌入式方法 = "">
    参数 文本内容 <注释 = "所欲计算尺寸的文本" @匹配类型 = 通用型>
    参数 隐藏两个井号后面 <类型 = 逻辑型 注释 = "隐藏两个井号后面的文本" @默认值 = 假>
    参数 换行宽度 <类型 = 小数 注释 = "小于0时表示不换行." @默认值 = -1.0>
    {
        @ @dt<ImVec2>{ImGui::CalcTextSize(*PivAny2U{@<文本内容>}, nullptr, (bool)@<隐藏两个井号后面>, @<换行宽度>)}
    }

    # 颜色实用工具 | Color Utilities

    方法 颜色值到ImVec4 <公开 静态 类型 = ImVec4 注释 = "将32位RGB颜色值转换到ImVec4类型" 折叠 @嵌入式方法 = "">
    参数 颜色值 <类型 = 整数 注释 = "32位RGB颜色值">
    {
        @ @dt<ImVec4>{ImGui::ColorConvertU32ToFloat4((ImU32)@<颜色值>)}
    }

    方法 ImVec4到颜色值 <公开 静态 类型 = 整数 注释 = "将ImVec4类型的RGB颜色值转换到32位整数" 折叠 @嵌入式方法 = "">
    参数 颜色 <类型 = ImVec4>
    {
        @ (INT)ImGui::ColorConvertFloat4ToU32(@<颜色>)
    }

    方法 RGB到HSV <公开 静态 注释 = "将RGB颜色值转换到HSV" 折叠 @嵌入式方法 = "">
    参数 R <类型 = 单精度小数 注释 = "所欲转换的红色分量">
    参数 G <类型 = 单精度小数 注释 = "所欲转换的绿色分量">
    参数 B <类型 = 单精度小数 注释 = "所欲转换的蓝色分量">
    参数 H <类型 = 单精度小数 注释 = "返回转换结果色相" @需求类型 = 可写入变量>
    参数 S <类型 = 单精度小数 注释 = "返回转换结果饱和度" @需求类型 = 可写入变量>
    参数 V <类型 = 单精度小数 注释 = "返回转换结果明度" @需求类型 = 可写入变量>
    {
        @ ImGui::ColorConvertRGBtoHSV(@<R>, @<G>, @<B>, &@<H>, &@<S>, &@<V>)
    }

    方法 HSV到RGB <公开 静态 注释 = "将HSV颜色值转换到RGB" 折叠 @嵌入式方法 = "">
    参数 H <类型 = 单精度小数 注释 = "所欲转换的色相">
    参数 S <类型 = 单精度小数 注释 = "所欲转换的饱和度">
    参数 V <类型 = 单精度小数 注释 = "所欲转换的明度">
    参数 R <类型 = 单精度小数 注释 = "返回转换结果红色分量" @需求类型 = 可写入变量>
    参数 G <类型 = 单精度小数 注释 = "返回转换结果绿色分量" @需求类型 = 可写入变量>
    参数 B <类型 = 单精度小数 注释 = "返回转换结果蓝色分量" @需求类型 = 可写入变量>
    {
        @ ImGui::ColorConvertHSVtoRGB(@<H>, @<S>, @<V>, &@<R>, &@<G>, &@<B>)
    }

    # 输入实用工具 | Inputs Utilities: Keyboard/Mouse/Gamepad

    方法 键被按住 <公开 静态 类型 = 逻辑型 注释 = "返回指定的按键是否被持续按住" 折叠 @嵌入式方法 = "">
    参数 按键码 <类型 = IM按键码>
    {
        @ ImGui::IsKeyDown((ImGuiKey)@<按键码>)
    }

    方法 键被按下 <公开 静态 类型 = 逻辑型 注释 = "返回指定的按键是否被按下" 折叠 @嵌入式方法 = "">
    参数 按键码 <类型 = IM按键码>
    参数 重复按键 <类型 = 逻辑型 注释 = "是否为重复按键" @默认值 = 真>
    {
        @ ImGui::IsKeyPressed((ImGuiKey)@<按键码>, (bool)@<重复按键>)
    }

    方法 键被释放 <公开 静态 类型 = 逻辑型 注释 = "返回指定的按键是否被释放" 折叠 @嵌入式方法 = "">
    参数 按键码 <类型 = IM按键码>
    {
        @ ImGui::IsKeyReleased((ImGuiKey)@<按键码>)
    }

    方法 取键按下计数 <公开 静态 类型 = 整数 注释 = "使用提供的重复按键速率和延迟计算出按键的重复计数" @嵌入式方法 = "">
    参数 按键码 <类型 = IM按键码>
    参数 重复延迟 <类型 = 单精度小数>
    参数 重复率 <类型 = 单精度小数>
    {
        @ ImGui::GetKeyPressedAmount((ImGuiKey)@<按键码>, @<重复延迟>, @<重复率>)
    }

    方法 取键名称 <公开 静态 类型 = 文本视图类U 注释 = "返回指定按键码的英文名称" @嵌入式方法 = "">
    参数 按键码 <类型 = IM按键码>
    {
        @ @dt<文本视图类U>{ImGui::GetKeyPressedAmount((ImGuiKey)@<按键码>)}
    }

    方法 置下一帧捕获键盘 <公开 静态 注释 = "强制下一帧捕获键盘" 折叠 @嵌入式方法 = "">
    参数 捕获键盘 <类型 = 逻辑型>
    {
        @ ImGui::SetNextFrameWantCaptureKeyboard((bool)@<捕获键盘>)
    }

    # 输入实用工具: 鼠标 | Inputs Utilities: Mouse specific

    方法 鼠标键被按住 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标键是否被持续按住" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    {
        @ ImGui::IsKeyDown((ImGuiMouseButton)@<按键>)
    }

    方法 鼠标键被单击 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标键是否被按下" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    参数 重复按键 <类型 = 逻辑型 注释 = "是否为重复按键" @默认值 = 真>
    {
        @ ImGui::IsMouseClicked((ImGuiMouseButton)@<按键>, (bool)@<重复按键>)
    }

    方法 鼠标键被释放 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标键是否被释放" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    {
        @ ImGui::IsMouseReleased((ImGuiMouseButton)@<按键>)
    }

    方法 鼠标键被双击 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标键是否被双击" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    {
        @ ImGui::IsMouseDoubleClicked((ImGuiMouseButton)@<按键>)
    }

    方法 取鼠标键单击计数 <公开 静态 类型 = 整数 注释 = "返回发生鼠标键单击后的连续单击次数" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    {
        @ ImGui::GetMouseClickedCount((ImGuiMouseButton)@<按键>)
    }

    方法 矩形可有鼠标悬停 <公开 静态 类型 = 逻辑型 注释 = "返回鼠标是否悬停在给定的边界矩形上" 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 是否剪切 <类型 = 逻辑型>
    {
        @ ImGui::IsMouseHoveringRect(@<左上矩形>, @<右下矩形>, (bool)@<是否剪切>)
    }

    方法 鼠标位置是否有效 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标位置是否有效" 折叠 @嵌入式方法 = "">
    参数 鼠标位置 <类型 = ImVec2 注释 = "留空时为当前的鼠标位置" @默认值 = 空对象>
    {
        @ ImGui::IsMousePosValid(@<鼠标位置>.GetPtr())
    }

    方法 取鼠标位置 <公开 静态 类型 = ImVec2 注释 = "返回当前的鼠标位置" @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetMousePos()}
    }

    方法 取鼠标弹出项位置 <公开 静态 类型 = ImVec2 注释 = "返回鼠标在弹出项中的位置(需要在弹出项的子语体内使用)" @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{ImGui::GetMousePosOnOpeningCurrentPopup()}
    }

    方法 鼠标被拖动 <公开 静态 类型 = 逻辑型 注释 = "返回指定的鼠标键是否正在被拖动" @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    参数 锁定阈值 <类型 = 单精度小数 注释 = "如果鼠标移动超过提供的距离,则判断为正在拖动." 注释 = "小于-1.0f时使用默认的鼠标拖动阈值." @默认值 = -1.0>
    {
        @ ImGui::IsMouseDragging((ImGuiMouseButton)@<按键>, @<锁定阈值>)
    }

    方法 取鼠标拖动增量 <公开 静态 类型 = ImVec2 注释 = "返回从初始单击位置到当前位置的拖动距离增量" @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    参数 锁定阈值 <类型 = 单精度小数 注释 = "如果鼠标移动超过提供的距离,则判断为正在拖动." 注释 = "小于-1.0f时使用默认的鼠标拖动阈值." @默认值 = -1.0>
    {
        @ @dt<ImVec2>{ImGui::GetMouseDragDelta((ImGuiMouseButton)@<按键>, @<锁定阈值>)}
    }

    方法 重置鼠标拖动增量 <公开 静态 注释 = "重置指定鼠标键的拖动增量" 折叠 @嵌入式方法 = "">
    参数 按键 <类型 = IM鼠标按钮>
    {
        @ ImGui::ResetMouseDragDelta((ImGuiMouseButton)@<按键>)
    }

    方法 取鼠标光标 <公开 静态 类型 = IM鼠标光标 注释 = "获取当前所用的光标形状" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::GetMouseCursor()
    }

    方法 置鼠标光标 <公开 静态 注释 = "设置当前所用的光标形状" 折叠 @嵌入式方法 = "">
    参数 鼠标光标 <类型 = IM鼠标光标>
    {
        @ ImGui::SetMouseCursor((ImGuiMouseCursor)@<鼠标光标>)
    }

    方法 置下一帧捕获鼠标 <公开 静态 注释 = "强制下一帧捕获鼠标" 折叠 @嵌入式方法 = "">
    参数 捕获键盘 <类型 = 逻辑型>
    {
        @ ImGui::SetNextFrameWantCaptureMouse((bool)@<捕获键盘>)
    }

    # (Optional) Platform/OS interface for multi-viewport support

    方法 取平台IO <公开 静态 类型 = IM平台IO类 注释 = "platform/renderer functions, for backend to setup + viewports list."
            @嵌入式方法 = "">
    {
        @ @dt<IM平台IO类>{&ImGui::GetPlatformIO()}
    }

    方法 更新平台窗口 <公开 静态 注释 = "call in main loop. will call CreateWindow/ResizeWindow/etc."
            注释 = "platform functions for each secondary viewport, and DestroyWindow for each inactive viewport."
            折叠 @嵌入式方法 = "">
    {
        @ ImGui::UpdatePlatformWindows()
    }

    方法 渲染平台默认窗口 <公开 静态 注释 = "call in main loop."
            注释 = "will call RenderWindow/SwapBuffers platform functions for each"
            注释 = "secondary viewport which doesn\'t have the ImGuiViewportFlags_Minimized flag set."
            注释 = "May be reimplemented by user for custom rendering needs." 折叠 @嵌入式方法 = "">
    参数 平台渲染参数 <类型 = 变整数 @默认值 = 0>
    参数 渲染器参数 <类型 = 变整数 @默认值 = 0>
    {
        @ ImGui::RenderPlatformWindowsDefault((void)@<平台渲染参数>,(void)@<渲染器参数>)
    }

    方法 销毁平台窗口 <公开 静态 注释 = "call DestroyWindow platform functions for all viewports."
            注释 = "call from backend Shutdown() if you need to close platform windows before imgui shutdown."
            注释 = "otherwise will be called by DestroyContext()." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::DestroyPlatformWindows()
    }

    方法 寻找视口_ID <公开 静态 类型 = IM视口类 注释 = "this is a helper for backends." @嵌入式方法 = "">
    参数 视口ID <类型 = 整数>
    {
        @ @dt<IM视口类>{&ImGui::FindViewportByID((ImGuiID)@<视口ID>)}
    }

    方法 寻找视口_平台句柄 <公开 静态 类型 = IM视口类
            注释 = "this is a helper for backends. the type platform_handle is decided by the backend"
            注释 = "(e.g. HWND, MyWindow*, GLFWwindow* etc.)" @嵌入式方法 = "">
    参数 平台句柄 <类型 = 变整数>
    {
        @ @dt<IM视口类>{&ImGui::FindViewportByPlatformHandle((void*)@<平台句柄>)}
    }
}

类 ImGui表格 <公开 注释 = "ImGui的表格组件" 折叠>
{

    # 表格 | Tables

    方法 创建表格 <公开 静态 注释 = "创建一个表格,然后在子语句体中填写数据." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "name = \"Table\"\r\nhas_body = true\r\nbody_tail = \"ImGui::EndTable();\\r\\n}\"">
    参数 文本ID <注释 = "设置表格的唯一文本ID,本ID不会显示在表格中;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 列数 <类型 = 整数 注释 = "提供表格的列数">
    参数 表格标志 <类型 = 整数 注释 = "请参考\"IM表格标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM表格标志.无>
    参数 外边框尺寸 <类型 = ImVec2 @默认值 = 空对象>
    参数 内宽度 <类型 = 单精度小数 @默认值 = 0.0>
    {
        @ if (ImGui::BeginTable(*PivAny2U{@<文本ID>}, @<列数>, (ImGuiTableFlags)@<表格标志>, @<外边框尺寸>, @<内宽度>) == true)
    }

    方法 到下一行 <公开 静态 注释 = "加入到新一行的第一个单元格." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = \"Table\"">
    参数 表格行标志 <类型 = 整数 注释 = "请参考\"IM表格行标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM表格行标志.无>
    参数 最小行高度 <类型 = 单精度小数 @默认值 = 0.0>
    {
        @ ImGui::TableNextRow((ImGuiTableRowFlags)@<表格行标志>, @<最小行高度>)
    }

    方法 到下一列 <公开 静态 类型 = 逻辑型 注释 = "加入到下一列,如果当前为最后一列则加入到下一行的第一列,列为可见状态时返回真." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"Table\"">
    {
        @ ImGui::TableNextColumn()
    }

    方法 到指定列 <公开 静态 类型 = 逻辑型 注释 = "加入到指定列,列为可见状态时返回真." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = \"Table\"">
    参数 列索引 <类型 = 整数>
    {
        @ ImGui::TableSetColumnIndex(@<列索引>)
    }

    方法 置列属性 <公开 静态 注释 = "设置列的首行标题、调整大小策略、默认宽度和权重、唯一元素ID和其他标志."
            注释 = "注: 只能在\"创建表格\"和\"到下一行\"之间调用,并需要根据表格的列数调用多次." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = \"Table\"">
    参数 标签文本 <注释 = "提供显示在表格第一行的列标签文本;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            注释 = "若想多个项目使用同一个标签,请使用\"##\"区分不同的元素ID,比如\"你好##foo1\";"
            注释 = "也可以使用\"###\"将动态更改内容的标签指向一个固定的元素ID,比如\"你好###ID\"." @匹配类型 = 通用型>
    参数 表格行标志 <类型 = 整数 注释 = "请参考\"IM表格行标志\"中的常量和备注,可以用\"连续位或\"组合使用多个标志." @默认值 = IM表格行标志.无>
    参数 初始宽度 <类型 = 单精度小数 注释 = "提供列的初始宽度,单位为像素或权重(依标志而定)" @默认值 = 0.0>
    参数 用户ID <类型 = 整数 注释 = "提供用户自定义的ID值" @默认值 = 0>
    {
        @ ImGui::TableSetupColumn(*PivAny2U{@<标签文本>}, (ImGuiTableRowFlags)@<表格行标志>, @<初始宽度>, (ImGuiID)@<用户ID>)
    }

    方法 冻结窗格 <公开 静态 注释 = "锁定指定数量的列和行,使它们在表格滚动时始终可见." 注释 = "注: 只能在\"置列属性\"和\"到下一行\"之间调用." 折叠 隐藏值属性 = "0"
            @嵌入式方法 = "parent = \"Table\"">
    参数 列数 <类型 = 整数>
    参数 行数 <类型 = 整数>
    {
        @ ImGui::TableSetupScrollFreeze(@<列数>, @<行数>)
    }

    方法 提交标题行 <公开 静态 注释 = "根据\"置列属性\"的数据提交所有标题行的单元格,以及提交上下文菜单." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = \"Table\"">
    {
        @ ImGui::TableHeadersRow()
    }

    方法 "// 取排序规范" <公开 静态 类型 = ImGuiTableSortSpecs 注释 = "获取表格最后的排序规范(可能为空,表示无排序)."
            注释 = "生命周期: 返回值只能在当前帧使用,如果当前帧后面又调用了\"创建表格\",则请勿再调用本返回值." 折叠 隐藏值属性 = "0" @嵌入式方法 = "parent = \"Table\"">
    {
        @ ImGui::TableGetSortSpecs()
    }

    方法 取列数 <公开 静态 类型 = 整数 注释 = "返回当前表格的列数(\"创建表格\"时提供的值)." 折叠 @嵌入式方法 = "">
    {
        @ ImGui::TableGetColumnCount()
    }

    方法 取列索引 <公开 静态 类型 = 整数 注释 = "返回当前列的索引" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::TableGetColumnIndex()
    }

    方法 取行索引 <公开 静态 类型 = 整数 注释 = "返回当前行的索引" 折叠 @嵌入式方法 = "">
    {
        @ ImGui::TableGetRowIndex()
    }

    方法 取列标题 <公开 静态 类型 = 标准文本类U 注释 = "获取指定列的标题名称,如果未设置\"置列属性\"则返回空文本." 折叠 @嵌入式方法 = "">
    参数 列索引 <类型 = 整数 注释 = "-1表示当前列" @默认值 = -1>
    {
        @ @dt<标准文本类U>{ImGui::TableGetColumnName(@<列索引>)}
    }

    方法 取列标志 <公开 静态 类型 = 整数 注释 = "获取指定列的标志,通过标志可以检测列的可用、可见、排序、悬停等状态." 折叠 @嵌入式方法 = "">
    参数 列索引 <类型 = 整数 注释 = "-1表示当前列" @默认值 = -1>
    {
        @ (INT)ImGui::TableGetColumnFlags(@<列索引>)}
    }

    方法 置列启用 <公开 静态 类型 = 标准文本类U 注释 = "设置指定列是否可以被用户访问,设置为假可隐藏列." 注释 = "用户也可以使用上下文菜单自行更改(在列标题中右键单击)." 折叠
            @嵌入式方法 = "">
    参数 列索引 <类型 = 整数 注释 = "-1表示当前列" @默认值 = -1>
    参数 是否启用 <类型 = 逻辑型 注释 = "是否启用指定的列,假时将隐藏列">
    {
        @ ImGui::TableSetColumnEnabled(@<列索引>, (bool)@<是否启用>)
    }

    方法 置背景颜色 <公开 静态 类型 = 标准文本类U 注释 = "设置指定单元格、行或列的背景颜色" 折叠 @嵌入式方法 = "">
    参数 设置目标 <类型 = IM表格背景目标 注释 = "-1表示当前列">
    参数 颜色值 <类型 = 整数 注释 = "32位颜色值">
    参数 列索引 <类型 = 整数 注释 = "-1表示当前列" @默认值 = -1>
    {
        @ ImGui::TableSetBgColor((ImGuiTableBgTarget)@<设置目标>, (ImU32)@<颜色值>, @<列索引>)
    }
}

类 IM绘制列表类 <公开 基础类 = 结构指针基础类 注释 = "ImDrawList" 折叠>
{

    # @ @m<PIV_DECLARE_STRUCT_PTR> (ImDrawList)

    方法 标志 <公开 属性读 类型 = 整数 注释 = "返回绘制列表标志,为\"IM绘制列表标志\"的组合值." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().Flags
    }

    方法 标志 <公开 属性写 注释 = "设置绘制列表标志,请使用\"IM绘制列表标志\"的位或组合值." 折叠>
    参数 新标志 <类型 = 整数>
    {
        @ data().Flags = (ImDrawListFlags)@<新标志>;
    }

    # 基本图形 | Primitives

    方法 添加直线 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddLine(@<端点1>, @<端点2>, (ImU32)@<颜色>, @<粗细>)
    }

    方法 添加矩形 <公开 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 圆角半径 <类型 = 单精度小数 @默认值 = 0.0>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddRect(@<左上矩形>, @<右下矩形>, (ImU32)@<颜色>, @<圆角半径>, (ImDrawFlags)@<标志>, @<粗细>)
    }

    方法 添加矩形填充 <公开 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 圆角半径 <类型 = 单精度小数 @默认值 = 0.0>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    {
        @ @sn<this>.data().AddRectFilled(@<左上矩形>, @<右下矩形>, (ImU32)@<颜色>, @<圆角半径>, (ImDrawFlags)@<标志>)
    }

    方法 添加多色矩形填充 <公开 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 左上颜色 <类型 = 整数>
    参数 右上颜色 <类型 = 整数>
    参数 右下颜色 <类型 = 整数>
    参数 左下颜色 <类型 = 整数>
    {
        @ @sn<this>.data().AddRectFilled(@<左上矩形>, @<右下矩形>, (ImU32)@<左上颜色>, (ImU32)@<右上颜色>, (ImU32)@<右下颜色>, (ImU32)@<左下颜色>)
    }

    方法 添加四边形 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 端点4 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddQuad(@<端点1>, @<端点2>, @<端点3>, @<端点4>, (ImU32)@<颜色>, @<粗细>)
    }

    方法 添加四边形填充 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 端点4 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    {
        @ @sn<this>.data().AddQuadFilled(@<端点1>, @<端点2>, @<端点3>, @<端点4>, (ImU32)@<颜色>)
    }

    方法 添加三角形 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddTriangle(@<端点1>, @<端点2>, @<端点3>, (ImU32)@<颜色>, @<粗细>)
    }

    方法 添加三角形填充 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    {
        @ @sn<this>.data().AddTriangleFilled(@<端点1>, @<端点2>, @<端点3>, (ImU32)@<颜色>)
    }

    方法 添加圆形 <公开 折叠 @嵌入式方法 = "">
    参数 圆心 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 颜色 <类型 = 整数>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddCircle(@<圆心>, @<半径>, (ImU32)@<颜色>, @<分段数>, @<粗细>)
    }

    方法 添加圆形填充 <公开 折叠 @嵌入式方法 = "">
    参数 圆心 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 颜色 <类型 = 整数>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().AddCircleFilled(@<圆心>, @<半径>, (ImU32)@<颜色>, @<分段数>)
    }

    方法 添加多边形 <公开 折叠 @嵌入式方法 = "">
    参数 中心点 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 颜色 <类型 = 整数>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().AddCircle(@<中心点>, @<半径>, (ImU32)@<颜色>, @<分段数>, @<粗细>)
    }

    方法 添加多边形填充 <公开 折叠 @嵌入式方法 = "">
    参数 中心点 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 颜色 <类型 = 整数>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().AddNgonFilled(@<中心点>, @<半径>, (ImU32)@<颜色>, @<分段数>)
    }

    方法 添加文本 <公开 折叠 @嵌入式方法 = "">
    参数 位置 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 文本内容 <注释 = "所欲添加的文本内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    {
        @ @sn<this>.data().AddText(@<位置>, (ImU32)@<颜色>, *PivAny2U{@<文本内容>}, nullptr)
    }

    方法 添加文本Ex <公开 折叠 @嵌入式方法 = "">
    参数 字体 <类型 = IM字体类>
    参数 字体大小 <类型 = 单精度小数>
    参数 位置 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 文本内容 <注释 = "所欲添加的文本内容;" 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;" @匹配类型 = 通用型>
    参数 换行宽度 <类型 = 单精度小数 @默认值 = 0.0>
    参数 精细剪切矩形 <类型 = ImVec4 注释 = "CPU精细剪切矩形" @默认值 = 空对象>
    {
        @ @sn<this>.data().AddText(@<字体>, @<字体大小>, @<位置>, (ImU32)@<颜色>, *PivAny2U{@<文本内容>}, nullptr, @<换行宽度>, @<精细剪切矩形>.GetPtr())
    }

    方法 添加折线 <公开 折叠>
    参数 端点数组 <类型 = ImVec2数组类>
    参数 颜色 <类型 = 整数>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ data().AddPolyline(@<端点数组>.data().data(), @<端点数组>.data().size(), (ImU32)@<颜色>, (ImDrawFlags)@<标志>, @<粗细>);
    }

    方法 添加凸多边形填充 <公开 折叠>
    参数 端点数组 <类型 = ImVec2数组类>
    参数 颜色 <类型 = 整数>
    {
        @ data().AddConvexPolyFilled(@<端点数组>.data().data(), @<端点数组>.data().size(), (ImU32)@<颜色>);
    }

    方法 添加三次贝塞尔曲线 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 端点4 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().AddBezierCubic(@<端点1>, @<端点2>, @<端点3>, <端点4>, (ImU32)@<颜色>, @<粗细>, @<分段数>)
    }

    方法 添加二次贝塞尔曲线 <公开 折叠 @嵌入式方法 = "">
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 颜色 <类型 = 整数>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().AddBezierQuadratic(@<端点1>, @<端点2>, @<端点3>, (ImU32)@<颜色>, @<粗细>, @<分段数>)
    }

    # 图像基元 | Image primitives

    方法 添加图像 <公开 折叠>
    参数 用户纹理ID <类型 = 变整数>
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 左上纹理坐标 <类型 = ImVec2 注释 = "提供纹理的左上坐标,默认的(0.0, 0.0)表示最左上角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 右下纹理坐标 <类型 = ImVec2 注释 = "提供纹理的右下坐标,默认的(1.0, 1.0)表示最右下角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 颜色 <类型 = 整数 注释 = "默认为白色" @默认值 = 0xFFFFFFFF>
    {
        @ data().AddImage((ImTextureID)@<用户纹理ID>, @<左上矩形>, @<右下矩形>, @<左上纹理坐标>, @<右下纹理坐标>.IsNullObject() ? ImVec2(1, 1) : @<右下纹理坐标>.data(), (ImU32)@<颜色>);
    }

    方法 添加四边形图像 <公开 折叠>
    参数 用户纹理ID <类型 = 变整数>
    参数 端点1 <类型 = ImVec2>
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 端点4 <类型 = ImVec2>
    参数 纹理坐标1 <类型 = ImVec2 注释 = "提供纹理的左上坐标,默认的(0.0, 0.0)表示最左上角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 纹理坐标2 <类型 = ImVec2 注释 = "提供纹理的右下坐标,默认的(1.0, 1.0)表示最右下角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 纹理坐标3 <类型 = ImVec2 @默认值 = 空对象>
    参数 纹理坐标4 <类型 = ImVec2 @默认值 = 空对象>
    参数 颜色 <类型 = 整数 注释 = "默认为白色" @默认值 = 0xFFFFFFFF>
    {
        @ data().AddImageQuad((ImTextureID)@<用户纹理ID>, @<端点1>, @<端点2>, @<端点3>, @<端点4>, @<纹理坐标1>, @<纹理坐标2>.IsNullObject() ? ImVec2(1, 0) : @<纹理坐标2>.data(),
        @                     @<纹理坐标3>.IsNullObject() ? ImVec2(1, 1) : @<纹理坐标3>.data(), @<纹理坐标4>.IsNullObject() ? ImVec2(0, 1) : @<纹理坐标4>.data(), (ImU32)@<颜色>);
    }

    方法 添加圆角矩形图像 <公开 折叠>
    参数 用户纹理ID <类型 = 变整数>
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 左上纹理坐标 <类型 = ImVec2 注释 = "提供纹理的左上坐标,默认的(0.0, 0.0)表示最左上角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 右下纹理坐标 <类型 = ImVec2 注释 = "提供纹理的右下坐标,默认的(1.0, 1.0)表示最右下角,修改该值可以裁剪显示部分图像." @默认值 = 空对象>
    参数 颜色 <类型 = 整数 注释 = "默认为白色" @默认值 = 0xFFFFFFFF>
    参数 圆角半径 <类型 = 单精度小数>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    {
        @ data().AddImage((ImTextureID)@<用户纹理ID>, @<左上矩形>, @<右下矩形>, @<左上纹理坐标>,
        @                 @<右下纹理坐标>.IsNullObject() ? ImVec2(1, 1) : @<右下纹理坐标>.data(), (ImU32)@<颜色>, @<圆角半径>, (ImDrawFlags)@<标志>);
    }

    # Stateful path API, add points then finish with PathFillConvex() or PathStroke()

    方法 清除路径 <公开 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().PathClear()
    }

    方法 连接折线路径 <公开 折叠 @嵌入式方法 = "">
    参数 位置 <类型 = ImVec2>
    {
        @ @sn<this>.data().PathLineTo(@<位置>)
    }

    方法 连接折线路径_去重 <公开 折叠 @嵌入式方法 = "">
    参数 位置 <类型 = ImVec2>
    {
        @ @sn<this>.data().PathLineToMergeDuplicate(@<位置>)
    }

    方法 填充凸多边形路径 <公开 折叠 @嵌入式方法 = "">
    参数 颜色 <类型 = 整数>
    {
        @ @sn<this>.data().PathFillConvex((ImU32)@<颜色>)
    }

    方法 描边路径 <公开 折叠 @嵌入式方法 = "">
    参数 颜色 <类型 = 整数>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    参数 粗细 <类型 = 单精度小数 @默认值 = 1.0>
    {
        @ @sn<this>.data().PathStroke((ImU32)@<颜色>, (ImDrawFlags)@<标志>, @<粗细>)
    }

    方法 连接弧形路径 <公开 折叠 @嵌入式方法 = "">
    参数 圆心 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 a_min <类型 = 单精度小数>
    参数 a_max <类型 = 单精度小数>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().PathArcTo(@<圆心>, @<半径>, @<a_min>, @<a_max>, @<分段数>)
    }

    方法 连接弧形路径_快速 <公开 折叠 @嵌入式方法 = "">
    参数 圆心 <类型 = ImVec2>
    参数 半径 <类型 = 单精度小数>
    参数 a_min_of_12 <类型 = 单精度小数>
    参数 a_max_of_12 <类型 = 单精度小数>
    {
        @ @sn<this>.data().PathArcToFast(@<圆心>, @<半径>, @<a_min_of_12>, @<a_max_of_12>)
    }

    方法 连接三次贝塞尔曲线路径 <公开 折叠 @嵌入式方法 = "">
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 端点4 <类型 = ImVec2>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().PathBezierCubicCurveTo(@<端点2>, @<端点3>, @<端点4>, @<分段数>)
    }

    方法 连接二次贝塞尔曲线路径 <公开 折叠 @嵌入式方法 = "">
    参数 端点2 <类型 = ImVec2>
    参数 端点3 <类型 = ImVec2>
    参数 分段数 <类型 = 整数 @默认值 = 0>
    {
        @ @sn<this>.data().PathBezierQuadraticCurveTo(@<端点2>, @<端点3>, @<分段数>)
    }

    方法 矩形路径 <公开 折叠 @嵌入式方法 = "">
    参数 左上矩形 <类型 = ImVec2>
    参数 右下矩形 <类型 = ImVec2>
    参数 圆角半径 <类型 = 单精度小数 @默认值 = 0.0>
    参数 标志 <类型 = 整数 @默认值 = IM绘制标志.无>
    {
        @ @sn<this>.data().PathRect(@<左上矩形>, @<右下矩形>, @<圆角半径>, (ImDrawFlags)@<标志>)
    }
}

# 辅助类

类 IM颜色类 <公开 注释 = "提供了ImGui中的各种颜色的快捷创建与转换" 折叠 @文档 = "category = \"辅助类\"" @禁止创建对象 = 真>
{
    方法 取颜色值 <公开 静态 类型 = 整数 注释 = "将指定的RGBA颜色分量组合为32位整数颜色值并返回" 折叠 @嵌入式方法 = "">
    参数 红色分量值 <类型 = 整数 注释 = "数值范围从 0 到 255,表示颜色中的红色分量值.">
    参数 绿色分量值 <类型 = 整数 注释 = "数值范围从 0 到 255,表示颜色中的绿色分量值.">
    参数 蓝色分量值 <类型 = 整数 注释 = "数值范围从 0 到 255,表示颜色中的蓝色分量值.">
    参数 透明分量值 <类型 = 整数 注释 = "数值范围从 0 到 255,表示颜色中的透明分量值;" 注释 = "0为完全透明,255为完全不透明." @默认值 = 255>
    {
        @ (CLIP(@<红色分量值>, 0, 255) << 0 ) | (CLIP(@<绿色分量值>, 0, 255) << 8 ) |
        @ (CLIP(@<蓝色分量值>, 0, 255) << 16) | (CLIP(@<透明分量值>, 0, 255) << 24)
    }

    方法 取ImVec4颜色 <公开 静态 类型 = ImVec4 注释 = "使用指定的RGBA颜色分量创建一个ImVec4实例并返回" 折叠 @嵌入式方法 = "">
    参数 红色值 <类型 = 单精度小数 注释 = "数值范围从 0.0 到 1.0,表示颜色中的红色分量值." @默认值 = 0>
    参数 绿色值 <类型 = 单精度小数 注释 = "数值范围从 0.0 到 1.0,表示颜色中的绿色分量值." @默认值 = 0>
    参数 蓝色值 <类型 = 单精度小数 注释 = "数值范围从 0.0 到 1.0,表示颜色中的蓝色分量值." @默认值 = 0>
    参数 透明值 <类型 = 单精度小数 注释 = "数值范围从 0.0 到 1.0,表示颜色中的透明分量值." @默认值 = 0>
    {
        @ @dt<ImVec4>{ImVec4(@<红色值>, @<绿色值>, @<蓝色值>, @<透明值>)}
    }

    方法 RGB到RGBA <公开 静态 类型 = 整数 注释 = "将指定的RGB颜色转换为RGBA颜色值并返回." 注释 = "注: 可用于转换\"颜色类\"中的常量." 折叠 @嵌入式方法 = "">
    参数 RGB颜色值 <类型 = 整数 注释 = "可以提供\"颜色类\"中的常量,或\"取颜色值\"的返回值.">
    参数 透明分量值 <类型 = 整数 注释 = "数值范围从 0 到 255,表示颜色中的透明分量值;" 注释 = "0为完全透明,255为完全不透明." @默认值 = 255>
    {
        @ @<RGB颜色值> | (CLIP(@<透明分量值>, 0, 255) << 24)
    }

    方法 RGBA到RGB <公开 静态 类型 = 整数 注释 = "将指定的RGBA颜色转换为RGB颜色值并返回."
            注释 = "注: 返回的是COLORREF值,不能用于ImGui,但可以给Win32窗口使用." 折叠 @禁止流程检查 = 真>
    参数 RGBA颜色值 <类型 = 整数 注释 = "可以提供\"颜色类\"中的常量,或\"取颜色值\"的返回值.">
    参数 是否应用透明 <类型 = 逻辑型 注释 = "是否将透明度应用到返回的RGB值中,为真时按比例降低RGB各颜色分量;" 注释 = "为假则仅将透明分量值置0后返回." @默认值 = 真>
    {
        @ if (@<是否应用透明>) {
        @     int alpha = (@<RGBA颜色值> >> 24) & 0xFF;
        @     if (alpha != 255) {
        @         float a = alpha / 255.0f;
        @         return ((int)(((@<RGBA颜色值> >> 0) & 0xFF) * a + 0.5f) << 0) | ((int)(((@<RGBA颜色值> >> 8) & 0xFF) * a + 0.5f) << 8) |
        @                 ((int)(((@<RGBA颜色值> >> 16) & 0xFF) * a + 0.5f) << 16);
        @     }
        @ }
        @ return (@<RGBA颜色值> & 0x00FFFFFF);
    }

    方法 颜色值到ImVec4 <公开 静态 类型 = ImVec4 注释 = "将32位整数的RGBA颜色值转换到4个单精度小数" 折叠 @嵌入式方法 = "">
    参数 颜色值 <类型 = 整数 注释 = "32位RGBA颜色值">
    {
        @ @dt<ImVec4>{ImGui::ColorConvertU32ToFloat4((ImU32)@<颜色值>)}
    }

    方法 ImVec4到颜色值 <公开 静态 类型 = 整数 注释 = "将4个单精度小数的RGBA颜色值转换到32位整数" 折叠 @嵌入式方法 = "">
    参数 浮点数颜色 <类型 = ImVec4>
    {
        @ (INT)ImGui::ColorConvertFloat4ToU32(@<浮点数颜色>)
    }
}

类 IM文本数组类 <公开 基础类 = 扩展对象类 注释 = "  成员类型为\"标准文本类U\"的数组类,内部文本编码是UTF-8," 注释 = "加入成员时支持多种文本类型,如有必要会自动转换编码."
        注释 = "  主要供\"组合框\"、\"列表框\"等ImGUI窗口组件使用." 折叠 @文档 = "category = \"辅助类\"" @视窗.外部头文件 = "<vector>">
{
    方法 枚举循环 <公开 注释 = "  启动一个循环来枚举数组的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = counter\r\nhas_loop_body = true">
    {
        @ IM_VECTOR_FOR_FORWARD (@sn<this>)
    }

    方法 逆向枚举循环 <公开 注释 = "  启动一个逆向循环来枚举数组的每一个成员,在循环中可以调" 注释 = "用\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = rcounter\r\nhas_loop_body = true">
    {
        @ IM_VECTOR_FOR_REVERSE (@sn<this>)
    }

    方法 取枚举索引 <公开 类型 = 变整数 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到成员的索引位置."
            注释 = "跟官方库的不一样,即使有多层本类或本类继承类的\"枚举循环\"嵌套,本方法仍能正确返回" 注释 = "枚举到成员的索引位置." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"">
    {
        @ static_cast<INT_P>(@sn<this>.m_index)
    }

    方法 取枚举成员 <公开 类型 = 标准文本类U 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到的成员值."
            注释 = "跟官方库的不一样,即使有多层本类或本类继承类的\"枚举循环\"嵌套,本方法仍能正确" 注释 = "返回枚举成员值." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"" @视窗.返回参考 = 真>
    {
        @ IM_VECTOR_FOR_GET_VALUES (@sn<this>)
    }

    方法 取枚举成员文本 <公开 类型 = 文本型 注释 = "跟\"取枚举成员\"不同,本方法返回的是火山的\"文本型\",会产生编码转换." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"">
    {
        @ IM_VECTOR_FOR_GET_VALUES (@sn<this>).ToVolString()
    }

    方法 索引是否有效 <公开 类型 = 逻辑型 注释 = "返回所指定的索引值是否大于等于0且小于本数组的成员数." 折叠 @禁止流程检查 = 真>
    参数 所欲检查的索引值 <类型 = 变整数>
    {
        @ return static_cast<size_t>(@<所欲检查的索引值>) >= 0 && static_cast<size_t>(@<所欲检查的索引值>) < data().size();
    }

    方法 重置数组 <公开 注释 = "重置数组中的成员数为所指定的数目,数组原有的数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 欲重置的成员数目 <类型 = 整数 注释 = "重置后的数组成员数">
    {
        @ @sn<this>.data().assign(@<欲重置的成员数目>, PivStringU{})
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回本数组是否为空" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<BOOL>(@sn<this>.data().empty())
    }

    方法 删除所有成员 <公开 注释 = "删除数组中的当前所有成员" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().clear()
    }

    方法 删除成员 <公开 注释 = "删除数组中所指定索引范围的单个或多个成员" 折叠>
    参数 删除索引位置 <类型 = 变整数 注释 = "提供所欲删除的索引位置,必须大于等于0且小于等于数组成员数目.">
    参数 结束索引位置 <类型 = 变整数 注释 = "默认为-1, 即只删除单个成员." 注释 = "提供所欲删除的尾成员的索引位置,必须大于\"所欲删除首位置\"且小于等于数组成员数目."
            @默认值 = -1>
    {
        @ auto it = data().begin();
        @ if (@<结束索引位置> != -1){
        @     data().erase(it + static_cast<size_t>(@<删除索引位置>), it + static_cast<size_t>(@<结束索引位置>) + 1);
        @ } else {
        @     data().erase(it + static_cast<size_t>(@<删除索引位置>), it + static_cast<size_t>(@<删除索引位置>) + 1);
        @ }
    }

    方法 取成员数 <公开 类型 = 变整数 注释 = "返回数组中的当前已有成员数目" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.data().size())
    }

    方法 取成员 <公开 类型 = 标准文本类U 注释 = "返回所指定索引位置处的\"标准文本类U\"成员值." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)]
    }

    方法 取成员文本 <公开 类型 = 文本型 注释 = "返回所指定索引位置处的\"文本型\"成员值,会产生编码转换." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠
            @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)].ToVolString()
    }

    方法 置成员值 <公开 注释 = "设置数组中所指定索引位置处的成员文本值,本方法不执行索引检查,索引无效直接崩溃." 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于数组成员数目.">
    参数 所欲设置的文本 <注释 = "提供所欲设置的成员值,先前的值将被覆盖." 注释 = "支持类型(*表示会进行编码转换):" 注释 = "  标准文本类U、文本视图类U"
            注释 = "  *文本型、*标准文本类、*文本视图类" @匹配类型 = 通用型>
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)] = @dt<标准文本类U>{@<所欲设置的文本>}
    }

    方法 加入成员 <公开 注释 = "将一个或多个文本值加入到数组尾部" 折叠 @嵌入式方法 = "">
    参数 所欲加入文本 <注释 = "所欲添加的文本值,支持类型(*表示会进行编码转换):" 注释 = "  标准文本类U、文本视图类U、字节集类(UTF-8)"
            注释 = "  *文本型、*标准文本类、*文本视图类" @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @sn<this>.push_backs(@<所欲加入文本>)
    }

    方法 加入成员2 <公开 注释 = "将一个文本值加入到数组尾部,本方法不会进行编码转换." 折叠 @嵌入式方法 = "">
    参数 所欲加入文本 <类型 = 文本型 注释 = "只支持填入用\"\"包围的字符串字面量或文本常量" @需求类型 = 立即数或常量>
    {
        @ @sn<this>.data().push_back(@dt<标准文本类U>{u8@sn<quot>@pvpt<所欲加入文本>@sn<quot>})
    }

    方法 插入成员 <公开 注释 = "将所指定的文本值插入到所指定的索引位置" 折叠 @嵌入式方法 = "">
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目.">
    参数 所欲插入的文本 <注释 = "所欲添加的文本值,支持类型(*表示会进行编码转换):" 注释 = "  标准文本类U、文本视图类U" 注释 = "  *文本型、*标准文本类、*文本视图类"
            @匹配类型 = 通用型>
    {
        @ data().emplace (data().begin() + static_cast<size_t>(@<插入索引位置>), @dt<标准文本类U>{@<所欲插入的文本>});
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<IM_项目数组类> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举成员 ()))

        }
    }

    # @begin
    # <> <include>
    # #define IM_VECTOR_FOR_FORWARD(cThis) for (cThis.m_index = 0; cThis.m_index < cThis.data().size(); cThis.m_index++)
    # #define IM_VECTOR_FOR_REVERSE(cThis) for (cThis.m_index = cThis.data().size() - 1; cThis.m_index >= 0; cThis.m_index--)
    # #define IM_VECTOR_FOR_GET_VALUES(cThis) cThis.data()[cThis.m_index]
    # size_t m_index;
    # std::vector<PivStringU> m_vecData;
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_vecData = objCopyFrom.m_vecData; }
    # inline @sn<current_class>& operator= (@sn<current_class>&& rhs) { m_vecData = std::move(rhs.m_vecData); return *this; }
    # inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_vecData == objCompare.m_vecData); }
    # inline std::vector<PivStringU> &data () { return m_vecData; }
    # inline std::vector<PivStringU> *pdata () { return &m_vecData; }
    # inline void push_backs(const std::string &s) { m_vecData.push_back(PivStringU{s}); }
    # inline void push_backs(const std::wstring &s) { m_vecData.push_back(PivStringU{s}); }
    # inline void push_backs(const piv::string_view &s) { m_vecData.push_back(PivStringU{s}); }
    # inline void push_backs(const piv::wstring_view &s) { m_vecData.push_back(PivStringU{s}); }
    # template <typename T>
    # inline void push_backs(const T &s) { m_vecData.push_back(PivStringU{s}); }
    # template <typename T, typename... Args>
    # inline void push_backs(const T &s, const Args... args)
    # {
    #     push_backs(s); push_backs(args...);
    # }
    # static bool ItemGetter(void* data, int n, const char** out_str)
    # {
    #     std::vector<PivStringU>* arr = (std::vector<PivStringU>*)data;
    #     *out_str = arr->at(n).data().c_str();
    #     return true;
    # }
    # <> </include>
    # @end
}

类 IM字体类 <公开 基础类 = 数据类型基础类 注释 = "ImFont" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImFont)
}

类 IM字体图集类 <公开 基础类 = 数据类型基础类 注释 = "ImFontAtlas" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImFontAtlas)

    方法 添加默认字体 <公开 类型 = IM字体类 注释 = "添加ImGui的默认字体(ProggyClean.ttf)" 返回值注释 = "返回字体指针" 折叠 @嵌入式方法 = "">
    {
        @ @dt<IM字体类>{@sn<this>.pdata()->AddFontDefault(nullptr)}
    }

    方法 添加字体文件 <公开 类型 = IM字体类 注释 = "从文件中添加字体" 返回值注释 = "返回字体" @嵌入式方法 = "">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲添加的字体文件路径">
    参数 像素大小 <类型 = 单精度小数 注释 = "栅格化字体时的像素大小,每种字体的大小都不一样,请自行测试找到合适的大小.">
    参数 字形范围 <类型 = IM字形范围 注释 = "选择字体的字形范围,范围内的字符将栅格化为图集,如果范围过大将消耗更多的内存." 注释 = "但如果有不在范围内字符,将无法正常显示."
            @默认值 = IM字形范围.中文>
    {
        @ [](ImFontAtlas* fonts, const char* filename) {
        @     return @dt<IM字体类>{fonts->AddFontFromFileTTF(filename, @<像素大小>, nullptr, fonts->@pvpt<字形范围>())};
        @ } (@sn<this>.pdata(), *PivAny2U{@<文件名>})
    }

    方法 添加内存字体 <公开 类型 = IM字体类 注释 = "从内存数据添加字体,添加后请勿自行释放字体的内存数据." 返回值注释 = "返回字体指针" 折叠 @嵌入式方法 = "">
    参数 字体数据地址 <类型 = 变整数 注释 = "提供所欲添加的字体数据地址,字体数据的所有权将自动转移到ImGui内部,由ImGui释放相关内存,所以请勿自行释放.">
    参数 字体数据大小 <类型 = 整数 注释 = "提供所欲添加的字体数据大小">
    参数 像素大小 <类型 = 单精度小数 注释 = "栅格化字体时的像素大小,每种字体的大小都不一样,请自行测试找到合适的大小.">
    参数 字形范围 <类型 = IM字形范围 注释 = "选择字体的字形范围,范围内的字符将栅格化为图集,如果范围过大将消耗更多的内存." 注释 = "但如果有不在范围内字符,将无法正常显示."
            @默认值 = IM字形范围.中文>
    {
        @ [](ImFontAtlas* fonts) {
        @     return @dt<IM字体类>{fonts->AddFontFromMemoryTTF((void*)@<字体数据地址>, @<字体数据大小>, @<像素大小>, nullptr, fonts->@pvpt<字形范围>())};
        @ } (@sn<this>.pdata())
    }

    方法 添加字体文件Ex <公开 类型 = IM字体类 注释 = "从文件中添加字体" 返回值注释 = "返回字体" @嵌入式方法 = "">
    参数 文件名 <类型 = 文本型 注释 = "提供所欲添加的字体文件路径">
    参数 像素大小 <类型 = 单精度小数 注释 = "栅格化字体时的像素大小,每种字体的大小都不一样,请自行测试找到合适的大小.">
    参数 字形范围 <类型 = IM字形范围构建类 注释 = "选择字体的字形范围,范围内的字符将栅格化为图集,如果范围过大将消耗更多的内存." 注释 = "但如果有不在范围内字符,将无法正常显示.">
    {
        @ @dt<IM字体类>{@sn<this>.pdata()->AddFontFromFileTTF(*PivAny2U{@<文件名>}, @<像素大小>, nullptr, @<字形范围>.ranges())}
    }

    方法 添加内存字体Ex <公开 类型 = IM字体类 注释 = "从内存数据添加字体,添加后请勿自行释放字体的内存数据." 返回值注释 = "返回字体指针" 折叠 @嵌入式方法 = "">
    参数 字体数据地址 <类型 = 变整数 注释 = "提供所欲添加的字体数据地址,字体数据的所有权将自动转移到ImGui内部,由ImGui释放相关内存,所以请勿自行释放.">
    参数 字体数据大小 <类型 = 整数 注释 = "提供所欲添加的字体数据大小">
    参数 像素大小 <类型 = 单精度小数 注释 = "栅格化字体时的像素大小,每种字体的大小都不一样,请自行测试找到合适的大小.">
    参数 字形范围 <类型 = IM字形范围构建类 注释 = "选择字体的字形范围,范围内的字符将栅格化为图集,如果范围过大将消耗更多的内存." 注释 = "但如果有不在范围内字符,将无法正常显示.">
    {
        @ @dt<IM字体类>{@sn<this>.pdata()->AddFontFromMemoryTTF((void*)@<字体数据地址>, @<字体数据大小>, @<像素大小>, nullptr, @<字形范围>.ranges())}
    }

    方法 清除输入数据 <公开 注释 = "清除字体的输入数据(所有ImFontConfig结构,包括大小、字体内存数据、字形范围等),即用于生成纹理和字体的所有数据." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->ClearInputData()
    }

    方法 清除纹理数据 <公开 注释 = "清除输出的字体纹理数据(CPU侧),每当字体纹理复制到显卡内存后保存到内存中." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->ClearTexData()
    }

    方法 清除字体 <公开 注释 = "清除输出的字体数据(字形存储、UV坐标等)" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->ClearFonts()
    }

    方法 清除 <公开 注释 = "清除字体图集的所有输入和输出数据" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->Clear()
    }

    方法 生成 <公开 注释 = "生成8位单通道Alpha颜色的字体图集像素,本方法亦会在执行\"取纹理数据_xxx\"时自动调用." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->Build()
    }

    方法 取纹理数据_Alpha8 <公开 类型 = 变整数 注释 = "生成8位单通道Alpha颜色的字体图集像素(1字节/像素),然后返回纹理的指针和宽高."
            返回值注释 = "返回字体纹理的指针,可以转换到字节集: 字节集.指针添加字节集 (纹理指针, 纹理宽度 * 纹理高度 * 1)" 折叠 @嵌入式方法 = "">
    参数 纹理宽度 <类型 = 整数 注释 = "必须提供一个整数变量,返回字体图集纹理的宽度." @需求类型 = 可写入变量>
    参数 纹理高度 <类型 = 整数 注释 = "必须提供一个整数变量,返回字体图集纹理的高度." @需求类型 = 可写入变量>
    {
        @ [&]() {
        @     unsigned char* tex_pixels = nullptr;
        @     @sn<this>.pdata()->GetTexDataAsAlpha8(&tex_pixels, &@<纹理宽度>, &@<纹理高度>, nullptr);
        @     return (INT_P)tex_pixels;
        @ } ()
    }

    方法 取纹理数据_RGBA32 <公开 类型 = 变整数 注释 = "生成32位RGBA颜色的字体图集像素(4字节/像素),然后返回纹理的指针和宽高."
            注释 = "注意: 提供RGBA32格式主要为了方便和兼容性,除非手动操作或将颜色数据复制到纹理中," 注释 = "否则生成的RGB像素将始终是白色(约浪费75%的内存占用)."
            注释 = "无论如何,内部都会先生成8位Alpha颜色,再转换到RGBA32."
            返回值注释 = "返回字体纹理的指针,可以转换到字节集: 字节集.指针添加字节集 (纹理指针, 纹理宽度 * 纹理高度 * 4)" 折叠 @嵌入式方法 = "">
    参数 纹理宽度 <类型 = 整数 注释 = "必须提供一个整数变量,返回字体图集纹理的宽度." @需求类型 = 可写入变量>
    参数 纹理高度 <类型 = 整数 注释 = "必须提供一个整数变量,返回字体图集纹理的高度." @需求类型 = 可写入变量>
    {
        @ [&]() {
        @     unsigned char* tex_pixels = nullptr;
        @     @sn<this>.pdata()->GetTexDataAsRGBA32(&tex_pixels, &@<纹理宽度>, &@<纹理高度>, nullptr);
        @     return (INT_P)tex_pixels;
        @ } ()
    }

    方法 是否已生成 <公开 类型 = 逻辑型 注释 = "返回是否已经生成了纹理数据" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->IsBuilt()
    }
}

类 IM字形范围构建类 <公开 基础类 = 数据类型基础类 注释 = "ImFontGlyphRangesBuilder,用于自定义字体的字形范围,"
        注释 = "可实现只渲染字体中需要的文字,可以有效缩减字体纹理数据的内存占用." 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImFontGlyphRangesBuilder)

    方法 清空 <公开 注释 = "清空当前的字形范围" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().Clear()
    }

    方法 加入字符 <公开 注释 = "添加一个宽字库到字形范围中" 折叠 @嵌入式方法 = "">
    参数 所加入字符 <类型 = 字符 注释 = "所欲添加的字符,可以用单引号输入汉字,比如: \'火\'">
    {
        @ @sn<this>.data().AddChar(@<所加入字符>)
    }

    方法 加入文本 <公开 注释 = "以火山的文本型添加一组文字到自定义的字形范围中." 注释 = "本方法不会产生编码转换,推荐使用." 折叠>
    参数 所加入文本 <类型 = 文本型>
    {
        @ for (INT_P i = 0; i < @<所加入文本>.GetLength(); i++) {
        @     this->data().AddChar(@<所加入文本>.GetCharAt (i));
        @ }
    }

    方法 加入文本U <公开 注释 = "添加UTF-8编码的文本数据到自定义的字形范围中."
            注释 = "注意: 由于内部会将UTF-8字符转换到Unicode字符,因此会产生一到两次的编码转换,不太建议使用." 折叠 @嵌入式方法 = "">
    参数 所加入文本 <注释 = "支持类型(*表示会进行编码转换):" 注释 = " 标准文本类U、文本视图类U、字节集类(UTF-8编码)" 注释 = " *文本型、*标准文本类、*文本视图类"
            @匹配类型 = 通用型>
    {
        @ @sn<this>.data().AddText(*PivAny2U{@<所加入文本>})
    }

    方法 加入范围 <公开 注释 = "添加\"IM字形范围\"常量中的字形范围,可以方便添加英文数字等常用文字类型." 折叠 @嵌入式方法 = "">
    参数 字形范围 <类型 = IM字形范围 注释 = "选择字体的字形范围,范围内的字符将栅格化为图集,如果范围过大将消耗更多的内存." 注释 = "但如果有不在范围内字符,将无法正常显示."
            @默认值 = IM字形范围.中文>
    {
        @ @sn<this>.data().AddRanges(ImGui::GetIO().Fonts->@pvpt<字形范围>())

    }

    # @begin
    # <> <include>
    # ImVector<ImWchar>* m_ranges = nullptr;
    # // 下面的方法找不到释放内存的时机,但只内存泄漏一次,问题不大...
    # inline ImWchar* ranges() {
    #     if (!m_ranges) { m_ranges = new ImVector<ImWchar>; }
    #     this->data().BuildRanges(m_ranges);
    #     return m_ranges->Data;
    # }
    # <> </include>
    # @end
}

类 ImVec2 <公开 基础类 = 数据类型基础类 注释 = "ImVec2" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImVec2)

    方法 创建 <公开 静态 类型 = ImVec2 注释 = "带参构造一个ImVec2实例,请以类名使用本方法." 折叠 @嵌入式方法 = "">
    参数 x值 <类型 = 单精度小数 @默认值 = 0>
    参数 y值 <类型 = 单精度小数 @默认值 = 0>
    {
        @ @dt<ImVec2>{ImVec2(@<x值>, @<y值>)}
    }

    方法 x <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->x
    }

    方法 x <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->x = @<所欲设置值>;
    }

    方法 y <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->y
    }

    方法 y <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->y = @<所欲设置值>;
    }

    方法 置值 <公开 注释 = "一个命令设置ImVec2的所有值" 折叠>
    参数 x值 <类型 = 单精度小数>
    参数 y值 <类型 = 单精度小数>
    {
        @ pdata()->x = @<x值>;
        @ pdata()->y = @<y值>;
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<ImVec2> {x: %.2f, y: %.2f}", x, y)
    }
}

类 ImVec2数组类 <公开 基础类 = 数据容器模板类 折叠 @文档 = "category = \"辅助类\"" @模板实现类 = "ImVec2">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (ImVec2)
}

类 ImVec4 <公开 基础类 = 数据类型基础类 注释 = "ImVec4" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImVec4)

    方法 创建 <公开 静态 类型 = ImVec4 注释 = "带参构造一个ImVec4实例,请以类名使用本方法." 折叠 @嵌入式方法 = "">
    参数 x值 <类型 = 单精度小数 @默认值 = 0>
    参数 y值 <类型 = 单精度小数 @默认值 = 0>
    参数 z值 <类型 = 单精度小数 @默认值 = 0>
    参数 w值 <类型 = 单精度小数 @默认值 = 0>
    {
        @ @dt<ImVec4>{ImVec4(@<x值>, @<y值>, @<z值>, @<w值>)}
    }

    方法 x <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->x
    }

    方法 x <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->x = @<所欲设置值>;
    }

    方法 y <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->y
    }

    方法 y <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->y = @<所欲设置值>;
    }

    方法 z <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->z
    }

    方法 z <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->z = @<所欲设置值>;
    }

    方法 w <公开 属性读 类型 = 单精度小数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.pdata()->w
    }

    方法 w <公开 属性写 折叠>
    参数 所欲设置值 <类型 = 单精度小数>
    {
        @ pdata()->w = @<所欲设置值>;
    }

    方法 置值 <公开 注释 = "一个命令设置ImVec4的所有值" 折叠>
    参数 x值 <类型 = 单精度小数>
    参数 y值 <类型 = 单精度小数>
    参数 z值 <类型 = 单精度小数>
    参数 w值 <类型 = 单精度小数>
    {
        @ pdata()->x = @<x值>;
        @ pdata()->y = @<y值>;
        @ pdata()->z = @<z值>;
        @ pdata()->w = @<w值>;
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<ImVec4> {x: %.2f, y: %.2f, z: %.2f, w: %.2f}", x, y, z, w)
    }
}

类 IM图片信息类 <公开 基础类 = 扩展对象类 折叠 @文档 = "category = \"辅助类\"">
{
    变量 纹理ID <公开 类型 = 变整数>
    变量 宽度 <公开 类型 = 整数>
    变量 高度 <公开 类型 = 整数>
    变量 _内部数据 <公开 类型 = 变整数>
}

类 ImGuiIO类 <公开 基础类 = 数据类型基础类 注释 = "必须接收\"ImGui.取IO()\"的返回结果后,才能使用本类." 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiIO)

    方法 帧速率 <公开 属性读 类型 = 单精度小数 注释 = "返回应用程序的平均帧速率" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().Framerate
    }

    方法 字体全局缩放 <公开 属性写 折叠>
    参数 新值 <类型 = 单精度小数>
    {
        @ data().FontGlobalScale = @<新值>;
    }

    方法 标志 <公开 属性读 类型 = 整数 注释 = "IM配置标志,请参考\"IM配置标志\"的常量" 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().ConfigFlags
    }

    方法 标志 <公开 属性写 注释 = "IM配置标志" 折叠>
    参数 新标志 <类型 = 整数 注释 = "\"IM配置标志\"常量的位或值">
    {
        @ data().ConfigFlags = (ImGuiConfigFlags)@<新标志>;
    }
}

类 IM样式类 <公开 基础类 = 数据类型基础类 注释 = "ImGuiStyle 未封装功能" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiStyle)

    方法 窗口圆角半径 <公开 属性读 类型 = 单精度小数
            注释 = "Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended."
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().WindowRounding
    }

    方法 窗口圆角半径 <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().WindowRounding = @<所欲设置的值>;
    }

    方法 颜色 <公开 类型 = ImVec4 折叠 @嵌入式方法 = "">
    参数 颜色索引 <类型 = IM颜色标识符>
    {
        @ @dt<ImVec4>{&@sn<this>.data().Colors[(int)@<颜色索引>]}
    }
}

类 IM负载类 <公开 基础类 = 数据类型基础类 注释 = "ImGuiPayload 拖放的负载" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiPayload)

    方法 数据指针 <公开 属性读 类型 = 变整数 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().Data
    }

    方法 数据长度 <公开 属性读 类型 = 整数 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().DataSize
    }

    方法 是否预览 <公开 属性读 类型 = 逻辑型 注释 = "当调用了\"接收拖放负载\"且鼠标悬停在目标项目时返回真." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IsPreview()
    }

    方法 是否传递 <公开 属性读 类型 = 逻辑型 注释 = "当调用了\"接收拖放负载\"且鼠标按钮在目标按钮上释放时返回真." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().IsDelivery()
    }

    方法 是否为指定类型 <公开 类型 = 逻辑型 注释 = "检查当前的数据类型是否为指定的类型" 折叠 @嵌入式方法 = "">
    参数 类型 <注释 = "类型是用户定义的文本,最多32个UTF-8字符,字符\'_\'开头的是ImGui的内部保留类型." 注释 = "建议类型: 标准文本类U、字节集类(UTF-8)、文本型;"
            @匹配类型 = 通用型>
    {
        @ @sn<this>.data().IsDataType(*PivAny2U{@<类型>})
    }
}

类 IM视口类 <公开 基础类 = 数据类型基础类 注释 = "ImGuiViewport 用于接收\"ImGui.取主视口()\"的返回结果" 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiViewport)

    方法 ID <公开 属性读 类型 = 整数 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().ID
    }

    方法 标志 <公开 属性读 类型 = 整数 注释 = "请参考\"IM视口标志\"" 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().Flags
    }

    方法 标志 <公开 属性写 注释 = "请参考\"IM视口标志\"" 折叠>
    参数 所欲设置的值 <类型 = 整数>
    {
        @ data().Flags = (ImGuiViewportFlags)@<所欲设置的值>;
    }

    方法 平台句柄 <公开 属性读 类型 = 变整数 注释 = "Windows平台下返回Win32的窗口句柄" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().PlatformHandleRaw
    }

    方法 DPI缩放 <公开 属性读 类型 = 单精度小数 注释 = "1.0f = 96 DPI,即没有额外缩放." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().DpiScale
    }

    方法 DPI缩放 <公开 属性写 注释 = "1.0f = 96 DPI,即没有额外缩放." 折叠>
    参数 所欲设置的值 <类型 = 单精度小数>
    {
        @ data().DpiScale = @<所欲设置的值>;
    }

    方法 父视口ID <公开 属性读 类型 = 整数
            注释 = "(Advanced) 0: no parent. Instruct the platform backend to setup a parent/child relationship between platform windows."
            折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.data().ParentViewportId
    }

    方法 父视口ID <公开 属性写 折叠>
    参数 所欲设置的值 <类型 = 整数>
    {
        @ data().ParentViewportId = (ImGuiID)@<所欲设置的值>;
    }

    方法 取位置 <公开 类型 = ImVec2 注释 = "返回主区域的视口位置,坐标与操作系统桌面/本地坐标相同." 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().Pos}
    }

    方法 取尺寸 <公开 类型 = ImVec2 注释 = "返回主区域的视口尺寸" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().Size}
    }

    方法 取工作区位置 <公开 类型 = ImVec2 注释 = "返回工作区的位置,即视口位置减去任务栏、菜单栏、状态栏" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().WorkPos}
    }

    方法 取工作区尺寸 <公开 类型 = ImVec2 注释 = "返回工作区的尺寸,即视口尺寸减去任务栏、菜单栏、状态栏" 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().WorkSize}
    }

    方法 取中心 <公开 类型 = ImVec2 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().GetCenter()}
    }

    方法 取工作区中心 <公开 类型 = ImVec2 折叠 @嵌入式方法 = "">
    {
        @ @dt<ImVec2>{@sn<this>.data().GetWorkCenter()}
    }
}

类 IM窗口类 <公开 基础类 = 数据类型基础类 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiWindowClass)
}

类 IM平台IO类 <公开 基础类 = 数据类型基础类 折叠 @文档 = "category = \"辅助类\"">
{

    # @ @m<PIV_DECLARE_STRUCT_CLASS> (ImGuiPlatformIO)
}

# 标志常量

类 IM窗口标志 <公开 注释 = "ImGui.窗口开端()" 注释 = "ImGuiWindowFlags" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiWindowFlags_None 注释 = "无标志">
    常量 禁止标题栏 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoTitleBar 注释 = "禁止显示标题栏">
    常量 禁止调整大小 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoResize 注释 = "禁止使用右下大小调节手柄来重新调整窗口大小">
    常量 禁止移动 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoMove 注释 = "禁止用户移动窗口位置">
    常量 禁止滚动条 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoScrollbar 注释 = "禁止显示滚动条,但仍可以通过鼠标和编程方式进行滚动窗口.">
    常量 禁止鼠标滚动 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoScrollWithMouse
            注释 = "禁止用户使用鼠标滚轮垂直滚动窗口.除非同时设置了\"禁止滚动条\",否则子窗口的鼠标滚轮将转发到父窗口中.">
    常量 禁止折叠 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoCollapse 注释 = "禁止用户通过双击来折叠窗口,通用适用于窗口菜单按钮.">
    常量 始终自动调整大小 <公开 类型 = 整数 值 = @ImGuiWindowFlags_AlwaysAutoResize 注释 = "根据每一帧的内容调整每个窗口的大小">
    常量 禁止背景 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoBackground
            注释 = "禁止绘制背景颜色(窗口背景等)和外边框.类似于调用\"置下一窗口背景透明度(0.0)\".">
    常量 禁止保存配置 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoSavedSettings 注释 = "从不在 .ini 文件中加载和保存窗口配置">
    常量 禁止鼠标输入 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoMouseInputs 注释 = "禁止捕捉鼠标,悬停会穿透该窗口.">
    常量 菜单栏 <公开 类型 = 整数 值 = @ImGuiWindowFlags_MenuBar 注释 = "窗口拥有菜单栏">
    常量 水平滚动条 <公开 类型 = 整数 值 = @ImGuiWindowFlags_HorizontalScrollbar 注释 = "允许出现水平滚动条(默认不允许).">
    常量 显示时不获得焦点 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoFocusOnAppearing 注释 = "从隐藏状态切换到可视状态时禁止获得焦点.">
    常量 获得焦点时不置于顶层 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoBringToFrontOnFocus
            注释 = "当窗口获得焦点时,禁止将窗口置于顶层(例如单击窗口或以编程方式让窗口获得焦点).">
    常量 始终显示垂直滚动条 <公开 类型 = 整数 值 = @ImGuiWindowFlags_AlwaysVerticalScrollbar 注释 = "始终显示垂直滚动条,即使内容高度小于窗口高度.">
    常量 始终显示水平滚动条 <公开 类型 = 整数 值 = @ImGuiWindowFlags_AlwaysHorizontalScrollbar 注释 = "始终显示水平滚动条,即使内容宽度小于窗口宽度.">
    常量 始终使用窗口边距 <公开 类型 = 整数 值 = @ImGuiWindowFlags_AlwaysUseWindowPadding
            注释 = "Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)">
    常量 禁止导航输入 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoNavInputs 注释 = "禁止使用游戏手柄和鼠标导航窗口(控制窗口的前进、后退、刷新等)">
    常量 禁止导航焦点 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoNavFocus 注释 = "使用游戏手柄和鼠标导航窗口将无法焦点到此窗口,除了CTRL+TAB">
    常量 未保存文档 <公开 类型 = 整数 值 = @ImGuiWindowFlags_UnsavedDocument 注释 = "在窗口标题后面显示一个小圆点"
            注释 = "When used in a tab/docking context, tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab)."
            注释 = "Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.">
    常量 禁止停靠 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoDocking 注释 = "禁止窗口使用停靠">
    常量 禁止导航 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoNav 注释 = "连续位或(禁止导航输入, 禁止导航焦点)">
    常量 禁止窗口装饰 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoDecoration 注释 = "连续位或(禁止标题栏, 禁止调整大小, 禁止滚动条, 禁止折叠)">
    常量 禁止输入 <公开 类型 = 整数 值 = @ImGuiWindowFlags_NoInputs 注释 = "连续位或(禁止鼠标输入, 禁止导航输入, 禁止导航焦点)">
}

类 IM输入框标志 <公开 注释 = "ImGuiInputTextFlags" 注释 = "Flags for ImGui::InputText()"
        注释 = "(Those are per-item flags."
        注释 = "There are shared flags in ImGuiIO: io.ConfigInputTextCursorBlink"
        注释 = "and io.ConfigInputTextEnterKeepActive)" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_None>
    常量 十进制数字 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CharsDecimal 注释 = "允许输入 0123456789.+-*/">
    常量 十六进制数字 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CharsHexadecimal 注释 = "允许输入 0123456789ABCDEFabcdef">
    常量 转换到大写 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CharsUppercase 注释 = "将小写字母a..z转换到大写A..Z">
    常量 禁止空白 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CharsNoBlank 注释 = "过滤掉空格和制表符">
    常量 自动全选 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_AutoSelectAll 注释 = "第一次获得鼠标焦点时选择整个文本">
    常量 按回车返回真 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_EnterReturnsTrue
            注释 = "按回车键时返回\"true\",与每次修改值时相反.请查看IsItemDeactivatedAfterEdit()函数.">
    常量 完成回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackCompletion 注释 = "在输入TAB键时触发回调,用于处理结束文本编辑">
    常量 历史记录回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackHistory 注释 = "在输入向上/向下键时触发回调,用于处理历史记录">
    常量 始终回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackAlways 注释 = "每次迭代的回调.用户代码可以查询光标位置,修改文本缓冲区.">
    常量 字符过滤回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackCharFilter
            注释 = "在回调中替换或丢弃对输入的字符.修改\"EventChar\"以替换或丢弃，或在回调中返回1以丢弃。">
    常量 允许制表符 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_AllowTabInput 注释 = "按TAB键时输入一个\'\\t\'字符到文本区">
    常量 按Ctrl_回车换行 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CtrlEnterForNewLine
            注释 = "在多行模式下,按回车失去焦点,按Ctrl+回车添加新行(与默认行为正好相反)">
    常量 禁止水平滚动 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_NoHorizontalScroll 注释 = "禁止水平跟随光标">
    常量 改写模式 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_AlwaysOverwrite 注释 = "改写模式">
    常量 只读模式 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_ReadOnly 注释 = "只读模式">
    常量 密码模式 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_Password 注释 = "密码模式,将所有字符显示为\'*\'">
    常量 禁止撤销重做 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_NoUndoRedo
            注释 = "禁用撤消/重做.请注意输入框在活动时拥有文本数据,如果你想提供自己的撤销/重做堆栈,你需要调用ClearActiveID().">
    常量 科学计数法 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CharsScientific 注释 = "允许输入小数 0123456789.+-*/eE (科学计数法输入)">
    常量 重设大小回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackResize
            注释 = "缓冲区容量超过\"buf_size\"参数值时,请求更改的回调,以允许字符串增长." 注释 = "当字符串需要调整大小时通知(对于保存其大小的缓存的字符串类型)."
            注释 = "回调中会提供一个新的缓存大小,你需要遵守它.">
    常量 编辑回调 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_CallbackEdit
            注释 = "在进行任何编辑时触发回调.请注意\"输入框\"在编辑时已经返回true,这个回调主要用于在获得焦点时操作底层缓冲区.">
    常量 按ESC键清除 <公开 类型 = 整数 值 = @ImGuiInputTextFlags_EscapeClearsAll
            注释 = "如果内容不为空,按ESC键将清除内容,否则为停用(与ESC的默认行为正好相反)">
}

类 IM树节点标志 <公开 注释 = "ImGuiTreeNodeFlags"
        注释 = "Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_None>
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_Selected 注释 = "Draw as selected">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_Framed
            注释 = "Draw frame with background (e.g. for CollapsingHeader)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_AllowItemOverlap
            注释 = "Hit testing to allow subsequent widgets to overlap this one">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_NoTreePushOnOpen
            注释 = "Don\'t do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_NoAutoOpenOnLog
            注释 = "Don\'t automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_DefaultOpen 注释 = "Default node to be open">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_OpenOnDoubleClick 注释 = "Need double-click to open node">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_OpenOnArrow
            注释 = "Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_Leaf
            注释 = "No collapsing, no arrow (use as a convenience for leaf nodes).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_Bullet 注释 = "Display a bullet instead of arrow">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_FramePadding
            注释 = "Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_SpanAvailWidth
            注释 = "Extend hit box to the right-most edge, even if not framed."
            注释 = "This is not the default in order to allow adding other items on the same line."
            注释 = "In the future we may refactor the hit system to be front-to-back, allowing natural overlaps and then this can become the default.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_SpanFullWidth
            注释 = "Extend hit box to the left-most and right-most edges (bypass the indented area).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_NavLeftJumpsBackHere
            注释 = "(WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)">
    常量 "//" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_NoScrollOnOpen
            注释 = "FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTreeNodeFlags_CollapsingHeader
            注释 = "ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog">
}

类 IM弹出标志 <公开
        注释 = "ImGuiPopupFlags Flags for OpenPopup*(), BeginPopupContext*(), IsPopupOpen() functions." 折叠
        @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiPopupFlags_None>
    常量 鼠标左键 <公开 类型 = 整数 值 = @ImGuiPopupFlags_MouseButtonLeft
            注释 = "For BeginPopupContext*(): open on Left Mouse release. Guaranteed to always be == 0 (same as ImGuiMouseButton_Left)">
    常量 鼠标右键 <公开 类型 = 整数 值 = @ImGuiPopupFlags_MouseButtonRight
            注释 = "For BeginPopupContext*(): open on Right Mouse release. Guaranteed to always be == 1 (same as ImGuiMouseButton_Right)">
    常量 鼠标中键 <公开 类型 = 整数 值 = @ImGuiPopupFlags_MouseButtonMiddle
            注释 = "For BeginPopupContext*(): open on Middle Mouse release. Guaranteed to always be == 2 (same as ImGuiMouseButton_Middle)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_MouseButtonMask_>
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_MouseButtonDefault_>
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_NoOpenOverExistingPopup
            注释 = "For OpenPopup*(), BeginPopupContext*(): don\'t open if there\'s already a popup at the same level of the popup stack">
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_NoOpenOverItems
            注释 = "For BeginPopupContextWindow(): don\'t return true when hovering items, only when hovering empty space">
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_AnyPopupId
            注释 = "For IsPopupOpen(): ignore the ImGuiID parameter and test for any popup.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_AnyPopupLevel
            注释 = "For IsPopupOpen(): search/test at any level of the popup stack (default test in the current level)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiPopupFlags_AnyPopup
            注释 = "ImGuiPopupFlags_AnyPopupId | ImGuiPopupFlags_AnyPopupLevel">
}

类 IM可选项标志 <公开 注释 = "ImGuiSelectableFlags Flags for ImGui::Selectable()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_None>
    常量 不关闭弹出项 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_DontClosePopups
            注释 = "Clicking this doesn\'t close parent popup window">
    常量 横跨所有列 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_SpanAllColumns
            注释 = "Selectable frame can span all columns (text will still fit in current column)">
    常量 允许双击 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_AllowDoubleClick
            注释 = "Generate press events on double clicks too">
    常量 禁用 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_Disabled 注释 = "Cannot be selected, display grayed out text">
    常量 允许项目重叠 <公开 类型 = 整数 值 = @ImGuiSelectableFlags_AllowItemOverlap
            注释 = "(WIP) Hit testing to allow subsequent widgets to overlap this one">
}

类 IM组合框标志 <公开 注释 = "ImGuiComboFlags Flags for ImGui::BeginCombo()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiComboFlags_None>
    常量 左对齐弹出项 <公开 类型 = 整数 值 = @ImGuiComboFlags_PopupAlignLeft
            注释 = "Align the popup toward the left by default">
    常量 小型高度 <公开 类型 = 整数 值 = @ImGuiComboFlags_HeightSmall
            注释 = "Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()">
    常量 常规高度 <公开 类型 = 整数 值 = @ImGuiComboFlags_HeightRegular 注释 = "Max ~8 items visible (default)">
    常量 大型高度 <公开 类型 = 整数 值 = @ImGuiComboFlags_HeightLarge 注释 = "Max ~20 items visible">
    常量 最大高度 <公开 类型 = 整数 值 = @ImGuiComboFlags_HeightLargest 注释 = "As many fitting items as possible">
    常量 无箭头按钮 <公开 类型 = 整数 值 = @ImGuiComboFlags_NoArrowButton
            注释 = "Display on the preview box without the square arrow button">
    常量 无预览项 <公开 类型 = 整数 值 = @ImGuiComboFlags_NoPreview 注释 = "Display only a square arrow button">
    常量 高度掩码 <公开 类型 = 整数 值 = @ImGuiComboFlags_HeightMask_
            注释 = "ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest">
}

类 IM选项卡栏标志 <公开 注释 = "ImGuiTabBarFlags Flags for ImGui::BeginTabBar()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiTabBarFlags_None>
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabBarFlags_Reorderable
            注释 = "Allow manually dragging tabs to re-order them + New tabs are appended at the end of list">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabBarFlags_AutoSelectNewTabs
            注释 = "Automatically select new tabs when they appear">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabBarFlags_TabListPopupButton
            注释 = "Disable buttons to open the tab list popup">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabBarFlags_NoCloseWithMiddleMouseButton
            注释 = "Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button."
            注释 = "You can still repro this behavior on user\'s side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabBarFlags_NoTabListScrollingButtons
            注释 = "Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabBarFlags_NoTooltip 注释 = "Disable tooltips when hovering a tab">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabBarFlags_FittingPolicyResizeDown 注释 = "Resize tabs when they don\'t fit">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabBarFlags_FittingPolicyScroll
            注释 = "Add scroll buttons when tabs don\'t fit">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabBarFlags_FittingPolicyMask_
            注释 = "ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabBarFlags_FittingPolicyDefault_
            注释 = "ImGuiTabBarFlags_FittingPolicyResizeDown">
}

类 IM选项卡项标志 <公开 注释 = "ImGuiTabItemFlags Flags for ImGui::BeginTabItem()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiTabItemFlags_None>
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabItemFlags_UnsavedDocument
            注释 = "Display a dot next to the title + tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab)."
            注释 = "Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabItemFlags_SetSelected
            注释 = "Trigger flag to programmatically make the tab selected when calling BeginTabItem()">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabItemFlags_NoCloseWithMiddleMouseButton
            注释 = "Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button."
            注释 = "You can still repro this behavior on user\'s side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabItemFlags_NoPushId
            注释 = "Don\'t call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabItemFlags_NoTooltip 注释 = "Disable tooltip for the given tab">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabItemFlags_NoReorder
            注释 = "Disable reordering this tab or having another tab cross over this tab">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabItemFlags_Leading
            注释 = "Enforce the tab position to the left of the tab bar (after the tab list popup button)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTabItemFlags_Trailing
            注释 = "Enforce the tab position to the right of the tab bar (before the scrolling buttons)">
}

类 IM表格标志 <公开 注释 = "ImGuiTableFlags Flags for ImGui::BeginTable()" 折叠 @文档 = "category = \"标志类\"">
{

    # 功能 / Features

    常量 无 <公开 类型 = 整数 值 = @ImGuiTableFlags_None>
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_Resizable 注释 = "Enable resizing columns.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_Reorderable
            注释 = "Enable reordering columns in header row (need calling TableSetupColumn() + TableHeadersRow() to display headers)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_Hideable 注释 = "Enable hiding/disabling columns in context menu.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_Sortable
            注释 = "Enable sorting. Call TableGetSortSpecs() to obtain sort specs. Also see ImGuiTableFlags_SortMulti and ImGuiTableFlags_SortTristate.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_NoSavedSettings
            注释 = "Disable persisting columns order, width and sort settings in the .ini file.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_ContextMenuInBody
            注释 = "Right-click on columns body/contents will display table context menu. By default it is available in TableHeadersRow().">

    # Decorations

    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_RowBg
            注释 = "Set each RowBg color with ImGuiCol_TableRowBg or ImGuiCol_TableRowBgAlt (equivalent of calling TableSetBgColor with ImGuiTableBgFlags_RowBg0 on each row manually)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersInnerH 注释 = "Draw horizontal borders between rows.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersOuterH
            注释 = "Draw horizontal borders at the top and bottom.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersInnerV 注释 = "Draw vertical borders between columns.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersOuterV
            注释 = "Draw vertical borders on the left and right sides.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersH 注释 = "Draw horizontal borders.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersV 注释 = "Draw vertical borders.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersInner 注释 = "Draw inner borders.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_BordersOuter 注释 = "Draw outer borders.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_Borders 注释 = "Draw all borders.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_NoBordersInBody
            注释 = "[ALPHA] Disable vertical borders in columns Body (borders will always appear in Headers). -> May move to style">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_NoBordersInBodyUntilResize
            注释 = "[ALPHA] Disable vertical borders in columns Body until hovered for resize (borders will always appear in Headers). -> May move to style">

    # Sizing Policy (read above for defaults)

    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_SizingFixedFit
            注释 = "Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching contents width.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_SizingFixedSame
            注释 = "Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching the maximum contents width of all columns. Implicitly enable ImGuiTableFlags_NoKeepColumnsVisible.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_SizingStretchProp
            注释 = "Columns default to _WidthStretch with default weights proportional to each columns contents widths.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_SizingStretchSame
            注释 = "Columns default to _WidthStretch with default weights all equal, unless overridden by TableSetupColumn().">

    # Sizing Extra Options

    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_NoHostExtendX
            注释 = "Make outer width auto-fit to columns, overriding outer_size.x value. Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_NoHostExtendY
            注释 = "Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit)."
            注释 = "Only available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_NoKeepColumnsVisible
            注释 = "Disable keeping column always minimally visible when ScrollX is off and table gets too small. Not recommended if columns are resizable.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_PreciseWidths
            注释 = "Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33)."
            注释 = "With larger number of columns, resizing will appear to be less smooth.">

    # Clipping

    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_NoClip
            注释 = "Disable clipping rectangle for every individual columns (reduce draw command count, items will be able to overflow into other columns)."
            注释 = "Generally incompatible with TableSetupScrollFreeze().">

    # Padding

    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_PadOuterX
            注释 = "Default if BordersOuterV is on. Enable outermost padding. Generally desirable if you have headers.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_NoPadOuterX
            注释 = "Default if BordersOuterV is off. Disable outermost padding.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_NoPadInnerX
            注释 = "Disable inner padding between columns (double inner padding if BordersOuterV is on, single inner padding if BordersOuterV is off).">

    # Scrolling

    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_ScrollX
            注释 = "Enable horizontal scrolling. Require \'outer_size\' parameter of BeginTable() to specify the container size. Changes default sizing policy."
            注释 = "Because this creates a child window, ScrollY is currently generally recommended when using ScrollX.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_ScrollY
            注释 = "Enable vertical scrolling. Require \'outer_size\' parameter of BeginTable() to specify the container size.">

    # Sorting

    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_SortMulti
            注释 = "Hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_SortTristate
            注释 = "Allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableFlags_SizingMask_
            注释 = "ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_SizingFixedSame | ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_SizingStretchSame">
}

类 IM表格列标志 <公开 注释 = "ImGuiTableColumnFlags Flags for ImGui::TableSetupColumn()" 折叠
        @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_None>
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_Disabled
            注释 = "Overriding/master disable flag: hide column, won\'t show in context menu (unlike calling TableSetColumnEnabled() which manipulates the user accessible state)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_DefaultHide 注释 = "Default as a hidden/disabled column.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_DefaultSort 注释 = "Default as a sorting column.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_WidthStretch
            注释 = "Column will stretch. Preferable with horizontal scrolling disabled (default if table sizing policy is _SizingStretchSame or _SizingStretchProp).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_WidthFixed
            注释 = "Column will not stretch. Preferable with horizontal scrolling enabled (default if table sizing policy is _SizingFixedFit and table is resizable).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoResize 注释 = "Disable manual resizing.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoReorder
            注释 = "Disable manual reordering this column, this will also prevent other columns from crossing over this column.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoHide 注释 = "Disable ability to hide/disable this column.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoClip
            注释 = "Disable clipping for this column (all NoClip columns will render in a same draw command).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoSort
            注释 = "Disable ability to sort on this field (even if ImGuiTableFlags_Sortable is set on the table).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoSortAscending
            注释 = "Disable ability to sort in the ascending direction.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoSortDescending
            注释 = "Disable ability to sort in the descending direction.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoHeaderLabel
            注释 = "TableHeadersRow() will not submit label for this column. Convenient for some small columns. Name will still appear in context menu.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoHeaderWidth
            注释 = "Disable header text width contribution to automatic column width.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_PreferSortAscending
            注释 = "Make the initial sort direction Ascending when first sorting on this column (default).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_PreferSortDescending
            注释 = "Make the initial sort direction Descending when first sorting on this column.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IndentEnable
            注释 = "Use current Indent value when entering cell (default for column 0).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IndentDisable
            注释 = "Ignore current Indent value when entering cell (default for columns > 0). Indentation changes _within_ the cell will still be honored.">
    常量 "" <注释 = "// Output status flags, read-only via TableGetColumnFlags()">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IsEnabled
            注释 = "Status: is enabled == not hidden by user/api (referred to as \"Hide\" in _DefaultHide and _NoHide) flags.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IsVisible
            注释 = "Status: is visible == is enabled AND not clipped by scrolling.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IsSorted
            注释 = "Status: is currently part of the sort specs">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IsHovered 注释 = "Status: is hovered by mouse">
    常量 ""
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_WidthMask_
            注释 = "ImGuiTableColumnFlags_WidthStretch | ImGuiTableColumnFlags_WidthFixed">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_IndentMask_
            注释 = "ImGuiTableColumnFlags_IndentEnable | ImGuiTableColumnFlags_IndentDisable">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_StatusMask_
            注释 = "ImGuiTableColumnFlags_IsEnabled | ImGuiTableColumnFlags_IsVisible | ImGuiTableColumnFlags_IsSorted | ImGuiTableColumnFlags_IsHovered,">
    常量 "" <公开 类型 = 整数 值 = @ImGuiTableColumnFlags_NoDirectResize_
            注释 = "[Internal] Disable user resizing this column directly (it may however we resized indirectly from its left edge)">
}

类 IM表格行标志 <公开 注释 = "ImGuiTableRowFlags Flags for ImGui::TableNextRow()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiTableRowFlags_None>
    常量 表头 <公开 类型 = 整数 值 = @ImGuiTableRowFlags_Headers 注释 = "标识表头标题行(设置默认背景颜色+其内容的宽度,以不同方式考虑自动列宽)"
            注释 = "Identify header row (set default background color + width of its contents accounted differently for auto column width)">
}

类 IM焦点标志 <公开 注释 = "ImGuiFocusedFlags ImGui.窗口可有焦点()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_None>
    常量 子窗口 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_ChildWindows 注释 = "如果任意子窗口有焦点也返回真">
    常量 根窗口 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_RootWindow 注释 = "从根窗口测试(当前层级结构的最顶端父级)">
    常量 任意窗口 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_AnyWindow 注释 = "任意窗口获得焦点都会返回真">
    常量 无弹出层级 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_NoPopupHierarchy
            注释 = "不考虑弹出层级结构(不将触发弹出的窗口视为弹出项的父级,与\"子窗口\"或\"根窗口\"一起使用）">
    常量 停靠层级 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_DockHierarchy
            注释 = "考虑停靠的层次结构,将停靠空间的宿主视为停靠窗口的父级(与\"子窗口\"和\"根窗口\"组合使用)">
    常量 根和子窗口 <公开 类型 = 整数 值 = @ImGuiFocusedFlags_RootAndChildWindows
            注释 = "ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows">
}

类 IM悬停标志 <公开 注释 = "ImGuiHoveredFlags ImGui.窗口可有悬停()、ImGui.项目可有悬停()" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_None 注释 = "当鼠标直接悬停于项目/窗口,未被另一个窗口遮挡,且未被活动弹出项或模态输入框遮挡,则返回真.">
    常量 子窗口 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_ChildWindows 注释 = "仅限\"窗口可有悬停\": 在此窗口的任意子窗口上悬停时返回真.">
    常量 根窗口 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_RootWindow 注释 = "仅限\"窗口可有悬停\": 从根窗口测试(当前层级结构的最顶端父级)">
    常量 任意窗口 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_AnyWindow 注释 = "仅限\"窗口可有悬停\": 在任意窗口上悬停时返回真">
    常量 无弹出层级 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_NoPopupHierarchy
            注释 = "仅限\"窗口可有悬停\": 不考虑弹出层级结构(不将触发弹出的窗口视为弹出项的父级,与\"子窗口\"或\"根窗口\"一起使用）">
    常量 停靠层级 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_DockHierarchy
            注释 = "仅限\"窗口可有悬停\": 考虑停靠的层次结构,将停靠空间的宿主视为停靠窗口的父级(与\"子窗口\"和\"根窗口\"组合使用)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiHoveredFlags_AllowWhenBlockedByPopup
            注释 = "Return true even if a popup window is normally blocking access to this item/window">
    常量 "" <公开 类型 = 整数 值 = @ImGuiHoveredFlags_AllowWhenBlockedByActiveItem
            注释 = "Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiHoveredFlags_AllowWhenOverlapped
            注释 = "仅限\"项目可有悬停\": Return true even if the position is obstructed or overlapped by another window">
    常量 "" <公开 类型 = 整数 值 = @ImGuiHoveredFlags_AllowWhenDisabled
            注释 = "仅限\"项目可有悬停\": Return true even if the item is disabled">
    常量 "" <公开 类型 = 整数 值 = @ImGuiHoveredFlags_NoNavOverride
            注释 = "仅限\"项目可有悬停\": only: Disable using gamepad/keyboard navigation state when active, always query mouse">
    常量 "" <公开 类型 = 整数 值 = @ImGuiHoveredFlags_RectOnly
            注释 = "ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped">
    常量 根和子窗口 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_RootAndChildWindows 注释 = "连续位或 (根窗口, 子窗口)">
    常量 "" <类型 = 整数 值 = @ImGuiHoveredFlags_ForTooltip
            注释 = "Shortcut for standard flags when using IsItemHovered() + SetTooltip() sequence.">
    常量 "" <类型 = 整数 值 = @ImGuiHoveredFlags_Stationary
            注释 = "Require mouse to be stationary for style.HoverStationaryDelay (~0.15 sec) _at least one time_."
            注释 = "After this, can move on same item/window. Using the stationary test tends to reduces the need for a long delay.">
    常量 无延迟 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_DelayNone 注释 = "仅限\"工具提示\": 立即返回真(默认),因为它是默认的,你可以忽略它.">
    常量 正常延迟 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_DelayNormal
            注释 = "仅限\"工具提示\": 经过 io.HoverDelayNormal (约0.30秒)的时间后返回真">
    常量 快速延迟 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_DelayShort
            注释 = "仅限\"工具提示\": 经过 io.HoverDelayShort  (约0.10秒)的时间后返回真">
    常量 禁止共用延迟 <公开 类型 = 整数 值 = @ImGuiHoveredFlags_NoSharedDelay
            注释 = "仅限\"工具提示\": 禁止共用延迟系统(即从一个项目移动到另一个项目,会继续使用之前的计时,以缩短延迟时间.这是长延迟工具提示的标准设置.)">
}

类 IM停靠节点标志 <公开 注释 = "ImGuiDockNodeFlags" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_None>
    常量 "" <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_KeepAliveOnly
            注释 = "Don\'t display the dockspace node but keep it alive. Windows docked into this dockspace node won\'t be undocked.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_NoDockingInCentralNode
            注释 = "Disable docking inside the Central Node, which will be always kept empty.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_PassthruCentralNode 注释 = "Enable passthru dockspace:"
            注释 = "1) DockSpace() will render a ImGuiCol_WindowBg background covering everything excepted the Central Node when empty."
            注释 = "Meaning the host window should probably use SetNextWindowBgAlpha(0.0f) prior to Begin() when using this."
            注释 = "2) When Central Node is empty: let inputs pass-through + won\'t display a DockingEmptyBg background. See demo for details.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_NoSplit 注释 = "Disable splitting the node into smaller nodes."
            注释 = "Useful e.g. when embedding dockspaces into a main root one (the root one may have splitting disabled to reduce confusion)."
            注释 = "Note: when turned off, existing splits will be preserved.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_NoResize
            注释 = "Disable resizing node using the splitter/separators. Useful with programmatically setup dockspaces.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDockNodeFlags_AutoHideTabBar
            注释 = "Tab bar will automatically hide when there is a single window in the dock node.">

    #
}

类 IM拖放标志 <公开
        注释 = "ImGuiDragDropFlags Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()" 折叠
        @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiDragDropFlags_None>
    常量 "" <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceNoPreviewTooltip
            注释 = "Disable preview tooltip. By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents."
            注释 = "This flag disables this behavior.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceNoDisableHover
            注释 = "By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips."
            注释 = "This flag disables this behavior so you can still call IsItemHovered() on the source item.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceNoHoldToOpenOthers
            注释 = "Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceAllowNullID
            注释 = "Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position."
            注释 = "This is extremely unusual within the dear imgui ecosystem and so we made it explicit.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceExtern
            注释 = "External source (from outside of dear imgui), won\'t attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDragDropFlags_SourceAutoExpirePayload
            注释 = "Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDragDropFlags_AcceptBeforeDelivery
            注释 = "AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDragDropFlags_AcceptNoDrawDefaultRect
            注释 = "Do not draw the default highlight rectangle when hovering over target.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDragDropFlags_AcceptNoPreviewTooltip
            注释 = "Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiDragDropFlags_AcceptPeekOnly
            注释 = "For peeking ahead and inspecting the payload before delivery.">
}

类 IM配置标志 <公开
        注释 = "ImGuiConfigFlags Configuration flags stored in io.ConfigFlags. Set by user/application."
        注释 = "" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiConfigFlags_None>
    常量 键盘导航 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NavEnableKeyboard
            注释 = "Master keyboard navigation enable flag. Enable full Tabbing + directional arrows + space/enter to activate.">
    常量 游戏手柄导航 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NavEnableGamepad
            注释 = "Master gamepad navigation enable flag. Backend also needs to set ImGuiBackendFlags_HasGamepad.">
    常量 导航移动鼠标位置 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NavEnableSetMousePos
            注释 = "Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward."
            注释 = "Will update io.MousePos and set io.WantSetMousePos=true."
            注释 = "If enabled you MUST honor io.WantSetMousePos requests in your backend, otherwise ImGui will react as if the mouse is jumping around back and forth.">
    常量 不捕获键盘 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NavNoCaptureKeyboard
            注释 = "Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.">
    常量 无鼠标 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NoMouse
            注释 = "Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the backend.">
    常量 不改变鼠标光标 <公开 类型 = 整数 值 = @ImGuiConfigFlags_NoMouseCursorChange
            注释 = "Instruct backend to not alter mouse cursor shape and visibility. Use if the backend cursor changes are interfering with yours and you don\'t want to use SetMouseCursor() to change mouse cursor."
            注释 = "You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.">
    常量 启用停靠 <公开 类型 = 整数 值 = @ImGuiConfigFlags_DockingEnable 注释 = "Docking enable flags.">
    常量 启用视口 <公开 类型 = 整数 值 = @ImGuiConfigFlags_ViewportsEnable
            注释 = "Viewport enable flags (require both ImGuiBackendFlags_PlatformHasViewports + ImGuiBackendFlags_RendererHasViewports set by the respective backends)">
    常量 SRGB颜色 <公开 类型 = 整数 值 = @ImGuiConfigFlags_IsSRGB 注释 = "Application is SRGB-aware.">
    常量 触控屏 <公开 类型 = 整数 值 = @ImGuiConfigFlags_IsTouchScreen
            注释 = "Application is using a touch screen instead of a mouse.">
}

类 IM后端标志 <公开
        注释 = "ImGuiBackendFlags Backend capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom backend."
        注释 = "" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiBackendFlags_None>
    常量 支持游戏手柄 <公开 类型 = 整数 值 = @ImGuiBackendFlags_HasGamepad
            注释 = "Backend Platform supports gamepad and currently has one connected.">
    常量 支持鼠标光标 <公开 类型 = 整数 值 = @ImGuiBackendFlags_HasMouseCursors
            注释 = "Backend Platform supports honoring GetMouseCursor() value to change the OS cursor shape.">
    常量 支持设置鼠标位置 <公开 类型 = 整数 值 = @ImGuiBackendFlags_HasSetMousePos
            注释 = "Backend Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).">
    常量 渲染器支持VTX偏移 <公开 类型 = 整数 值 = @ImGuiBackendFlags_RendererHasVtxOffset
            注释 = "Backend Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bit indices.">
    常量 平台支持视口 <公开 类型 = 整数 值 = @ImGuiBackendFlags_PlatformHasViewports
            注释 = "Backend Platform supports multiple viewports.">
    常量 视口接受鼠标悬停 <公开 类型 = 整数 值 = @ImGuiBackendFlags_HasMouseHoveredViewport
            注释 = "Backend Platform supports calling io.AddMouseViewportEvent() with the viewport under the mouse. IF POSSIBLE, ignore viewports with the ImGuiViewportFlags_NoInputs flag (Win32 backend, GLFW 3.30+ backend can do this, SDL backend cannot). If this cannot be done, Dear ImGui needs to use a flawed heuristic to find the viewport under.">
    常量 渲染器支持视口 <公开 类型 = 整数 值 = @ImGuiBackendFlags_RendererHasViewports
            注释 = "Backend Renderer supports multiple viewports.">
}

类 IM按钮标志 <公开 注释 = "ImGuiButtonFlags Flags for InvisibleButton() [extended in imgui_internal.h]" 折叠
        @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiButtonFlags_None>
    常量 鼠标左键 <公开 类型 = 整数 值 = @ImGuiButtonFlags_MouseButtonLeft 注释 = "响应鼠标左键(默认值)">
    常量 鼠标右键 <公开 类型 = 整数 值 = @ImGuiButtonFlags_MouseButtonRight 注释 = "响应鼠标右键">
    常量 鼠标中键 <公开 类型 = 整数 值 = @ImGuiButtonFlags_MouseButtonMiddle 注释 = "响应鼠标中键">
    常量 鼠标按键掩码_ <公开 类型 = 整数 值 = @ImGuiButtonFlags_MouseButtonMask_ 注释 = "连续位或 (鼠标左键, 鼠标右键, 鼠标中键)">
    常量 默认鼠标按键_ <公开 类型 = 整数 值 = @ImGuiButtonFlags_MouseButtonDefault_ 注释 = "等于\"鼠标左键\"">
}

类 IM颜色编辑标志 <公开
        注释 = "ImGuiColorEditFlags Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()"
        折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_None>
    常量 无透明分量 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoAlpha
            注释 = "ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).">
    常量 无选取器 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoPicker
            注释 = "ColorEdit: disable picker when clicking on color square.">
    常量 无选项菜单 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoOptions
            注释 = "ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoSmallPreview
            注释 = "ColorEdit, ColorPicker: disable color square preview next to the inputs. (e.g. to show only the inputs)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoInputs
            注释 = "ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview color square).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoTooltip
            注释 = "ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoLabel
            注释 = "ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoSidePreview
            注释 = "ColorPicker: disable bigger color preview on right side of the picker, use small color square preview instead.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoDragDrop
            注释 = "ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_NoBorder
            注释 = "ColorButton: disable border (which is enforced by default)">
    常量 ""
    常量 显示透明条 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_AlphaBar
            注释 = "ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.">
    常量 透明预览 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_AlphaPreview
            注释 = "ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.">
    常量 半透明预览 <公开 类型 = 整数 值 = @ImGuiColorEditFlags_AlphaPreviewHalf
            注释 = "ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_HDR
            注释 = "(WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DisplayRGB
            注释 = "ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DisplayHSV>
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DisplayHex>
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_Uint8
            注释 = "ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_Float
            注释 = "ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_PickerHueBar
            注释 = "ColorPicker: bar for Hue, rectangle for Sat/Value.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_PickerHueWheel
            注释 = "ColorPicker: wheel for Hue, triangle for Sat/Value.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_InputRGB
            注释 = "ColorEdit, ColorPicker: input and output data in RGB format.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_InputHSV
            注释 = "ColorEdit, ColorPicker: input and output data in HSV format.">
    常量 ""
    常量 默认选项_ <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DefaultOptions_
            注释 = "ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_PickerHueBar"
            注释 = "Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don\'t want to"
            注释 = "override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DisplayMask_
            注释 = "ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_DisplayHex">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_DataTypeMask_
            注释 = "ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_Float">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_PickerMask_
            注释 = "ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_PickerHueBar">
    常量 "" <公开 类型 = 整数 值 = @ImGuiColorEditFlags_InputMask_
            注释 = "ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_InputHSV">
}

类 IM滑块标志 <公开 注释 = "\"××拖动框\"和\"××滑块\"组件的标志[ImGuiSliderFlags]." 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiSliderFlags_None>
    常量 始终限制范围 <公开 类型 = 整数 值 = @ImGuiSliderFlags_AlwaysClamp
            注释 = "使用Ctrl+单击手动输入时,始终将值限制在\"最小值~最大值\"的范围内.默认情况下,手动输入值允许越界.">
    常量 对数 <公开 类型 = 整数 值 = @ImGuiSliderFlags_Logarithmic
            注释 = "Make the widget logarithmic (linear otherwise). Consider using ImGuiSliderFlags_NoRoundToFormat with this if using a format-string with small amount of digits.">
    常量 不舍弃精度 <公开 类型 = 整数 值 = @ImGuiSliderFlags_NoRoundToFormat
            注释 = "禁用舍入基础值以匹配显示格式文本的精度(例如\"%.3f\"会将值四舍五入到小数点后3位)">
    常量 禁止输入 <公开 类型 = 整数 值 = @ImGuiSliderFlags_NoInput 注释 = "禁止使用Ctrl+单击、双击、回车键来直接输入数值到组件中">
}

类 IM视口标志 <公开 注释 = "ImGuiViewportFlags" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImGuiViewportFlags_None>
    常量 平台窗口 <公开 类型 = 整数 值 = @ImGuiViewportFlags_IsPlatformWindow 注释 = "显示一个平台窗口">
    常量 平台显示器 <公开 类型 = 整数 值 = @ImGuiViewportFlags_IsPlatformMonitor 注释 = "显示一个平台显示器,目前未使用">
    常量 属于应用程序 <公开 类型 = 整数 值 = @ImGuiViewportFlags_OwnedByApp 注释 = "平台窗口：由应用程序创建和管理,而不是一个ImGui后端."
            注释 = "Platform Window: Was created/managed by the user application? (rather than our backend)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoDecoration
            注释 = "Platform Window: Disable platform decorations: title bar, borders, etc. (generally set all windows, but if ImGuiConfigFlags_ViewportsDecoration is set we only set this on popups/tooltips)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoTaskBarIcon
            注释 = "Platform Window: Disable platform task bar icon (generally set on popups/tooltips, or all windows if ImGuiConfigFlags_ViewportsNoTaskBarIcon is set)">
    常量 "" <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoFocusOnAppearing
            注释 = "Platform Window: Don\'t take focus when created.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoFocusOnClick
            注释 = "Platform Window: Don\'t take focus when clicked on.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoInputs
            注释 = "Platform Window: Make mouse pass through so we can drag this window while peaking behind it.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoRendererClear
            注释 = "Platform Window: Renderer doesn\'t need to clear the framebuffer ahead (because we will fill it entirely).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiViewportFlags_NoAutoMerge
            注释 = "Platform Window: Avoid merging this window into another host window."
            注释 = "This can only be set via ImGuiWindowClass viewport flags override (because we need to now ahead if we are going to create a viewport in the first place!).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiViewportFlags_TopMost
            注释 = "Platform Window: Display on top (for tooltips only).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiViewportFlags_CanHostOtherWindows
            注释 = "Viewport can host multiple imgui windows (secondary viewports are associated to a single window)."
            注释 = "// FIXME: In practice there\'s still probably code making the assumption that this is always and only on the MainViewport. Will fix once we add support for \"no main viewport\".">
    常量 "" <公开 类型 = 整数 值 = @ImGuiViewportFlags_IsMinimized
            注释 = "Platform Window: Window is minimized, can skip render."
            注释 = "When minimized we tend to avoid using the viewport pos/size for clipping window or testing if they are contained in the viewport.">
    常量 "" <公开 类型 = 整数 值 = @ImGuiViewportFlags_IsFocused
            注释 = "Platform Window: Window is focused (last call to Platform_GetWindowFocus() returned true)">
}

类 IM绘制标志 <公开 注释 = "ImDrawFlags" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImDrawFlags_None>
    常量 "" <公开 类型 = 整数 值 = @ImDrawFlags_Closed
            注释 = "PathStroke(), AddPolyline(): specify that shape should be closed (Important: this is always == 1 for legacy reason)">
    常量 "" <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersTopLeft
            注释 = "AddRect(), AddRectFilled(), PathRect(): enable rounding top-left corner only (when rounding > 0.0f, we default to all corners). Was 0x01.">
    常量 "" <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersTopRight
            注释 = "AddRect(), AddRectFilled(), PathRect(): enable rounding top-right corner only (when rounding > 0.0f, we default to all corners). Was 0x02.">
    常量 "" <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersBottomLeft
            注释 = "AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-left corner only (when rounding > 0.0f, we default to all corners). Was 0x04.">
    常量 "" <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersBottomRight
            注释 = "AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-right corner only (when rounding > 0.0f, we default to all corners). Wax 0x08.">
    常量 "" <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersNone
            注释 = "AddRect(), AddRectFilled(), PathRect(): disable rounding on all corners (when rounding > 0.0f). This is NOT zero, NOT an implicit flag!">
    常量 "" <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersTop
            注释 = "ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight">
    常量 "" <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersBottom
            注释 = "ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight">
    常量 "" <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersLeft
            注释 = "ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersTopLeft">
    常量 "" <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersRight
            注释 = "ImDrawFlags_RoundCornersBottomRight | ImDrawFlags_RoundCornersTopRight">
    常量 "" <公开 类型 = 整数 值 = @ImDrawFlags_RoundCornersAll
            注释 = "ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight | ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight">
}

类 IM绘制列表标志 <公开 注释 = "ImDrawListFlags" 折叠 @文档 = "category = \"标志类\"">
{
    常量 无 <公开 类型 = 整数 值 = @ImDrawListFlags_None>
    常量 抗锯齿线条 <公开 类型 = 整数 值 = @ImDrawListFlags_AntiAliasedLines 注释 = "启用线条和边线的抗锯齿">
    常量 纹理抗锯齿线条 <公开 类型 = 整数 值 = @ImDrawListFlags_AntiAliasedLinesUseTex
            注释 = "尽可能使用纹理启用线条和边线的抗锯齿,要求后端使用双线性过滤进行渲染.">
    常量 抗锯齿填充 <公开 类型 = 整数 值 = @ImDrawListFlags_AntiAliasedFill 注释 = "启用填充形状(圆角矩形、圆形)周围边缘的抗锯齿.">
    常量 允许VTX偏移 <公开 类型 = 整数 值 = @ImDrawListFlags_AllowVtxOffset
            注释 = "Can emit \'VtxOffset > 0\' to allow large meshes. Set when \'ImGuiBackendFlags_RendererHasVtxOffset\' is enabled.">
}

# 枚举常量

类 IM字形范围 <公开 注释 = "用于获取常用的Unicode范围列表(每个范围2个值,包含值的以零结尾列表)" 折叠 @文档 = "category = \"常量类\"" @常量类 = 文本型>
{
    常量 默认 <公开 值 = "GetGlyphRangesDefault" 注释 = "基本拉丁文 + 扩展拉丁文">
    常量 希腊文 <公开 值 = "GetGlyphRangesGreek" 注释 = "默认 + 希腊文 + 科普特文">
    常量 韓文 <公开 值 = "GetGlyphRangesKorean" 注释 = "默认 + 韓文">
    常量 日文 <公开 值 = "GetGlyphRangesJapanese" 注释 = "默认 + 平假名、平假名、半角字符、2999字的常用汉字表">
    常量 中文 <公开 值 = "GetGlyphRangesChineseFull" 注释 = "默认 + 半角字符 + 日文平假名/平假名 + 约21000字的完整中日韩统一表意文字">
    常量 简体中文 <公开 值 = "GetGlyphRangesChineseSimplifiedCommon"
            注释 = "默认 + 半角字符 + 日文平假名/平假名 + 2500字的中日韩统一表意文字(简体中文)">
    常量 西里尔文 <公开 值 = "GetGlyphRangesCyrillic" 注释 = "默认 + 大约400字的西里尔文字符">
    常量 泰文 <公开 值 = "GetGlyphRangesThai" 注释 = "默认 + 泰文字符">
    常量 越南文 <公开 值 = "GetGlyphRangesVietnamese" 注释 = "默认 + 越南文字符">
}

类 IM表格背景目标 <公开 注释 = "ImGuiTableBgTarget Enum for ImGui::TableSetBgColor()" 折叠
        @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 无 <公开 值 = @ImGuiTableBgTarget_None>
    常量 行背景颜色0 <公开 值 = @ImGuiTableBgTarget_RowBg0
            注释 = "设置行背景颜色0(通常用于行背景,使用\"ImGuiTableFlags_RowBg\"时自动设置本标志)">
    常量 行背景颜色1 <公开 值 = @ImGuiTableBgTarget_RowBg1 注释 = "设置行背景颜色1(通常用于被选中项)">
    常量 单元格背景颜色 <公开 值 = @ImGuiTableBgTarget_CellBg 注释 = "设置单元格的背景颜色(最顶层的颜色)">
}

类 IM排序方向 <公开 注释 = "ImGuiSortDirection" 折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 无 <公开 值 = @ImGuiSortDirection_None>
    常量 升序 <公开 值 = @ImGuiSortDirection_Ascending 注释 = "升序 = 0->9, A->Z etc.">
    常量 降序 <公开 值 = @ImGuiSortDirection_Descending 注释 = "降序 = 9->0, Z->A etc.">
}

类 IM按键码 <公开 注释 = "ImGuiKey" 折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 无 <公开 值 = @ImGuiKey_None>
    常量 Tab键 <公开 值 = @ImGuiKey_Tab>
    常量 左光标键 <公开 值 = @ImGuiKey_LeftArrow 注释 = "左箭头">
    常量 右光标键 <公开 值 = @ImGuiKey_RightArrow 注释 = "右箭头">
    常量 上光标键 <公开 值 = @ImGuiKey_UpArrow 注释 = "上箭头">
    常量 下光标键 <公开 值 = @ImGuiKey_DownArrow 注释 = "下箭头">
    常量 PageUp键 <公开 值 = @ImGuiKey_PageUp 注释 = "上翻页">
    常量 PageDown键 <公开 值 = @ImGuiKey_PageDown 注释 = "下翻页">
    常量 Home键 <公开 值 = @ImGuiKey_Home>
    常量 End键 <公开 值 = @ImGuiKey_End>
    常量 插入键 <公开 值 = @ImGuiKey_Insert 注释 = "Insert">
    常量 删除键 <公开 值 = @ImGuiKey_Delete 注释 = "Delete">
    常量 退格键 <公开 值 = @ImGuiKey_Backspace 注释 = "Backspace">
    常量 空格键 <公开 值 = @ImGuiKey_Space 注释 = "Space">
    常量 回车键 <公开 值 = @ImGuiKey_Enter 注释 = "Enter">
    常量 Esc键 <公开 值 = @ImGuiKey_Escape 注释 = "Escape">
    常量 左Ctrl键 <公开 值 = @ImGuiKey_LeftCtrl>
    常量 左Shift键 <公开 值 = @ImGuiKey_LeftShift>
    常量 左Alt键 <公开 值 = @ImGuiKey_LeftAlt>
    常量 左徽标键 <公开 值 = @ImGuiKey_LeftSuper 注释 = "Win键">
    常量 右Ctrl键 <公开 值 = @ImGuiKey_RightCtrl>
    常量 右Shift键 <公开 值 = @ImGuiKey_RightShift>
    常量 右Alt键 <公开 值 = @ImGuiKey_RightAlt>
    常量 右徽标键 <公开 值 = @ImGuiKey_RightSuper>
    常量 菜单键 <公开 值 = @ImGuiKey_Menu>
    常量 数字0键 <公开 值 = @ImGuiKey_0>
    常量 数字1键 <公开 值 = @ImGuiKey_1>
    常量 数字2键 <公开 值 = @ImGuiKey_2>
    常量 数字3键 <公开 值 = @ImGuiKey_3>
    常量 数字4键 <公开 值 = @ImGuiKey_4>
    常量 数字5键 <公开 值 = @ImGuiKey_5>
    常量 数字6键 <公开 值 = @ImGuiKey_6>
    常量 数字7键 <公开 值 = @ImGuiKey_7>
    常量 数字8键 <公开 值 = @ImGuiKey_8>
    常量 数字9键 <公开 值 = @ImGuiKey_9>
    常量 A键 <公开 值 = @ImGuiKey_A>
    常量 B键 <公开 值 = @ImGuiKey_B>
    常量 C键 <公开 值 = @ImGuiKey_C>
    常量 D键 <公开 值 = @ImGuiKey_D>
    常量 E键 <公开 值 = @ImGuiKey_E>
    常量 F键 <公开 值 = @ImGuiKey_F>
    常量 G键 <公开 值 = @ImGuiKey_G>
    常量 H键 <公开 值 = @ImGuiKey_H>
    常量 I键 <公开 值 = @ImGuiKey_I>
    常量 J键 <公开 值 = @ImGuiKey_J>
    常量 K键 <公开 值 = @ImGuiKey_K>
    常量 L键 <公开 值 = @ImGuiKey_L>
    常量 M键 <公开 值 = @ImGuiKey_M>
    常量 N键 <公开 值 = @ImGuiKey_N>
    常量 O键 <公开 值 = @ImGuiKey_O>
    常量 P键 <公开 值 = @ImGuiKey_P>
    常量 Q键 <公开 值 = @ImGuiKey_Q>
    常量 R键 <公开 值 = @ImGuiKey_R>
    常量 S键 <公开 值 = @ImGuiKey_S>
    常量 T键 <公开 值 = @ImGuiKey_T>
    常量 U键 <公开 值 = @ImGuiKey_U>
    常量 V键 <公开 值 = @ImGuiKey_V>
    常量 W键 <公开 值 = @ImGuiKey_W>
    常量 X键 <公开 值 = @ImGuiKey_X>
    常量 Y键 <公开 值 = @ImGuiKey_Y>
    常量 Z键 <公开 值 = @ImGuiKey_Z>
    常量 F1键 <公开 值 = @ImGuiKey_F1>
    常量 F2键 <公开 值 = @ImGuiKey_F2>
    常量 F3键 <公开 值 = @ImGuiKey_F3>
    常量 F4键 <公开 值 = @ImGuiKey_F4>
    常量 F5键 <公开 值 = @ImGuiKey_F5>
    常量 F6键 <公开 值 = @ImGuiKey_F6>
    常量 F7键 <公开 值 = @ImGuiKey_F7>
    常量 F8键 <公开 值 = @ImGuiKey_F8>
    常量 F9键 <公开 值 = @ImGuiKey_F9>
    常量 F10键 <公开 值 = @ImGuiKey_F10>
    常量 F11键 <公开 值 = @ImGuiKey_F11>
    常量 F12键 <公开 值 = @ImGuiKey_F12>
    常量 撇号键 <公开 值 = @ImGuiKey_Apostrophe 注释 = "单引号 \'">
    常量 逗号键 <公开 值 = @ImGuiKey_Comma 注释 = ",">
    常量 减号键 <公开 值 = @ImGuiKey_Minus 注释 = "-">
    常量 句号键 <公开 值 = @ImGuiKey_Period 注释 = ".">
    常量 斜杠键 <公开 值 = @ImGuiKey_Slash 注释 = "/">
    常量 分号键 <公开 值 = @ImGuiKey_Semicolon 注释 = ";">
    常量 等号键 <公开 值 = @ImGuiKey_Equal 注释 = "=">
    常量 左中括号键 <公开 值 = @ImGuiKey_LeftBracket 注释 = "[">
    常量 反斜杠键 <公开 值 = @ImGuiKey_Backslash 注释 = "\\ (this text inhibit multiline comment caused by backslash)">
    常量 右中括号键 <公开 值 = @ImGuiKey_RightBracket 注释 = "]">
    常量 反撇号键 <公开 值 = @ImGuiKey_GraveAccent 注释 = "`">
    常量 大写锁定键 <公开 值 = @ImGuiKey_CapsLock 注释 = "CapsLock">
    常量 滚动锁定键 <公开 值 = @ImGuiKey_ScrollLock 注释 = "ScrollLock">
    常量 数字锁定键 <公开 值 = @ImGuiKey_NumLock 注释 = "NumLock">
    常量 截屏键 <公开 值 = @ImGuiKey_PrintScreen 注释 = "PrintScreen">
    常量 暂停键 <公开 值 = @ImGuiKey_Pause 注释 = "Pause">
    常量 小键盘0键 <公开 值 = @ImGuiKey_Keypad0>
    常量 小键盘1键 <公开 值 = @ImGuiKey_Keypad1>
    常量 小键盘2键 <公开 值 = @ImGuiKey_Keypad2>
    常量 小键盘3键 <公开 值 = @ImGuiKey_Keypad3>
    常量 小键盘4键 <公开 值 = @ImGuiKey_Keypad4>
    常量 小键盘5键 <公开 值 = @ImGuiKey_Keypad5>
    常量 小键盘6键 <公开 值 = @ImGuiKey_Keypad6>
    常量 小键盘7键 <公开 值 = @ImGuiKey_Keypad7>
    常量 小键盘8键 <公开 值 = @ImGuiKey_Keypad8>
    常量 小键盘9键 <公开 值 = @ImGuiKey_Keypad9>
    常量 小键盘小数点键 <公开 值 = @ImGuiKey_KeypadDecimal>
    常量 小键盘除号键 <公开 值 = @ImGuiKey_KeypadDivide>
    常量 小键盘乘号键 <公开 值 = @ImGuiKey_KeypadMultiply>
    常量 小键盘减号键 <公开 值 = @ImGuiKey_KeypadSubtract>
    常量 小键盘加号键 <公开 值 = @ImGuiKey_KeypadAdd>
    常量 小键盘回车键 <公开 值 = @ImGuiKey_KeypadEnter>
    常量 小键盘等号键 <公开 值 = @ImGuiKey_KeypadEqual>
    常量 ""
    常量 手柄开始键 <公开 值 = @ImGuiKey_GamepadStart 注释 = "Menu (Xbox)      + (Switch)   Start/Options (PS)">
    常量 手柄返回键 <公开 值 = @ImGuiKey_GamepadBack 注释 = "View (Xbox)      - (Switch)   Share (PS)">
    常量 "" <公开 值 = @ImGuiKey_GamepadFaceLeft 注释 = "X (Xbox)         Y (Switch)   Square (PS)">
    常量 "" <公开 值 = @ImGuiKey_GamepadFaceRight 注释 = "B (Xbox)         A (Switch)   Circle (PS)">
    常量 "" <公开 值 = @ImGuiKey_GamepadFaceUp 注释 = "Y (Xbox)         X (Switch)   Triangle (PS)">
    常量 "" <公开 值 = @ImGuiKey_GamepadFaceDown 注释 = "A (Xbox)         B (Switch)   Cross (PS)">
    常量 手柄向左键 <公开 值 = @ImGuiKey_GamepadDpadLeft 注释 = "D-pad Left">
    常量 手柄向右键 <公开 值 = @ImGuiKey_GamepadDpadRight 注释 = "D-pad Right">
    常量 手柄向上键 <公开 值 = @ImGuiKey_GamepadDpadUp 注释 = "D-pad Up">
    常量 手柄向下键 <公开 值 = @ImGuiKey_GamepadDpadDown 注释 = "D-pad Down">
    常量 手柄L1键 <公开 值 = @ImGuiKey_GamepadL1 注释 = "L Bumper (Xbox)  L (Switch)   L1 (PS)">
    常量 手柄R1键 <公开 值 = @ImGuiKey_GamepadR1 注释 = "R Bumper (Xbox)  R (Switch)   R1 (PS)">
    常量 手柄L2键 <公开 值 = @ImGuiKey_GamepadL2 注释 = "L Trig. (Xbox)   ZL (Switch)  L2 (PS) [模拟]">
    常量 手柄R2键 <公开 值 = @ImGuiKey_GamepadR2 注释 = "R Trig. (Xbox)   ZR (Switch)  R2 (PS) [模拟]">
    常量 手柄L3键 <公开 值 = @ImGuiKey_GamepadL3 注释 = "L Stick (Xbox)   L3 (Switch)  L3 (PS)">
    常量 手柄R3键 <公开 值 = @ImGuiKey_GamepadR3 注释 = "R Stick (Xbox)   R3 (Switch)  R3 (PS)">
    常量 "" <公开 值 = @ImGuiKey_GamepadLStickLeft 注释 = "[模拟]">
    常量 "" <公开 值 = @ImGuiKey_GamepadLStickRight 注释 = "[模拟]">
    常量 "" <公开 值 = @ImGuiKey_GamepadLStickUp 注释 = "[模拟]">
    常量 "" <公开 值 = @ImGuiKey_GamepadLStickDown 注释 = "[模拟]">
    常量 "" <公开 值 = @ImGuiKey_GamepadRStickLeft 注释 = "[模拟]">
    常量 "" <公开 值 = @ImGuiKey_GamepadRStickRight 注释 = "[模拟]">
    常量 "" <公开 值 = @ImGuiKey_GamepadRStickUp 注释 = "[模拟]">
    常量 "" <公开 值 = @ImGuiKey_GamepadRStickDown 注释 = "[模拟]">
    常量 ""
    常量 鼠标左键 <公开 值 = @ImGuiKey_MouseLeft>
    常量 鼠标右键 <公开 值 = @ImGuiKey_MouseRight>
    常量 鼠标中键 <公开 值 = @ImGuiKey_MouseMiddle>
    常量 "" <公开 值 = @ImGuiKey_MouseX1>
    常量 "" <公开 值 = @ImGuiKey_MouseX2>
    常量 "" <公开 值 = @ImGuiKey_MouseWheelX>
    常量 "" <公开 值 = @ImGuiKey_MouseWheelY>
    常量 ""
    常量 "" <公开 值 = @ImGuiKey_ReservedForModCtrl>
    常量 "" <公开 值 = @ImGuiKey_ReservedForModShift>
    常量 "" <公开 值 = @ImGuiKey_ReservedForModAlt>
    常量 "" <公开 值 = @ImGuiKey_ReservedForModSuper>
    常量 "" <公开 值 = @ImGuiKey_COUNT>
    常量 ""
    常量 Ctrl键 <公开 值 = @ImGuiMod_Ctrl 注释 = "Ctrl">
    常量 Shift键 <公开 值 = @ImGuiMod_Shift 注释 = "Shift">
    常量 Alt键 <公开 值 = @ImGuiMod_Alt 注释 = "Option/Menu">
    常量 徽标键 <公开 值 = @ImGuiMod_Super 注释 = "Cmd/Super/Windows">
    常量 "" <公开 值 = @ImGuiMod_Shortcut 注释 = "Alias for Ctrl (non-macOS) _or_ Super (macOS).">
    常量 "" <公开 类型 = 整数 值 = @ImGuiMod_Mask_ 注释 = "5-bits">
}

类 IM颜色标识符 <公开 注释 = "样式的颜色标识符 ImGuiCol" 折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 文本 <公开 值 = @ImGuiCol_Text>
    常量 文本_已禁用 <公开 值 = @ImGuiCol_TextDisabled>
    常量 窗口背景 <公开 值 = @ImGuiCol_WindowBg 注释 = "常规窗口的背景颜色">
    常量 子窗口背景 <公开 值 = @ImGuiCol_ChildBg 注释 = "子窗口的背景颜色">
    常量 弹出项背景 <公开 值 = @ImGuiCol_PopupBg 注释 = "弹出项、菜单、工具提示窗口的背景颜色">
    常量 边框 <公开 值 = @ImGuiCol_Border>
    常量 边框阴影 <公开 值 = @ImGuiCol_BorderShadow>
    常量 边框背景 <公开 值 = @ImGuiCol_FrameBg 注释 = "复选框、单选按钮、绘图区、滑块、文本输入的背景颜色">
    常量 边框背景_悬停 <公开 值 = @ImGuiCol_FrameBgHovered>
    常量 边框背景_活动 <公开 值 = @ImGuiCol_FrameBgActive>
    常量 标题背景 <公开 值 = @ImGuiCol_TitleBg>
    常量 标题背景_活动 <公开 值 = @ImGuiCol_TitleBgActive>
    常量 标题背景_已折叠 <公开 值 = @ImGuiCol_TitleBgCollapsed>
    常量 菜单栏背景 <公开 值 = @ImGuiCol_MenuBarBg>
    常量 滚动条背景 <公开 值 = @ImGuiCol_ScrollbarBg>
    常量 滚动条手柄 <公开 值 = @ImGuiCol_ScrollbarGrab>
    常量 滚动条手柄_悬停 <公开 值 = @ImGuiCol_ScrollbarGrabHovered>
    常量 滚动条手柄_活动 <公开 值 = @ImGuiCol_ScrollbarGrabActive>
    常量 选中标记 <公开 值 = @ImGuiCol_CheckMark>
    常量 滑块手柄 <公开 值 = @ImGuiCol_SliderGrab>
    常量 滑块手柄_活动 <公开 值 = @ImGuiCol_SliderGrabActive>
    常量 按钮 <公开 值 = @ImGuiCol_Button>
    常量 按钮_悬停 <公开 值 = @ImGuiCol_ButtonHovered>
    常量 按钮_活动 <公开 值 = @ImGuiCol_ButtonActive>
    常量 标题 <公开 值 = @ImGuiCol_Header 注释 = "标题颜色用于折叠标题、数节点、可选项、菜单项">
    常量 标题_悬停 <公开 值 = @ImGuiCol_HeaderHovered>
    常量 标题_活动 <公开 值 = @ImGuiCol_HeaderActive>
    常量 分隔条 <公开 值 = @ImGuiCol_Separator>
    常量 分隔条_悬停 <公开 值 = @ImGuiCol_SeparatorHovered>
    常量 分隔条_活动 <公开 值 = @ImGuiCol_SeparatorActive>
    常量 调整大小手柄 <公开 值 = @ImGuiCol_ResizeGrip 注释 = "窗口右下角和左下角的调整大小手柄">
    常量 调整大小手柄_悬停 <公开 值 = @ImGuiCol_ResizeGripHovered>
    常量 调整大小手柄_活动 <公开 值 = @ImGuiCol_ResizeGripActive>
    常量 选项卡 <公开 值 = @ImGuiCol_Tab 注释 = "选项卡栏的选项卡">
    常量 选项卡_悬停 <公开 值 = @ImGuiCol_TabHovered>
    常量 选项卡_活动 <公开 值 = @ImGuiCol_TabActive>
    常量 选项卡_失去焦点 <公开 值 = @ImGuiCol_TabUnfocused>
    常量 选项卡_失去焦点_活动 <公开 值 = @ImGuiCol_TabUnfocusedActive>
    常量 停靠_预览色 <公开 值 = @ImGuiCol_DockingPreview 注释 = "将要停靠某些内容时预览覆盖颜色">
    常量 停靠_空节点背景 <公开 值 = @ImGuiCol_DockingEmptyBg 注释 = "空节点的背景颜色(例如没有停靠窗口的节点)">
    常量 线形图 <公开 值 = @ImGuiCol_PlotLines>
    常量 线形图_悬停 <公开 值 = @ImGuiCol_PlotLinesHovered>
    常量 直方图 <公开 值 = @ImGuiCol_PlotHistogram>
    常量 直方图_悬停 <公开 值 = @ImGuiCol_PlotHistogramHovered>
    常量 表格标题背景 <公开 值 = @ImGuiCol_TableHeaderBg 注释 = "表格标题的背景颜色">
    常量 表格边框_粗 <公开 值 = @ImGuiCol_TableBorderStrong 注释 = "表格外边框和标题边框(最好使用 1.0 透明度)">
    常量 表格边框_细 <公开 值 = @ImGuiCol_TableBorderLight 注释 = "表格内边框(最好使用 1.0 透明度)">
    常量 表格偶数行背景 <公开 值 = @ImGuiCol_TableRowBg 注释 = "表格偶数行背景颜色">
    常量 表格奇数行背景 <公开 值 = @ImGuiCol_TableRowBgAlt 注释 = "表格奇数行背景颜色">
    常量 被选中文本背景 <公开 值 = @ImGuiCol_TextSelectedBg>
    常量 拖放目标 <公开 值 = @ImGuiCol_DragDropTarget 注释 = "用矩形框高亮拖放目标">
    常量 导航高亮颜色 <公开 值 = @ImGuiCol_NavHighlight 注释 = "游戏手柄/键盘: 当前突出显示的项目">
    常量 导航窗口高亮颜色 <公开 值 = @ImGuiCol_NavWindowingHighlight 注释 = "使用CTRL+TAB时突出显示窗口">
    常量 导航窗口暗背景 <公开 值 = @ImGuiCol_NavWindowingDimBg 注释 = "活动时,使CTRL+TAB窗口列表背后的整个屏幕变暗或着色">
    常量 模态窗口暗背景 <公开 值 = @ImGuiCol_ModalWindowDimBg 注释 = "当模态窗口处于活动状态时,使模态窗口后面的整个屏幕变暗或着色">
    常量 标识符数量 <公开 值 = @ImGuiCol_COUNT>
}

类 IM样式标识符 <公开
        注释 = "ImGuiStyleVar Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure."
        折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 "" <公开 值 = @ImGuiStyleVar_Alpha 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_DisabledAlpha 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_WindowPadding 注释 = "ImVec2">
    常量 "" <公开 值 = @ImGuiStyleVar_WindowRounding 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_WindowBorderSize 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_WindowMinSize 注释 = "ImVec2">
    常量 "" <公开 值 = @ImGuiStyleVar_WindowTitleAlign 注释 = "ImVec2">
    常量 "" <公开 值 = @ImGuiStyleVar_ChildRounding 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_ChildBorderSize 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_PopupRounding 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_PopupBorderSize 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_FramePadding 注释 = "ImVec2">
    常量 "" <公开 值 = @ImGuiStyleVar_FrameRounding 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_FrameBorderSize 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_ItemSpacing 注释 = "ImVec2">
    常量 "" <公开 值 = @ImGuiStyleVar_ItemInnerSpacing 注释 = "ImVec2">
    常量 "" <公开 值 = @ImGuiStyleVar_IndentSpacing 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_CellPadding 注释 = "ImVec2">
    常量 "" <公开 值 = @ImGuiStyleVar_ScrollbarSize 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_ScrollbarRounding 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_GrabMinSize 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_GrabRounding 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_TabRounding 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_ButtonTextAlign 注释 = "ImVec2">
    常量 "" <公开 值 = @ImGuiStyleVar_SelectableTextAlign 注释 = "ImVec2">
    常量 "" <公开 值 = @ImGuiStyleVar_SeparatorTextBorderSize 注释 = "float">
    常量 "" <公开 值 = @ImGuiStyleVar_SeparatorTextAlign 注释 = "ImVec2">
    常量 "" <公开 值 = @ImGuiStyleVar_SeparatorTextPadding 注释 = "ImVec2">
}

类 IM鼠标按钮 <公开 注释 = "鼠标按钮的标识符[ImGuiMouseButton]" 折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 左键 <公开 值 = @ImGuiMouseButton_Left>
    常量 右键 <公开 值 = @ImGuiMouseButton_Right>
    常量 中键 <公开 值 = @ImGuiMouseButton_Middle>
    常量 "" <公开 值 = @ImGuiMouseButton_COUNT>
}

类 IM鼠标光标 <公开 注释 = "ImGuiMouseCursor Enumeration for GetMouseCursor()" 折叠 @文档 = "category = \"常量类\""
        @常量类 = 整数>
{
    常量 无 <公开 值 = @ImGuiMouseCursor_None>
    常量 正常选择 <公开 值 = @ImGuiMouseCursor_Arrow>
    常量 文本选择 <公开 值 = @ImGuiMouseCursor_TextInput 注释 = "When hovering over InputText, etc.">
    常量 调整大小 <公开 值 = @ImGuiMouseCursor_ResizeAll 注释 = "(Unused by Dear ImGui functions)">
    常量 垂直调整大小 <公开 值 = @ImGuiMouseCursor_ResizeNS 注释 = "When hovering over a horizontal border">
    常量 水平调整大小 <公开 值 = @ImGuiMouseCursor_ResizeEW 注释 = "When hovering over a vertical border or a column">
    常量 沿对角线调整大小1 <公开 值 = @ImGuiMouseCursor_ResizeNESW
            注释 = "When hovering over the bottom-left corner of a window">
    常量 沿对角线调整大小2 <公开 值 = @ImGuiMouseCursor_ResizeNWSE
            注释 = "When hovering over the bottom-right corner of a window">
    常量 链接选择 <公开 值 = @ImGuiMouseCursor_Hand 注释 = "(Unused by Dear ImGui functions. Use for e.g. hyperlinks)">
    常量 不可用 <公开 值 = @ImGuiMouseCursor_NotAllowed
            注释 = "When hovering something with disallowed interaction. Usually a crossed circle.">
    常量 "" <公开 值 = @ImGuiMouseCursor_COUNT>
}

类 IM鼠标来源 <公开
        注释 = "ImGuiMouseSource Enumeration for AddMouseSourceEvent() actual source of Mouse Input data." 折叠
        @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 鼠标 <公开 值 = @ImGuiMouseSource_Mouse 注释 = "Input is coming from an actual mouse.">
    常量 触摸屏 <公开 值 = @ImGuiMouseSource_TouchScreen
            注释 = "Input is coming from a touch screen (no hovering prior to initial press, less precise initial press aiming, dual-axis wheeling possible).">
    常量 笔 <公开 值 = @ImGuiMouseSource_Pen
            注释 = "Input is coming from a pressure/magnetic pen (often used in conjunction with high-sampling rates).">
    常量 "" <公开 值 = @ImGuiMouseSource_COUNT>
}

类 IM执行条件 <公开
        注释 = "ImGuiCond Enumeration for ImGui::SetWindow***(), SetNextWindow***(), SetNextItem***() functions"
        折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 无 <公开 值 = @ImGuiCond_None 注释 = "无条件执行(始终设置变量),等同于\"始终执行\"">
    常量 始终执行 <公开 值 = @ImGuiCond_Always 注释 = "无条件执行(始终设置变量),等同于\"无\"">
    常量 执行一次 <公开 值 = @ImGuiCond_Once 注释 = "只在第一次调用本方法时执行">
    常量 首次使用 <公开 值 = @ImGuiCond_FirstUseEver 注释 = "仅在对象/窗口未持久化保存数据前执行,(即.ini文件中无此内容)">
    常量 首次显示 <公开 值 = @ImGuiCond_Appearing 注释 = "在对象/窗口第一次显示时执行,包括从隐藏或禁用状态重新显示">
}

类 IM数据类型 <公开 注释 = "主要数据类型 ImGuiDataType" 折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 字节型 <公开 值 = @ImGuiDataType_S8>
    常量 无符号字节 <公开 值 = @ImGuiDataType_U8>
    常量 短整数型 <公开 值 = @ImGuiDataType_S16>
    常量 无符号短整数 <公开 值 = @ImGuiDataType_U16>
    常量 整数型 <公开 值 = @ImGuiDataType_S32>
    常量 无符号整数 <公开 值 = @ImGuiDataType_U32>
    常量 长整数型 <公开 值 = @ImGuiDataType_S64>
    常量 无符号长整数 <公开 值 = @ImGuiDataType_U64>
    常量 单精度浮点数 <公开 值 = @ImGuiDataType_Float>
    常量 双精度浮点数 <公开 值 = @ImGuiDataType_Double>
}

类 IM基本方向 <公开 注释 = "ImGuiDir" 折叠 @文档 = "category = \"常量类\"" @常量类 = 整数>
{
    常量 无 <公开 值 = @ImGuiDir_None>
    常量 向左 <公开 值 = @ImGuiDir_Left>
    常量 向右 <公开 值 = @ImGuiDir_Right>
    常量 向上 <公开 值 = @ImGuiDir_Up>
    常量 向下 <公开 值 = @ImGuiDir_Down>
}

# 平台后端

类 IM_Win32平台 <公开 注释 = "基于Windows API的平台后端,需要配合DirectX、OpenGL、Vulkan渲染器使用." 折叠 折叠2
        @文档 = "category = \"平台后端\"" @视窗.外部头文件 = "imgui\\backends\\imgui_impl_win32.h"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_win32.cpp">
{
    方法 初始化 <公开 静态 类型 = 逻辑型 注释 = "初始化链接到DirectX渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供Win32 API的窗口句柄(HWND)">
    {
        @ ImGui_ImplWin32_Init((void*)@<窗口句柄>)
    }

    方法 初始化_OpenGL <公开 静态 类型 = 逻辑型 注释 = "初始化链接到OpenGL渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供Win32 API的窗口句柄(HWND)">
    {
        @ ImGui_ImplWin32_InitForOpenGL((void*)@<窗口句柄>)
    }

    方法 关闭 <公开 静态 注释 = "关闭Win32框架" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplWin32_Shutdown()
    }

    方法 新建帧 <公开 静态 注释 = "新建Win32帧" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplWin32_NewFrame()
    }

    方法 消息处理 <公开 静态 类型 = 逻辑型 注释 = "让ImGui处理Windows窗口中的部分消息" 返回值注释 = "返回真表示允许消息继续向后传递并处理,返回假表示取消掉该消息的后续处理."
            折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供消息所对应的窗口句柄(HWND)">
    参数 消息值 <类型 = 整数 注释 = "提供消息的具体值">
    参数 消息参数1 <类型 = 变整数 注释 = "提供消息所附带的参数1的值">
    参数 消息参数2 <类型 = 变整数 注释 = "提供消息所附带的参数2的值">
    {
        @ (BOOL)ImGui_ImplWin32_WndProcHandler((HWND)@<窗口句柄>, (UINT)@<消息值>, (WPARAM)@<消息参数1>, (LPARAM)@<消息参数2>)
    }

    方法 关注DPI <公开 静态 注释 = "设置本程序是否关注系统默认显示器的DPI(缩放比例)" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplWin32_EnableDpiAwareness()
    }

    方法 取窗口DPI <公开 静态 类型 = 单精度小数 注释 = "返回指定窗口的DPI比例值(相对基准96 DPI)" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供Win32 API的窗口句柄(HWND)">
    {
        @ ImGui_ImplWin32_GetDpiScaleForHwnd((HWND)@<窗口句柄>)
    }

    方法 取显示器DPI <公开 静态 类型 = 单精度小数 注释 = "返回指定显示器的DPI比例值(相对基准96 DPI)" 折叠 @嵌入式方法 = "">
    参数 显示器句柄 <类型 = 变整数 注释 = "提供Win32 API的显示器句柄(HMONITOR)">
    {
        @ ImGui_ImplWin32_GetDpiScaleForHwnd((HMONITOR)@<显示器句柄>)
    }

    方法 启用透明度合成 <公开 静态 注释 = "启用桌面的alpha合成透明度,必须在窗口被创建和被显示之前使用才有效." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供Win32 API的窗口句柄(HWND)">
    {
        @ ImGui_ImplWin32_EnableAlphaCompositing((HWND)@<窗口句柄>)
    }

    # @begin
    # <> <include>
    # <> <global>
    # extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    # <> </global>
    # <> </include>
    # @end
}

类 IM_GLFW平台 <公开 注释 = "基于GLFW的平台后端,GLFW是一个OpenGL应用框架,需要配合OpenGL、Vulkan渲染器使用." 折叠 折叠2
        @文档 = "category = \"平台后端\"" @视窗.预定义宏 = "GLFW_INCLUDE_NONE\r\nGLFW_EXPOSE_NATIVE_WIN32"
        @视窗.头文件搜寻目录 = "FrameWork\\glfw\\include"
        @视窗.外部头文件 = "imgui\\backends\\imgui_impl_glfw.h\r\nGLFW\\glfw3.h\r\nGLFW\\glfw3native.h"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_glfw.cpp"
        "@视窗.外部库.mt-non_dynamic" = "FrameWork\\glfw\\$(p)\\$(vs)\\glfw3_mt.lib"
        "@视窗.外部库.md-non_dynamic" = "FrameWork\\glfw\\$(p)\\$(vs)\\glfw3.lib"
        @视窗.外部库.dynamic = "FrameWork\\glfw\\$(p)\\$(vs)\\glfw3dll.lib"
        @视窗.附属文件.dynamic = "FrameWork\\glfw\\$(p)\\$(vs)\\glfw3.dll" @视窗.需求VS版本 = "15-">
{
    方法 初始化_OpenGL <公开 静态 类型 = 逻辑型 注释 = "初始化链接到OpenGL渲染器" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供GLFW的窗口句柄,注意不支持Win32 API的窗口句柄.">
    参数 安装回调 <类型 = 逻辑型 注释 = "是否将GLFW的部分输入输出回调安装到ImGui中">
    {
        @ ImGui_ImplGlfw_InitForOpenGL((GLFWwindow*)@<窗口句柄>, @<安装回调>)
    }

    方法 初始化_Vulkan <公开 静态 类型 = 逻辑型 注释 = "初始化链接到Vulkan渲染器" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供GLFW的窗口句柄,注意不支持Win32 API的窗口句柄.">
    参数 安装回调 <类型 = 逻辑型 注释 = "是否将GLFW的部分输入输出回调安装到ImGui中">
    {
        @ ImGui_ImplGlfw_InitForVulkan((GLFWwindow*)@<窗口句柄>, @<安装回调>)
    }

    方法 初始化_其他 <公开 静态 类型 = 逻辑型 注释 = "初始化链接到未知渲染器(本方法不可用)" 折叠 @嵌入式方法 = "req_cpp_bool = true">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供GLFW的窗口句柄,注意不支持Win32 API的窗口句柄.">
    参数 安装回调 <类型 = 逻辑型 注释 = "是否将GLFW的部分输入输出回调安装到ImGui中">
    {
        @ ImGui_ImplGlfw_InitForOther((GLFWwindow*)@<窗口句柄>, @<安装回调>)
    }

    方法 关闭 <公开 静态 注释 = "关闭GLFW框架" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplGlfw_Shutdown()
    }

    方法 新建帧 <公开 静态 注释 = "新建GLFW帧" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplGlfw_NewFrame()
    }

    方法 安装回调 <公开 静态 注释 = "将指定GLFW窗口的部分输入输出回调安装到ImGui中." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供GLFW的窗口句柄,注意不支持Win32 API的窗口句柄.">
    {
        @ ImGui_ImplGlfw_InstallCallbacks((GLFWwindow*)@<窗口句柄>)
    }

    方法 还原回调 <公开 静态 注释 = "将指定GLFW窗口的部分输入输出回调函数,还原为ImGui接管前的设置." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 注释 = "提供GLFW的窗口句柄,注意不支持Win32 API的窗口句柄.">
    {
        @ ImGui_ImplGlfw_InstallCallbacks((GLFWwindow*)@<窗口句柄>)
    }

    方法 置链接所有窗口 <公开 静态 注释 = "在所有窗口(包括后台和用户创建的辅助视口)启用链接回调." 折叠 @嵌入式方法 = "">
    参数 链接所有窗口 <类型 = 逻辑型 注释 = "是否将回调链接到所有窗口">
    {
        @ ImGui_ImplGlfw_SetCallbacksChainForAllWindows((bool)@<链接所有窗口>)
    }
}

类 IM_SDL2平台 <公开 注释 = "基于SDL(Simple DirectMedia Layer)的平台后端,需要配合DirectX、OpenGL、Vulkan渲染器使用." 折叠 折叠2
        @文档 = "category = \"平台后端\"" @视窗.头文件搜寻目录 = "FrameWork\\SDL2\\include"
        @视窗.外部头文件 = "imgui\\backends\\imgui_impl_sdl2.h\r\nSDL.h"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_sdl2.cpp"
        @视窗.外部库 = "FrameWork\\SDL2\\$(p)\\SDL2.lib\r\nFrameWork\\SDL2\\$(p)\\SDL2main.lib"
        @视窗.附属文件 = "FrameWork\\SDL2\\$(p)\\SDL2.dll">
{
    方法 初始化_OpenGL <公开 静态 类型 = 逻辑型 注释 = "初始化链接到OpenGL渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 SDL环境 <类型 = 变整数>
    {
        @ ImGui_ImplSDL2_InitForOpenGL((SDL_Window*)@<窗口句柄>, (void*)@<SDL环境>)
    }

    方法 初始化_D3D <公开 静态 类型 = 逻辑型 注释 = "初始化链接到DirectX渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    {
        @ ImGui_ImplSDL2_InitForD3D((SDL_Window*)@<窗口句柄>)
    }

    方法 初始化_Vulkan <公开 静态 类型 = 逻辑型 注释 = "初始化链接到Vulkan渲染器" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    {
        @ ImGui_ImplSDL2_InitForVulkan((SDL_Window*)@<窗口句柄>)
    }

    方法 关闭 <公开 静态 注释 = "关闭SDL2框架" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplSDL2_Shutdown()
    }

    方法 新建帧 <公开 静态 注释 = "新建SDL2帧" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplSDL2_NewFrame()
    }

    方法 处理事件 <公开 静态 类型 = 逻辑型 注释 = "让ImGui处理SDL2的部分输入输出事件" 折叠 @嵌入式方法 = "">
    参数 事件指针 <类型 = 变整数>
    {
        @ ImGui_ImplSDL2_ProcessEvent((const SDL_Event*)@<事件指针>)
    }
}

# 渲染器

类 IM_DX9渲染器 <公开 注释 = "基于DirectX9的渲染器后端,兼容Windows XP以上系统." 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.外部头文件 = "imgui\\backends\\imgui_impl_dx9.h\r\n<d3d9.h>"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_dx9.cpp" @视窗.外部库 = "d3d9.lib">
{

    # @begin
    # <> <include>
    # LPDIRECT3D9            m_pD3D = nullptr;
    # LPDIRECT3DDEVICE9      m_pd3dDevice = nullptr;
    # D3DPRESENT_PARAMETERS  m_d3dpp = {};
    # <> </include>
    # @end

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回0,表示DirectX渲染器)" 折叠>
    {
        返回 (0)
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX9_Init(@sn<this>.m_pd3dDevice)
    }

    方法 关闭 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX9_Shutdown()
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX9_NewFrame()
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = 变整数 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplDX9_RenderDrawData((ImDrawData*)@<绘制数据>)
    }

    方法 创建设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX9_CreateDeviceObjects()
    }

    方法 销毁设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX9_InvalidateDeviceObjects()
    }

    # 纹理图片 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真
            @视窗.外部头文件 = "<D3dx9tex.h>" @视窗.外部库 = "D3dx9.lib"
            @视窗.需求系统头文件 = "<D3dx9tex.h>|需要安装 DirectX SDK 9 https://www.microsoft.com/zh-CN/download/details.aspx?id=6812">
    参数 文件名 <类型 = 文本型 注释 = "支持格式: .bmp、.dds、.dib、.hdr、.jpg、.pfm、.png、.ppm 和 .tga">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ PDIRECT3DTEXTURE9 texture;
        @ HRESULT hr = D3DXCreateTextureFromFileW(m_pd3dDevice, @<文件名>.GetText(), &texture);
        @ if (hr != S_OK) return false;
        @ D3DSURFACE_DESC my_image_desc;
        @ texture->GetLevelDesc(0, &my_image_desc);
        @ @<图片信息.纹理ID> = (INT_P)texture;
        @ @<图片信息.宽度> = (int)my_image_desc.Width;
        @ @<图片信息.高度> = (int)my_image_desc.Height;
        @ return true;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 折叠2
            @禁止流程检查 = 真 @视窗.外部头文件 = "<D3dx9tex.h>" @视窗.外部库 = "D3dx9.lib"
            @视窗.需求系统头文件 = "<D3dx9tex.h>|需要安装 DirectX SDK 9 https://www.microsoft.com/zh-CN/download/details.aspx?id=6812">
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: 支持格式: .bmp、.dds、.dib、.hdr、.jpg、.pfm、.png、.ppm 和 .tga">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ PDIRECT3DTEXTURE9 texture;
        @ HRESULT hr = D3DXCreateTextureFromResourceW(m_pd3dDevice, g_objVolApp.GetInstanceHandle(), MAKEINTRESOURCE(@<图片资源>), &texture);
        @ if (hr != S_OK) return false;
        @ D3DSURFACE_DESC my_image_desc;
        @ texture->GetLevelDesc(0, &my_image_desc);
        @ @<图片信息.纹理ID> = (INT_P)texture;
        @ @<图片信息.宽度> = (int)my_image_desc.Width;
        @ @<图片信息.高度> = (int)my_image_desc.Height;
        @ return true;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 折叠2
            @禁止流程检查 = 真 @视窗.外部头文件 = "<D3dx9tex.h>" @视窗.外部库 = "D3dx9.lib"
            @视窗.需求系统头文件 = "<D3dx9tex.h>|需要安装 DirectX SDK 9 https://www.microsoft.com/zh-CN/download/details.aspx?id=6812">
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: 支持格式: .bmp、.dds、.dib、.hdr、.jpg、.pfm、.png、.ppm 和 .tga">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ PDIRECT3DTEXTURE9 texture;
        @ HRESULT hr = D3DXCreateTextureFromFileInMemory(m_pd3dDevice, @<图片数据>.GetPtr(), (UINT)@<图片数据>.GetSize(), &texture);
        @ if (hr != S_OK) return false;
        @ D3DSURFACE_DESC my_image_desc;
        @ texture->GetLevelDesc(0, &my_image_desc);
        @ @<图片信息.纹理ID> = (INT_P)texture;
        @ @<图片信息.宽度> = (int)my_image_desc.Width;
        @ @<图片信息.高度> = (int)my_image_desc.Height;
        @ return true;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回的图片信息,释放后会清空信息.">
    {
        如果 (图片信息.纹理ID != 0)
        {
            @ ((PDIRECT3DTEXTURE9)@<图片信息.纹理ID>)->Release();
        }
        图片信息.重置为空对象 ()
    }

    # Win32 ---

    方法 创建设备 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ if ((m_pD3D = Direct3DCreate9(D3D_SDK_VERSION)) == nullptr)
        @     return FALSE;
        @ ZeroMemory(&m_d3dpp, sizeof(m_d3dpp));
        @ m_d3dpp.Windowed = TRUE;
        @ m_d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
        @ m_d3dpp.BackBufferFormat = D3DFMT_UNKNOWN; // Need to use an explicit format with alpha if needing per-pixel alpha composition.
        @ m_d3dpp.EnableAutoDepthStencil = TRUE;
        @ m_d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
        @ m_d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_ONE;           // Present with vsync
        @ //m_d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;   // Present without vsync, maximum unthrottled framerate
        @ if (m_pD3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, (HWND)@<窗口句柄>, D3DCREATE_HARDWARE_VERTEXPROCESSING, &m_d3dpp, &m_pd3dDevice) < 0)
        @     return FALSE;
        @ return TRUE;
    }

    方法 释放设备 <公开 折叠>
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ if (m_pd3dDevice) { m_pd3dDevice->Release(); m_pd3dDevice = nullptr; }
        @ if (m_pD3D) { m_pD3D->Release(); m_pD3D = nullptr; }
    }

    方法 重置设备 <公开 折叠>
    {
        @ ImGui_ImplDX9_InvalidateDeviceObjects();
        @ HRESULT hr = m_pd3dDevice->Reset(&m_d3dpp);
        @ if (hr == D3DERR_INVALIDCALL)
        @     IM_ASSERT(0);
        @ ImGui_ImplDX9_CreateDeviceObjects();
    }

    方法 重置尺寸 <公开 折叠>
    参数 宽度 <类型 = 整数>
    参数 高度 <类型 = 整数>
    {
        @ m_d3dpp.BackBufferWidth = (INT)@<宽度>;
        @ m_d3dpp.BackBufferHeight = (INT)@<高度>;
        @ this->@<重置设备>();
    }

    方法 渲染 <公开 折叠>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ ImGui::Render();
        @ m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);
        @ m_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
        @ m_pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
        @ ImVec4* clear_color = @<背景颜色>.pdata();
        @ D3DCOLOR clear_col_dx = D3DCOLOR_COLORVALUE(clear_color->x * clear_color->w, clear_color->y * clear_color->w, clear_color->z * clear_color->w, clear_color->w);
        @ m_pd3dDevice->Clear(0, nullptr, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, clear_col_dx, 1.0f, 0);
        @ if (m_pd3dDevice->BeginScene() >= 0)
        @ {
        @     ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
        @     m_pd3dDevice->EndScene();
        @ }
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @ }
        @ HRESULT result = m_pd3dDevice->Present(nullptr, nullptr, nullptr, nullptr);
        @ // Handle loss of D3D9 device
        @ if (result == D3DERR_DEVICELOST && m_pd3dDevice->TestCooperativeLevel() == D3DERR_DEVICENOTRESET)
        @     this->@<重置设备>();
    }

    方法 准备 <公开>

    # SDL ---

    变量 局_窗口句柄 <类型 = 变整数>

    方法 加载_SDL <公开 类型 = 逻辑型 折叠 @视窗.外部头文件 = "SDL_syswm.h">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ SDL_SysWMinfo wmInfo;
        @ SDL_VERSION(&wmInfo.version);
        @ SDL_GetWindowWMInfo((SDL_Window*)@<窗口句柄>, &wmInfo);
        @ @<局_窗口句柄> = (INT_P)wmInfo.info.win.window;
        返回 (创建设备 (局_窗口句柄))
    }

    方法 渲染_SDL <公开 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ @sn<this>.@<渲染>(@<背景颜色>)
    }

    方法 加载字体纹理 <公开>

    方法 清理 <公开 折叠>
    {
        释放设备 (局_窗口句柄)
    }
}

类 IM_DX10渲染器 <公开 注释 = "基于DirectX10的渲染器后端,兼容Windows Vista以上系统." 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.外部头文件 = "imgui\\backends\\imgui_impl_dx10.h\r\n<d3d10_1.h>\r\n<d3d10.h>"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_dx10.cpp"
        @视窗.外部库 = "d3d10.lib\r\nd3dcompiler.lib\r\ndxgi.lib">
{

    # @begin
    # <> <include>
    # ID3D10Device*            m_pd3dDevice = nullptr;
    # IDXGISwapChain*          m_pSwapChain = nullptr;
    # ID3D10RenderTargetView*  m_mainRenderTargetView = nullptr;
    # <> </include>
    # @end

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回0,表示DirectX渲染器)" 折叠>
    {
        返回 (0)
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @禁止流程检查 = 真>
    {
        @ return ImGui_ImplDX10_Init(m_pd3dDevice);
    }

    方法 关闭 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX10_Shutdown()
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX10_NewFrame()
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = 变整数 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplDX10_RenderDrawData((ImDrawData*)@<绘制数据>)
    }

    方法 创建设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX10_CreateDeviceObjects()
    }

    方法 销毁设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX10_InvalidateDeviceObjects()
    }

    # 图片纹理 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (!m_pd3dDevice) return false;
        @ FILE* file = _wfopen(@<文件名>.GetText(), L"rb");
        @ if (!file) return false;
        @ int image_width = 0, image_height = 0;
        @ unsigned char* image_data = stbi_load_from_file(file, &image_width, &image_height, nullptr, 4);
        @ fclose(file);
        @ if (!image_data) return false;
        // Create texture
        @ D3D10_TEXTURE2D_DESC desc;
        @ ZeroMemory(&desc, sizeof(desc));
        @ desc.Width = image_width;
        @ desc.Height = image_height;
        @ desc.MipLevels = 1;
        @ desc.ArraySize = 1;
        @ desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ desc.SampleDesc.Count = 1;
        @ desc.Usage = D3D10_USAGE_DEFAULT;
        @ desc.BindFlags = D3D10_BIND_SHADER_RESOURCE;
        @ desc.CPUAccessFlags = 0;
        @ ID3D10Texture2D *pTexture = NULL;
        @ D3D10_SUBRESOURCE_DATA subResource {image_data, desc.Width * 4, 0};
        @ m_pd3dDevice->CreateTexture2D(&desc, &subResource, &pTexture);
        // Create texture view
        @ D3D10_SHADER_RESOURCE_VIEW_DESC srvDesc;
        @ ZeroMemory(&srvDesc, sizeof(srvDesc));
        @ srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        @ srvDesc.Texture2D.MipLevels = desc.MipLevels;
        @ srvDesc.Texture2D.MostDetailedMip = 0;
        @ ID3D10ShaderResourceView* out_srv;
        @ m_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, &out_srv);
        @ pTexture->Release();
        @ @<图片信息.宽度> = image_width;
        @ @<图片信息.高度> = image_height;
        @ @<图片信息.纹理ID> = (INT_P)out_srv;
        @ stbi_image_free(image_data);
        @ return true;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCE((WORD)@<图片资源>), RT_RCDATA);
        @ if (!hSrc) return false;
        @ HGLOBAL resdata = ::LoadResource(hModule, hSrc);
        @ if (!resdata) return false;
        @ int image_width = 0, image_height = 0;
        @ unsigned char* image_data = stbi_load_from_memory((unsigned char*)::LockResource(resdata), (int)::SizeofResource(hModule, hSrc),
        @                                                   &image_width, &image_height, nullptr, 4);
        @ if (!image_data) return false;
        // Create texture
        @ D3D10_TEXTURE2D_DESC desc;
        @ ZeroMemory(&desc, sizeof(desc));
        @ desc.Width = image_width;
        @ desc.Height = image_height;
        @ desc.MipLevels = 1;
        @ desc.ArraySize = 1;
        @ desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ desc.SampleDesc.Count = 1;
        @ desc.Usage = D3D10_USAGE_DEFAULT;
        @ desc.BindFlags = D3D10_BIND_SHADER_RESOURCE;
        @ desc.CPUAccessFlags = 0;
        @ ID3D10Texture2D *pTexture = NULL;
        @ D3D10_SUBRESOURCE_DATA subResource {image_data, desc.Width * 4, 0};
        @ m_pd3dDevice->CreateTexture2D(&desc, &subResource, &pTexture);
        // Create texture view
        @ D3D10_SHADER_RESOURCE_VIEW_DESC srvDesc;
        @ ZeroMemory(&srvDesc, sizeof(srvDesc));
        @ srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        @ srvDesc.Texture2D.MipLevels = desc.MipLevels;
        @ srvDesc.Texture2D.MostDetailedMip = 0;
        @ ID3D10ShaderResourceView* out_srv;
        @ m_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, &out_srv);
        @ pTexture->Release();
        @ @<图片信息.宽度> = image_width;
        @ @<图片信息.高度> = image_height;
        @ @<图片信息.纹理ID> = (INT_P)out_srv;
        @ stbi_image_free(image_data);
        @ return true;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ int image_width = 0, image_height = 0;
        @ unsigned char* image_data = stbi_load_from_memory(@<图片数据>.GetPtr(), (int)@<图片数据>.GetSize(), &image_width, &image_height, nullptr, 4);
        @ if (!image_data) return false;
        // Create texture
        @ D3D10_TEXTURE2D_DESC desc;
        @ ZeroMemory(&desc, sizeof(desc));
        @ desc.Width = image_width;
        @ desc.Height = image_height;
        @ desc.MipLevels = 1;
        @ desc.ArraySize = 1;
        @ desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ desc.SampleDesc.Count = 1;
        @ desc.Usage = D3D10_USAGE_DEFAULT;
        @ desc.BindFlags = D3D10_BIND_SHADER_RESOURCE;
        @ desc.CPUAccessFlags = 0;
        @ ID3D10Texture2D *pTexture = NULL;
        @ D3D10_SUBRESOURCE_DATA subResource {image_data, desc.Width * 4, 0};
        @ m_pd3dDevice->CreateTexture2D(&desc, &subResource, &pTexture);
        // Create texture view
        @ D3D10_SHADER_RESOURCE_VIEW_DESC srvDesc;
        @ ZeroMemory(&srvDesc, sizeof(srvDesc));
        @ srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        @ srvDesc.Texture2D.MipLevels = desc.MipLevels;
        @ srvDesc.Texture2D.MostDetailedMip = 0;
        @ ID3D10ShaderResourceView* out_srv;
        @ m_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, &out_srv);
        @ pTexture->Release();
        @ @<图片信息.宽度> = image_width;
        @ @<图片信息.高度> = image_height;
        @ @<图片信息.纹理ID> = (INT_P)out_srv;
        @ stbi_image_free(image_data);
        @ return true;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回的图片信息,释放后会清空信息.">
    {
        如果 (图片信息.纹理ID != 0)
        {
            @ ((ID3D10ShaderResourceView*)@<图片信息.纹理ID>)->Release();
        }
        图片信息.重置为空对象 ()
    }

    # Win32 ---

    方法 创建设备 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ DXGI_SWAP_CHAIN_DESC sd = {};
        @ sd.BufferCount = 2;
        @ sd.BufferDesc.Width = 0;
        @ sd.BufferDesc.Height = 0;
        @ sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ sd.BufferDesc.RefreshRate.Numerator = 60;
        @ sd.BufferDesc.RefreshRate.Denominator = 1;
        @ sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
        @ sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
        @ sd.OutputWindow = (HWND)@<窗口句柄>;
        @ sd.SampleDesc.Count = 1;
        @ sd.SampleDesc.Quality = 0;
        @ sd.Windowed = TRUE;
        @ sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
        @ UINT createDeviceFlags = 0;
        @ //createDeviceFlags |= D3D10_CREATE_DEVICE_DEBUG;
        @ HRESULT res = D3D10CreateDeviceAndSwapChain(nullptr, D3D10_DRIVER_TYPE_HARDWARE, nullptr, createDeviceFlags, D3D10_SDK_VERSION, &sd, &m_pSwapChain, &m_pd3dDevice);
        @ if (res == DXGI_ERROR_UNSUPPORTED) // Try high-performance WARP software driver if hardware is not available.
        @     res = D3D10CreateDeviceAndSwapChain(nullptr, D3D10_DRIVER_TYPE_WARP, nullptr, createDeviceFlags, D3D10_SDK_VERSION, &sd, &m_pSwapChain, &m_pd3dDevice);
        @ if (res != S_OK)
        @     return FALSE;
        @ this->@<创建渲染目标>();
        @ return TRUE;
    }

    方法 释放设备 <公开 折叠>
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ this->@<释放渲染目标>();
        @ if (m_pSwapChain) { m_pSwapChain->Release(); m_pSwapChain = nullptr; }
        @ if (m_pd3dDevice) { m_pd3dDevice->Release(); m_pd3dDevice = nullptr; }
    }

    方法 创建渲染目标 <公开 折叠>
    {
        @ ID3D10Texture2D* pBackBuffer;
        @ m_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
        @ m_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, &m_mainRenderTargetView);
        @ pBackBuffer->Release();
    }

    方法 释放渲染目标 <公开 折叠>
    {
        @ if (m_mainRenderTargetView) { m_mainRenderTargetView->Release(); m_mainRenderTargetView = nullptr; }
    }

    方法 重置尺寸 <公开 折叠>
    参数 宽度 <类型 = 整数>
    参数 高度 <类型 = 整数>
    {
        @ this->@<释放渲染目标>();
        @ m_pSwapChain->ResizeBuffers(0, @<宽度>, @<高度>, DXGI_FORMAT_UNKNOWN, 0);
        @ this->@<创建渲染目标>();
    }

    方法 渲染 <公开 折叠>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ ImGui::Render();
        @ ImVec4* clear_color = @<背景颜色>.pdata();
        @ const float clear_color_with_alpha[4] = { clear_color->x * clear_color->w, clear_color->y * clear_color->w, clear_color->z * clear_color->w, clear_color->w };
        @ m_pd3dDevice->OMSetRenderTargets(1, &m_mainRenderTargetView, nullptr);
        @ m_pd3dDevice->ClearRenderTargetView(m_mainRenderTargetView, clear_color_with_alpha);
        @ ImGui_ImplDX10_RenderDrawData(ImGui::GetDrawData());
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @ }
        @ m_pSwapChain->Present(1, 0);
    }

    方法 准备 <公开>

    # SDL ---

    变量 局_窗口句柄 <类型 = 变整数>

    方法 加载_SDL <公开 类型 = 逻辑型 折叠 @视窗.外部头文件 = "SDL_syswm.h">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ SDL_SysWMinfo wmInfo;
        @ SDL_VERSION(&wmInfo.version);
        @ SDL_GetWindowWMInfo((SDL_Window*)@<窗口句柄>, &wmInfo);
        @ @<局_窗口句柄> = (INT_P)wmInfo.info.win.window;
        返回 (创建设备 (局_窗口句柄))
    }

    方法 渲染_SDL <公开 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ @sn<this>.@<渲染>(@<背景颜色>)
    }

    方法 加载字体纹理 <公开>

    方法 清理 <公开 折叠>
    {
        释放设备 (局_窗口句柄)
    }
}

类 IM_DX11渲染器 <公开 注释 = "基于DirectX11的渲染器后端,兼容Windows 7及以上系统." 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.外部头文件 = "imgui\\backends\\imgui_impl_dx11.h\r\n<d3d11.h>"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_dx11.cpp"
        @视窗.外部库 = "d3d11.lib\r\nd3dcompiler.lib\r\ndxgi.lib">
{

    # @begin
    # <> <include>
    # ID3D11Device*            m_pd3dDevice = nullptr;
    # ID3D11DeviceContext*     m_pd3dDeviceContext = nullptr;
    # IDXGISwapChain*          m_pSwapChain = nullptr;
    # ID3D11RenderTargetView*  m_mainRenderTargetView = nullptr;
    # <> </include>
    # @end

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回0,表示DirectX渲染器)" 折叠>
    {
        返回 (0)
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @禁止流程检查 = 真>
    {
        @ return ImGui_ImplDX11_Init(m_pd3dDevice, m_pd3dDeviceContext);
    }

    方法 关闭 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX11_Shutdown()
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX11_NewFrame()
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = 变整数 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplDX11_RenderDrawData((ImDrawData*)@<绘制数据>)
    }

    方法 创建设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX11_CreateDeviceObjects()
    }

    方法 销毁设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX11_InvalidateDeviceObjects()
    }

    # 纹理图片 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (!m_pd3dDevice) return false;
        @ FILE* file = _wfopen(@<文件名>.GetText(), L"rb");
        @ if (!file) return false;
        @ int image_width = 0, image_height = 0;
        @ unsigned char* image_data = stbi_load_from_file(file, &image_width, &image_height, nullptr, 4);
        @ fclose(file);
        @ if (!image_data) return false;
        // Create texture
        @ D3D11_TEXTURE2D_DESC desc;
        @ ZeroMemory(&desc, sizeof(desc));
        @ desc.Width = image_width;
        @ desc.Height = image_height;
        @ desc.MipLevels = 1;
        @ desc.ArraySize = 1;
        @ desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ desc.SampleDesc.Count = 1;
        @ desc.Usage = D3D11_USAGE_DEFAULT;
        @ desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
        @ desc.CPUAccessFlags = 0;
        @ ID3D11Texture2D *pTexture = NULL;
        @ D3D11_SUBRESOURCE_DATA subResource {image_data, desc.Width * 4, 0};
        @ m_pd3dDevice->CreateTexture2D(&desc, &subResource, &pTexture);
        // Create texture view
        @ D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
        @ ZeroMemory(&srvDesc, sizeof(srvDesc));
        @ srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        @ srvDesc.Texture2D.MipLevels = desc.MipLevels;
        @ srvDesc.Texture2D.MostDetailedMip = 0;
        @ ID3D11ShaderResourceView* out_srv;
        @ m_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, &out_srv);
        @ pTexture->Release();
        @ @<图片信息.宽度> = image_width;
        @ @<图片信息.高度> = image_height;
        @ @<图片信息.纹理ID> = (INT_P)out_srv;
        @ stbi_image_free(image_data);
        @ return true;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCE((WORD)@<图片资源>), RT_RCDATA);
        @ if (!hSrc) return false;
        @ HGLOBAL resdata = ::LoadResource(hModule, hSrc);
        @ if (!resdata) return false;
        @ int image_width = 0, image_height = 0;
        @ unsigned char* image_data = stbi_load_from_memory((unsigned char*)::LockResource(resdata), (int)::SizeofResource(hModule, hSrc),
        @                                                   &image_width, &image_height, nullptr, 4);
        @ if (!image_data) return false;
        // Create texture
        @ D3D11_TEXTURE2D_DESC desc;
        @ ZeroMemory(&desc, sizeof(desc));
        @ desc.Width = image_width;
        @ desc.Height = image_height;
        @ desc.MipLevels = 1;
        @ desc.ArraySize = 1;
        @ desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ desc.SampleDesc.Count = 1;
        @ desc.Usage = D3D11_USAGE_DEFAULT;
        @ desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
        @ desc.CPUAccessFlags = 0;
        @ ID3D11Texture2D *pTexture = NULL;
        @ D3D11_SUBRESOURCE_DATA subResource {image_data, desc.Width * 4, 0};
        @ m_pd3dDevice->CreateTexture2D(&desc, &subResource, &pTexture);
        // Create texture view
        @ D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
        @ ZeroMemory(&srvDesc, sizeof(srvDesc));
        @ srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        @ srvDesc.Texture2D.MipLevels = desc.MipLevels;
        @ srvDesc.Texture2D.MostDetailedMip = 0;
        @ ID3D11ShaderResourceView* out_srv;
        @ m_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, &out_srv);
        @ pTexture->Release();
        @ @<图片信息.宽度> = image_width;
        @ @<图片信息.高度> = image_height;
        @ @<图片信息.纹理ID> = (INT_P)out_srv;
        @ stbi_image_free(image_data);
        @ return true;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ int image_width = 0, image_height = 0;
        @ unsigned char* image_data = stbi_load_from_memory(@<图片数据>.GetPtr(), (int)@<图片数据>.GetSize(), &image_width, &image_height, nullptr, 4);
        @ if (!image_data) return false;
        // Create texture
        @ D3D11_TEXTURE2D_DESC desc;
        @ ZeroMemory(&desc, sizeof(desc));
        @ desc.Width = image_width;
        @ desc.Height = image_height;
        @ desc.MipLevels = 1;
        @ desc.ArraySize = 1;
        @ desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ desc.SampleDesc.Count = 1;
        @ desc.Usage = D3D11_USAGE_DEFAULT;
        @ desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
        @ desc.CPUAccessFlags = 0;
        @ ID3D11Texture2D *pTexture = NULL;
        @ D3D11_SUBRESOURCE_DATA subResource {image_data, desc.Width * 4, 0};
        @ m_pd3dDevice->CreateTexture2D(&desc, &subResource, &pTexture);
        // Create texture view
        @ D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
        @ ZeroMemory(&srvDesc, sizeof(srvDesc));
        @ srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        @ srvDesc.Texture2D.MipLevels = desc.MipLevels;
        @ srvDesc.Texture2D.MostDetailedMip = 0;
        @ ID3D11ShaderResourceView* out_srv;
        @ m_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, &out_srv);
        @ pTexture->Release();
        @ @<图片信息.宽度> = image_width;
        @ @<图片信息.高度> = image_height;
        @ @<图片信息.纹理ID> = (INT_P)out_srv;
        @ stbi_image_free(image_data);
        @ return true;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回的图片信息,释放后会清空信息.">
    {
        如果 (图片信息.纹理ID != 0)
        {
            @ ((ID3D11ShaderResourceView*)@<图片信息.纹理ID>)->Release();
        }
        图片信息.重置为空对象 ()
    }

    # Win32 ---

    方法 创建设备 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ DXGI_SWAP_CHAIN_DESC sd;
        @ ZeroMemory(&sd, sizeof(sd));
        @ sd.BufferCount = 2;
        @ sd.BufferDesc.Width = 0;
        @ sd.BufferDesc.Height = 0;
        @ sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ sd.BufferDesc.RefreshRate.Numerator = 60;
        @ sd.BufferDesc.RefreshRate.Denominator = 1;
        @ sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
        @ sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
        @ sd.OutputWindow = (HWND)@<窗口句柄>;
        @ sd.SampleDesc.Count = 1;
        @ sd.SampleDesc.Quality = 0;
        @ sd.Windowed = TRUE;
        @ sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
        @ UINT createDeviceFlags = 0;
        @ // createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
        @ D3D_FEATURE_LEVEL featureLevel;
        @ const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };
        @ HRESULT res = D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &m_pSwapChain, &m_pd3dDevice, &featureLevel, &m_pd3dDeviceContext);
        @ if (res == DXGI_ERROR_UNSUPPORTED) // Try high-performance WARP software driver if hardware is not available.
        @     res = D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_WARP, nullptr, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &m_pSwapChain, &m_pd3dDevice, &featureLevel, &m_pd3dDeviceContext);
        @ if (res != S_OK)
        @     return FALSE;
        @ this->@<创建渲染目标>();
        @ return TRUE;
    }

    方法 释放设备 <公开 折叠>
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ this->@<释放渲染目标>();
        @ if (m_pSwapChain) { m_pSwapChain->Release(); m_pSwapChain = nullptr; }
        @ if (m_pd3dDeviceContext) { m_pd3dDeviceContext->Release(); m_pd3dDeviceContext = nullptr; }
        @ if (m_pd3dDevice) { m_pd3dDevice->Release(); m_pd3dDevice = nullptr; }
    }

    方法 创建渲染目标 <公开 折叠>
    {
        @ ID3D11Texture2D* pBackBuffer;
        @ m_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
        @ m_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, &m_mainRenderTargetView);
        @ pBackBuffer->Release();
    }

    方法 释放渲染目标 <公开 折叠>
    {
        @ if (m_mainRenderTargetView) { m_mainRenderTargetView->Release(); m_mainRenderTargetView = nullptr; }
    }

    方法 重置尺寸 <公开 折叠>
    参数 宽度 <类型 = 整数>
    参数 高度 <类型 = 整数>
    {
        @ this->@<释放渲染目标>();
        @ m_pSwapChain->ResizeBuffers(0, @<宽度>, @<高度>, DXGI_FORMAT_UNKNOWN, 0);
        @ this->@<创建渲染目标>();
    }

    方法 渲染 <公开 折叠>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ ImGui::Render();
        @ ImVec4* clear_color = @<背景颜色>.pdata();
        @ const float clear_color_with_alpha[4] = { clear_color->x * clear_color->w, clear_color->y * clear_color->w, clear_color->z * clear_color->w, clear_color->w };
        @ m_pd3dDeviceContext->OMSetRenderTargets(1, &m_mainRenderTargetView, nullptr);
        @ m_pd3dDeviceContext->ClearRenderTargetView(m_mainRenderTargetView, clear_color_with_alpha);
        @ ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @ }
        @ m_pSwapChain->Present(1, 0);
    }

    方法 准备 <公开>

    # SDL ---

    变量 局_窗口句柄 <类型 = 变整数>

    方法 加载_SDL <公开 类型 = 逻辑型 折叠 @视窗.外部头文件 = "SDL_syswm.h">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ SDL_SysWMinfo wmInfo;
        @ SDL_VERSION(&wmInfo.version);
        @ SDL_GetWindowWMInfo((SDL_Window*)@<窗口句柄>, &wmInfo);
        @ @<局_窗口句柄> = (INT_P)wmInfo.info.win.window;
        返回 (创建设备 (局_窗口句柄))
    }

    方法 渲染_SDL <公开 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ @sn<this>.@<渲染>(@<背景颜色>)
    }

    方法 加载字体纹理 <公开>

    方法 清理 <公开 折叠>
    {
        释放设备 (局_窗口句柄)
    }
}

类 IM_DX12渲染器 <公开 注释 = "基于DirectX12的渲染器后端,兼容Windows 10及以上系统." 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.外部头文件 = "imgui\\backends\\imgui_impl_dx12.h\r\n<d3d12.h>\r\n<dxgi1_4.h>"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_dx12.cpp"
        @视窗.外部库 = "d3d12.lib\r\nd3dcompiler.lib\r\ndxgi.lib" @视窗.预定义宏 = "ImTextureID=ImU64">
{

    # @begin
    # <> <include>
    # #define NUM_FRAMES_IN_FLIGHT  3
    # #define NUM_BACK_BUFFERS  3
    # struct FrameContext
    # {
    #     ID3D12CommandAllocator*  CommandAllocator;
    #     UINT64                   FenceValue;
    # };
    # FrameContext                 m_frameContext[NUM_FRAMES_IN_FLIGHT] = {};
    # UINT                         m_frameIndex = 0;
    # ID3D12Device*                m_pd3dDevice = nullptr;
    # ID3D12DescriptorHeap*        m_pd3dRtvDescHeap = nullptr;
    # ID3D12DescriptorHeap*        m_pd3dSrvDescHeap = nullptr;
    # ID3D12CommandQueue*          m_pd3dCommandQueue = nullptr;
    # ID3D12GraphicsCommandList*   m_pd3dCommandList = nullptr;
    # ID3D12Fence*                 m_fence = nullptr;
    # HANDLE                       m_fenceEvent = nullptr;
    # UINT64                       m_fenceLastSignaledValue = 0;
    # IDXGISwapChain3*             m_pSwapChain = nullptr;
    # HANDLE                       m_hSwapChainWaitableObject = nullptr;
    # ID3D12Resource*              m_mainRenderTargetResource[NUM_BACK_BUFFERS] = {};
    # D3D12_CPU_DESCRIPTOR_HANDLE  m_mainRenderTargetDescriptor[NUM_BACK_BUFFERS] = {};
    # int                          descriptor_index = 0;
    # <> </include>
    # @end

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回0,表示DirectX渲染器)" 折叠>
    {
        返回 (0)
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @禁止流程检查 = 真>
    {
        @ return ImGui_ImplDX12_Init(m_pd3dDevice, NUM_FRAMES_IN_FLIGHT, DXGI_FORMAT_R8G8B8A8_UNORM, m_pd3dSrvDescHeap,
        @                            m_pd3dSrvDescHeap->GetCPUDescriptorHandleForHeapStart(),
        @                            m_pd3dSrvDescHeap->GetGPUDescriptorHandleForHeapStart());
    }

    方法 关闭 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX12_Shutdown()
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX12_NewFrame()
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = 变整数 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplDX12_RenderDrawData((ImDrawData*)@<绘制数据>, @sn<this>.m_pd3dCommandList)
    }

    方法 创建设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX12_CreateDeviceObjects()
    }

    方法 销毁设备对象 <公开 注释 = "用于在不丢失ImGui状态的情况下重置渲染设备" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplDX12_InvalidateDeviceObjects()
    }

    # 纹理图片 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_DX12渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (!m_pd3dDevice) return false;
        @ FILE* file = _wfopen(@<文件名>.GetText(), L"rb");
        @ if (!file) return false;
        @ unsigned char* image_data = stbi_load_from_file(file, &@<图片信息.宽度>, &@<图片信息.高度>, nullptr, 4);
        @ fclose(file);
        @ if (!image_data) return false;
        @ ID3D12Resource* my_texture = NULL;
        @ UINT handle_increment = m_pd3dDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
        @ descriptor_index++;
        @ D3D12_CPU_DESCRIPTOR_HANDLE my_texture_srv_cpu_handle = m_pd3dSrvDescHeap->GetCPUDescriptorHandleForHeapStart();
        @ my_texture_srv_cpu_handle.ptr += (handle_increment * descriptor_index);
        @ D3D12_GPU_DESCRIPTOR_HANDLE my_texture_srv_gpu_handle = m_pd3dSrvDescHeap->GetGPUDescriptorHandleForHeapStart();
        @ my_texture_srv_gpu_handle.ptr += (handle_increment * descriptor_index);
        @ this->@<_加载图片>(image_data, my_texture_srv_cpu_handle, &my_texture, @<图片信息.宽度>, @<图片信息.高度>);
        @ @<图片信息.纹理ID> = (INT_P)my_texture_srv_gpu_handle.ptr;
        @ @<图片信息._内部数据> = (INT_P)my_texture;
        @ return true;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_DX12渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (!m_pd3dDevice) return false;
        @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCE((WORD)@<图片资源>), RT_RCDATA);
        @ if (!hSrc) return false;
        @ HGLOBAL resdata = ::LoadResource(hModule, hSrc);
        @ if (!resdata) return false;
        @ unsigned char* data = (unsigned char*)::LockResource(resdata);
        @ int len = (int)::SizeofResource(hModule, hSrc);
        @ unsigned char* image_data = stbi_load_from_memory(data, len, &@<图片信息.宽度>, &@<图片信息.高度>, nullptr, 4);
        @ if (!image_data) return false;
        @ ID3D12Resource* my_texture = NULL;
        @ UINT handle_increment = m_pd3dDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
        @ descriptor_index++;
        @ D3D12_CPU_DESCRIPTOR_HANDLE my_texture_srv_cpu_handle = m_pd3dSrvDescHeap->GetCPUDescriptorHandleForHeapStart();
        @ my_texture_srv_cpu_handle.ptr += (handle_increment * descriptor_index);
        @ D3D12_GPU_DESCRIPTOR_HANDLE my_texture_srv_gpu_handle = m_pd3dSrvDescHeap->GetGPUDescriptorHandleForHeapStart();
        @ my_texture_srv_gpu_handle.ptr += (handle_increment * descriptor_index);
        @ this->@<_加载图片>(image_data, my_texture_srv_cpu_handle, &my_texture, @<图片信息.宽度>, @<图片信息.高度>);
        @ @<图片信息.纹理ID> = (INT_P)my_texture_srv_gpu_handle.ptr;
        @ @<图片信息._内部数据> = (INT_P)my_texture;
        @ return true;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_DX12渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (!m_pd3dDevice) return false;
        @ unsigned char* image_data = stbi_load_from_memory(@<图片数据>.GetPtr(), (int)@<图片数据>.GetSize(), &@<图片信息.宽度>, &@<图片信息.高度>, nullptr, 4);
        @ if (!image_data) return false;
        @ ID3D12Resource* my_texture = NULL;
        @ UINT handle_increment = m_pd3dDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
        @ descriptor_index++;
        @ D3D12_CPU_DESCRIPTOR_HANDLE my_texture_srv_cpu_handle = m_pd3dSrvDescHeap->GetCPUDescriptorHandleForHeapStart();
        @ my_texture_srv_cpu_handle.ptr += (handle_increment * descriptor_index);
        @ D3D12_GPU_DESCRIPTOR_HANDLE my_texture_srv_gpu_handle = m_pd3dSrvDescHeap->GetGPUDescriptorHandleForHeapStart();
        @ my_texture_srv_gpu_handle.ptr += (handle_increment * descriptor_index);
        @ this->@<_加载图片>(image_data, my_texture_srv_cpu_handle, &my_texture, @<图片信息.宽度>, @<图片信息.高度>);
        @ @<图片信息.纹理ID> = (INT_P)my_texture_srv_gpu_handle.ptr;
        @ @<图片信息._内部数据> = (INT_P)my_texture;
        @ return true;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回图片的信息,释放后会清空信息.">
    {
        如果 (图片信息._内部数据 != 0)
        {
            @ ((ID3D12Resource*)@<图片信息._内部数据>)->Release();
        }
        图片信息.重置为空对象 ()
    }

    方法 _加载图片 <注释 = "仅限内部嵌入式使用" 折叠>
    参数 图片指针 <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/unsigned char*" @输出名 = "image_data">
    参数 srv_cpu_handle <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/D3D12_CPU_DESCRIPTOR_HANDLE"
            @输出名 = "srv_cpu_handle">
    参数 out_tex_resource <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/ID3D12Resource**" @输出名 = "out_tex_resource">
    参数 宽度 <类型 = 整数 @输出名 = "image_width">
    参数 高度 <类型 = 整数 @输出名 = "image_height">
    {
        // Create texture resource
        @ D3D12_HEAP_PROPERTIES props;
        @ memset(&props, 0, sizeof(D3D12_HEAP_PROPERTIES));
        @ props.Type = D3D12_HEAP_TYPE_DEFAULT;
        @ props.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
        @ props.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;

        @ D3D12_RESOURCE_DESC desc;
        @ ZeroMemory(&desc, sizeof(desc));
        @ desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
        @ desc.Alignment = 0;
        @ desc.Width = image_width;
        @ desc.Height = image_height;
        @ desc.DepthOrArraySize = 1;
        @ desc.MipLevels = 1;
        @ desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ desc.SampleDesc.Count = 1;
        @ desc.SampleDesc.Quality = 0;
        @ desc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
        @ desc.Flags = D3D12_RESOURCE_FLAG_NONE;

        @ ID3D12Resource* pTexture = NULL;
        @ m_pd3dDevice->CreateCommittedResource(&props, D3D12_HEAP_FLAG_NONE, &desc,
        @     D3D12_RESOURCE_STATE_COPY_DEST, NULL, IID_PPV_ARGS(&pTexture));

        // Create a temporary upload resource to move the data in
        @ UINT uploadPitch = (image_width * 4 + D3D12_TEXTURE_DATA_PITCH_ALIGNMENT - 1u) & ~(D3D12_TEXTURE_DATA_PITCH_ALIGNMENT - 1u);
        @ UINT uploadSize = image_height * uploadPitch;
        @ desc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
        @ desc.Alignment = 0;
        @ desc.Width = uploadSize;
        @ desc.Height = 1;
        @ desc.DepthOrArraySize = 1;
        @ desc.MipLevels = 1;
        @ desc.Format = DXGI_FORMAT_UNKNOWN;
        @ desc.SampleDesc.Count = 1;
        @ desc.SampleDesc.Quality = 0;
        @ desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
        @ desc.Flags = D3D12_RESOURCE_FLAG_NONE;

        @ props.Type = D3D12_HEAP_TYPE_UPLOAD;
        @ props.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
        @ props.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;

        @ ID3D12Resource* uploadBuffer = NULL;
        @ HRESULT hr = m_pd3dDevice->CreateCommittedResource(&props, D3D12_HEAP_FLAG_NONE, &desc,
        @     D3D12_RESOURCE_STATE_GENERIC_READ, NULL, IID_PPV_ARGS(&uploadBuffer));
        @ IM_ASSERT(SUCCEEDED(hr));

        // Write pixels into the upload resource
        @ void* mapped = NULL;
        @ D3D12_RANGE range = { 0, uploadSize };
        @ hr = uploadBuffer->Map(0, &range, &mapped);
        @ IM_ASSERT(SUCCEEDED(hr));
        @ for (int y = 0; y < image_height; y++)
        @     memcpy((void*)((uintptr_t)mapped + y * uploadPitch), image_data + y * image_width * 4, image_width * 4);
        @ uploadBuffer->Unmap(0, &range);

        // Copy the upload resource content into the real resource
        @ D3D12_TEXTURE_COPY_LOCATION srcLocation = {};
        @ srcLocation.pResource = uploadBuffer;
        @ srcLocation.Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;
        @ srcLocation.PlacedFootprint.Footprint.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srcLocation.PlacedFootprint.Footprint.Width = image_width;
        @ srcLocation.PlacedFootprint.Footprint.Height = image_height;
        @ srcLocation.PlacedFootprint.Footprint.Depth = 1;
        @ srcLocation.PlacedFootprint.Footprint.RowPitch = uploadPitch;

        @ D3D12_TEXTURE_COPY_LOCATION dstLocation = {};
        @ dstLocation.pResource = pTexture;
        @ dstLocation.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
        @ dstLocation.SubresourceIndex = 0;

        @ D3D12_RESOURCE_BARRIER barrier = {};
        @ barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
        @ barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
        @ barrier.Transition.pResource = pTexture;
        @ barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
        @ barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
        @ barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;

        // Create a temporary command queue to do the copy with
        @ ID3D12Fence* fence = NULL;
        @ hr = m_pd3dDevice->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence));
        @ IM_ASSERT(SUCCEEDED(hr));

        @ HANDLE event = CreateEvent(0, 0, 0, 0);
        @ IM_ASSERT(event != NULL);

        @ D3D12_COMMAND_QUEUE_DESC queueDesc = {};
        @ queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
        @ queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
        @ queueDesc.NodeMask = 1;

        @ ID3D12CommandQueue* cmdQueue = NULL;
        @ hr = m_pd3dDevice->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&cmdQueue));
        @ IM_ASSERT(SUCCEEDED(hr));

        @ ID3D12CommandAllocator* cmdAlloc = NULL;
        @ hr = m_pd3dDevice->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&cmdAlloc));
        @ IM_ASSERT(SUCCEEDED(hr));

        @ ID3D12GraphicsCommandList* cmdList = NULL;
        @ hr = m_pd3dDevice->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, cmdAlloc, NULL, IID_PPV_ARGS(&cmdList));
        @ IM_ASSERT(SUCCEEDED(hr));

        @ cmdList->CopyTextureRegion(&dstLocation, 0, 0, 0, &srcLocation, NULL);
        @ cmdList->ResourceBarrier(1, &barrier);

        @ hr = cmdList->Close();
        @ IM_ASSERT(SUCCEEDED(hr));

        // Execute the copy
        @ cmdQueue->ExecuteCommandLists(1, (ID3D12CommandList* const*)&cmdList);
        @ hr = cmdQueue->Signal(fence, 1);
        @ IM_ASSERT(SUCCEEDED(hr));

        // Wait for everything to complete
        @ fence->SetEventOnCompletion(1, event);
        @ WaitForSingleObject(event, INFINITE);

        // Tear down our temporary command queue and release the upload resource
        @ cmdList->Release();
        @ cmdAlloc->Release();
        @ cmdQueue->Release();
        @ CloseHandle(event);
        @ fence->Release();
        @ uploadBuffer->Release();

        // Create a shader resource view for the texture
        @ D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc;
        @ ZeroMemory(&srvDesc, sizeof(srvDesc));
        @ srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
        @ srvDesc.Texture2D.MipLevels = desc.MipLevels;
        @ srvDesc.Texture2D.MostDetailedMip = 0;
        @ srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
        @ m_pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, srv_cpu_handle);
        // Return results
        @ *out_tex_resource = pTexture;
        @ stbi_image_free(image_data);
    }

    # Win32 ---

    方法 创建设备 <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ DXGI_SWAP_CHAIN_DESC1 sd = {};
        @ sd.BufferCount = NUM_BACK_BUFFERS;
        @ sd.Width = 0;
        @ sd.Height = 0;
        @ sd.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        @ sd.Flags = DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;
        @ sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
        @ sd.SampleDesc.Count = 1;
        @ sd.SampleDesc.Quality = 0;
        @ sd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
        @ sd.AlphaMode = DXGI_ALPHA_MODE_UNSPECIFIED; // DXGI_ALPHA_MODE_STRAIGHT
        @ sd.Scaling = DXGI_SCALING_STRETCH;
        @ sd.Stereo = FALSE;
        @ if (D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&m_pd3dDevice)) != S_OK)
        @     return FALSE;
        @ {
        @     D3D12_DESCRIPTOR_HEAP_DESC desc = {};
        @     desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
        @     desc.NumDescriptors = NUM_BACK_BUFFERS;
        @     desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
        @     desc.NodeMask = 1;
        @     if (m_pd3dDevice->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&m_pd3dRtvDescHeap)) != S_OK)
        @         return FALSE;
        @ }
        @ SIZE_T rtvDescriptorSize = m_pd3dDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
        @ D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = m_pd3dRtvDescHeap->GetCPUDescriptorHandleForHeapStart();
        @ for (INT i = 0; i < NUM_BACK_BUFFERS; i++)
        @ {
        @     m_mainRenderTargetDescriptor[i] = rtvHandle;
        @     rtvHandle.ptr += rtvDescriptorSize;
        @ }
        @ {
        @     D3D12_DESCRIPTOR_HEAP_DESC desc = {};
        @     desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
        @     desc.NumDescriptors = 2;
        @     desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
        @     if (m_pd3dDevice->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&m_pd3dSrvDescHeap)) != S_OK)
        @         return FALSE;
        @ }
        @ {
        @     D3D12_COMMAND_QUEUE_DESC desc = {};
        @     desc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
        @     desc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
        @     desc.NodeMask = 1;
        @     if (m_pd3dDevice->CreateCommandQueue(&desc, IID_PPV_ARGS(&m_pd3dCommandQueue)) != S_OK)
        @         return FALSE;
        @ }
        @ for (INT i = 0; i < NUM_FRAMES_IN_FLIGHT; i++)
        @ {
        @     if (m_pd3dDevice->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&m_frameContext[i].CommandAllocator)) != S_OK)
        @         return FALSE;
        @ }
        @ if (m_pd3dDevice->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, m_frameContext[0].CommandAllocator, nullptr, IID_PPV_ARGS(&m_pd3dCommandList)) != S_OK ||
        @     m_pd3dCommandList->Close() != S_OK)
        @     return FALSE;
        @ if (m_pd3dDevice->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&m_fence)) != S_OK)
        @     return FALSE;
        @ m_fenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);
        @ if (m_fenceEvent == nullptr) return FALSE;
        @ IDXGIFactory4* dxgiFactory = nullptr;
        @ IDXGISwapChain1* swapChain1 = nullptr;
        @ if (CreateDXGIFactory1(IID_PPV_ARGS(&dxgiFactory)) != S_OK)
        @     return FALSE;
        @ if (dxgiFactory->CreateSwapChainForHwnd(m_pd3dCommandQueue, (HWND)@<窗口句柄>, &sd, nullptr, nullptr, &swapChain1) != S_OK)
        @     return FALSE;
        @ if (swapChain1->QueryInterface(IID_PPV_ARGS(&m_pSwapChain)) != S_OK)
        @     return FALSE;
        @ swapChain1->Release();
        @ dxgiFactory->Release();
        @ m_pSwapChain->SetMaximumFrameLatency(NUM_BACK_BUFFERS);
        @ m_hSwapChainWaitableObject = m_pSwapChain->GetFrameLatencyWaitableObject();
        @ this->@<创建渲染目标>();
        @ return TRUE;
    }

    方法 释放设备 <公开 折叠>
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ this->@<释放渲染目标>();
        @ if (m_pSwapChain) { m_pSwapChain->SetFullscreenState(false, nullptr); m_pSwapChain->Release(); m_pSwapChain = nullptr; }
        @ if (m_hSwapChainWaitableObject != nullptr) { CloseHandle(m_hSwapChainWaitableObject); }
        @ for (INT i = 0; i < NUM_FRAMES_IN_FLIGHT; i++)
        @     if (m_frameContext[i].CommandAllocator) { m_frameContext[i].CommandAllocator->Release(); m_frameContext[i].CommandAllocator = nullptr; }
        @ if (m_pd3dCommandQueue) { m_pd3dCommandQueue->Release(); m_pd3dCommandQueue = nullptr; }
        @ if (m_pd3dCommandList) { m_pd3dCommandList->Release(); m_pd3dCommandList = nullptr; }
        @ if (m_pd3dRtvDescHeap) { m_pd3dRtvDescHeap->Release(); m_pd3dRtvDescHeap = nullptr; }
        @ if (m_pd3dSrvDescHeap) { m_pd3dSrvDescHeap->Release(); m_pd3dSrvDescHeap = nullptr; }
        @ if (m_fence) { m_fence->Release(); m_fence = nullptr; }
        @ if (m_fenceEvent) { CloseHandle(m_fenceEvent); m_fenceEvent = nullptr; }
        @ if (m_pd3dDevice) { m_pd3dDevice->Release(); m_pd3dDevice = nullptr; }
    }

    方法 创建渲染目标 <公开 折叠>
    {
        @ for (INT i = 0; i < NUM_BACK_BUFFERS; i++)
        @ {
        @     ID3D12Resource* pBackBuffer = nullptr;
        @     m_pSwapChain->GetBuffer(i, IID_PPV_ARGS(&pBackBuffer));
        @     m_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, m_mainRenderTargetDescriptor[i]);
        @     m_mainRenderTargetResource[i] = pBackBuffer;
        @ }
    }

    方法 释放渲染目标 <公开 折叠>
    {
        @ this->@<等待最后一帧>();
        @ for (INT i = 0; i < NUM_BACK_BUFFERS; i++)
        @     if (m_mainRenderTargetResource[i]) { m_mainRenderTargetResource[i]->Release(); m_mainRenderTargetResource[i] = nullptr; }
    }

    方法 等待最后一帧 <公开 折叠>
    {
        @ FrameContext* frameCtx = &m_frameContext[m_frameIndex % NUM_FRAMES_IN_FLIGHT];
        @ UINT64 fenceValue = frameCtx->FenceValue;
        @ if (fenceValue == 0)
        @     return; // No fence was signaled
        @ frameCtx->FenceValue = 0;
        @ if (m_fence->GetCompletedValue() >= fenceValue)
        @     return;
        @ m_fence->SetEventOnCompletion(fenceValue, m_fenceEvent);
        @ ::WaitForSingleObject(m_fenceEvent, INFINITE);
    }

    方法 等待下一帧资源 <公开 类型 = 变整数 返回值注释 = "FrameContext*" 折叠 @禁止流程检查 = 真>
    {
        @ UINT nextFrameIndex = m_frameIndex + 1;
        @ m_frameIndex = nextFrameIndex;
        @ HANDLE waitableObjects[] = { m_hSwapChainWaitableObject, nullptr };
        @ DWORD numWaitableObjects = 1;
        @ FrameContext* frameCtx = &m_frameContext[nextFrameIndex % NUM_FRAMES_IN_FLIGHT];
        @ UINT64 fenceValue = frameCtx->FenceValue;
        @ if (fenceValue != 0) // means no fence was signaled
        @ {
        @     frameCtx->FenceValue = 0;
        @     m_fence->SetEventOnCompletion(fenceValue, m_fenceEvent);
        @     waitableObjects[1] = m_fenceEvent;
        @     numWaitableObjects = 2;
        @ }
        @ WaitForMultipleObjects(numWaitableObjects, waitableObjects, TRUE, INFINITE);
        @ return (INT_P)frameCtx;
    }

    方法 重置尺寸 <公开 折叠>
    参数 宽度 <类型 = 整数>
    参数 高度 <类型 = 整数>
    {
        @ this->@<等待最后一帧>();
        @ this->@<释放渲染目标>();
        @ HRESULT result = m_pSwapChain->ResizeBuffers(0, @<宽度>, @<高度>, DXGI_FORMAT_UNKNOWN, DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT);
        @ assert(SUCCEEDED(result) && "Failed to resize swapchain.");
        @ this->@<创建渲染目标>();
    }

    方法 准备 <公开>

    方法 渲染 <公开 折叠>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ FrameContext* frameCtx = (FrameContext*)this->@<等待下一帧资源>();
        @ UINT backBufferIdx = m_pSwapChain->GetCurrentBackBufferIndex();
        @ frameCtx->CommandAllocator->Reset();

        @ D3D12_RESOURCE_BARRIER barrier = {};
        @ barrier.Type                   = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
        @ barrier.Flags                  = D3D12_RESOURCE_BARRIER_FLAG_NONE;
        @ barrier.Transition.pResource   = m_mainRenderTargetResource[backBufferIdx];
        @ barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
        @ barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
        @ barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_RENDER_TARGET;
        @ m_pd3dCommandList->Reset(frameCtx->CommandAllocator, nullptr);
        @ m_pd3dCommandList->ResourceBarrier(1, &barrier);

        // Render Dear ImGui graphics
        @ ImGui::Render();
        @ ImVec4* clear_color = @<背景颜色>.pdata();
        @ const float clear_color_with_alpha[4] = { clear_color->x * clear_color->w, clear_color->y * clear_color->w, clear_color->z * clear_color->w, clear_color->w };
        @ m_pd3dCommandList->ClearRenderTargetView(m_mainRenderTargetDescriptor[backBufferIdx], clear_color_with_alpha, 0, nullptr);
        @ m_pd3dCommandList->OMSetRenderTargets(1, &m_mainRenderTargetDescriptor[backBufferIdx], FALSE, nullptr);
        @ m_pd3dCommandList->SetDescriptorHeaps(1, &m_pd3dSrvDescHeap);
        @ ImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), m_pd3dCommandList);
        @ barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
        @ barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_PRESENT;
        @ m_pd3dCommandList->ResourceBarrier(1, &barrier);
        @ m_pd3dCommandList->Close();

        @ m_pd3dCommandQueue->ExecuteCommandLists(1, (ID3D12CommandList* const*)&m_pd3dCommandList);
        // Update and Render additional Platform Windows
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault(nullptr, (void*)m_pd3dCommandList);
        @ }
        @ m_pSwapChain->Present(1, 0); // Present with vsync

        @ UINT64 fenceValue = m_fenceLastSignaledValue + 1;
        @ m_pd3dCommandQueue->Signal(m_fence, fenceValue);
        @ m_fenceLastSignaledValue = fenceValue;
        @ frameCtx->FenceValue = fenceValue;
    }

    # SDL ---

    变量 局_窗口句柄 <类型 = 变整数>

    方法 加载_SDL <公开 类型 = 逻辑型 折叠 @视窗.外部头文件 = "SDL_syswm.h">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ SDL_SysWMinfo wmInfo;
        @ SDL_VERSION(&wmInfo.version);
        @ SDL_GetWindowWMInfo((SDL_Window*)@<窗口句柄>, &wmInfo);
        @ @<局_窗口句柄> = (INT_P)wmInfo.info.win.window;
        返回 (创建设备 (局_窗口句柄))
    }

    方法 渲染_SDL <公开 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ @sn<this>.@<渲染>(@<背景颜色>)
    }

    方法 加载字体纹理 <公开>

    方法 清理 <公开 折叠>
    {
        释放设备 (局_窗口句柄)
    }
}

类 IM_OpenGL渲染器 <公开 注释 = "基于现代OpenGL的渲染器后端,支持桌面OpenGL版本: 2.x 3.x 4.x" 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.外部头文件 = "imgui\\backends\\imgui_impl_opengl3.h\r\nglad\\glad.h"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_opengl3.cpp\r\nFrameWork\\glad\\glad.c">
{

    # @begin
    # <> <global>
    # <> <include>
    # static HGLRC g_hRC;
    # <> </include>
    # <> </global>
    # <> <include>
    # struct WGL_WindowData { HDC hDC;};
    # WGL_WindowData m_MainWindow { 0 };
    # static void Hook_Renderer_CreateWindow(ImGuiViewport* viewport)
    # {
    #     WGL_WindowData* data = IM_NEW(WGL_WindowData);
    #     @<CreateDeviceWGL>((HWND)viewport->PlatformHandle, data);
    #     viewport->RendererUserData = data;
    # }
    # static void Hook_Renderer_DestroyWindow(ImGuiViewport* viewport)
    # {
    #     if (viewport->RendererUserData != NULL)
    #     {
    #         WGL_WindowData* data = (WGL_WindowData*)viewport->RendererUserData;
    #         wglMakeCurrent(NULL, NULL);
    #         ::ReleaseDC((HWND)viewport->PlatformHandle, data->hDC);
    #         IM_DELETE(data);
    #         viewport->RendererUserData = NULL;
    #     }
    # }
    # static void Hook_Platform_RenderWindow(ImGuiViewport* viewport, void*)
    # {
    #     if (WGL_WindowData* data = (WGL_WindowData*)viewport->RendererUserData)
    #         wglMakeCurrent(data->hDC, g_hRC);
    # }
    # static void Hook_Renderer_SwapBuffers(ImGuiViewport* viewport, void*)
    # {
    #     if (WGL_WindowData* data = (WGL_WindowData*)viewport->RendererUserData)
    #         ::SwapBuffers(data->hDC);
    # }
    # <> </include>
    # @end

    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回1,表示OpenGL渲染器)" 折叠>
    {
        返回 (1)
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @禁止流程检查 = 真>
    参数 GLSL版本 <类型 = 文本型 注释 = "请提供一个\"#version XXX\"的GLSL版本,留空为默认值\"#version 130\"."
            注释 = "下列是OpenGL和GLSL版本的对应表:" 注释 = "// OpenGL    GLSL      GLSL" 注释 = "// version   version   string"
            注释 = "//----------------------------------------" 注释 = "//  2.0       110       \"#version 110\""
            注释 = "//  2.1       120       \"#version 120\"" 注释 = "//  3.0       130       \"#version 130\""
            注释 = "//  3.1       140       \"#version 140\"" 注释 = "//  3.2       150       \"#version 150\""
            注释 = "//  3.3       330       \"#version 330 core\""
            注释 = "//  4.0       400       \"#version 400 core\""
            注释 = "//  4.1       410       \"#version 410 core\""
            注释 = "//  4.2       420       \"#version 410 core\""
            注释 = "//  4.3       430       \"#version 430 core\""
            注释 = "//  ES 2.0    100       \"#version 100\"      = WebGL 1.0"
            注释 = "//  ES 3.0    300       \"#version 300 es\"   = WebGL 2.0" @默认值 = "#version 330 core">
    {
        @ return ImGui_ImplOpenGL3_Init(@<GLSL版本>.IsEmpty() ? nullptr : PivW2U(@<GLSL版本>).GetText());
    }

    方法 关闭 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_Shutdown()
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_NewFrame()
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = 变整数 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplOpenGL3_RenderDrawData((ImDrawData*)@<绘制数据>)
    }

    方法 加载字体纹理 <公开 注释 = "(可选项)已在\"初始化/关闭/创建框架\"时自动调用" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_CreateFontsTexture()
    }

    方法 销毁字体纹理 <公开 注释 = "(可选项)已在\"初始化/关闭/创建框架\"时自动调用" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_DestroyFontsTexture()
    }

    方法 创建设备对象 <公开 注释 = "(可选项)已在\"初始化/关闭/创建框架\"时自动调用" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_CreateDeviceObjects()
    }

    方法 销毁设备对象 <公开 注释 = "(可选项)已在\"初始化/关闭/创建框架\"时自动调用" 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplOpenGL3_DestroyDeviceObjects()
    }

    # 纹理图片 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ FILE* file = _wfopen(@<文件名>.GetText(), L"rb");
        @ if (!file) return false;
        @ int image_width = 0, image_height = 0;
        @ unsigned char* image_data = stbi_load_from_file(file, &image_width, &image_height, nullptr, 4);
        @ fclose(file);
        @ if (!image_data) return false;
        @ GLuint image_texture;
        @ glGenTextures(1, &image_texture);
        @ glBindTexture(GL_TEXTURE_2D, image_texture);
        // Setup filtering parameters for display
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); // This is required on WebGL for non power-of-two textures
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); // Same
        // Upload pixels into texture
        @ #if defined(GL_UNPACK_ROW_LENGTH) && !defined(__EMSCRIPTEN__)
        @     glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
        @ #endif
        @ glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image_width, image_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);
        @ stbi_image_free(image_data);
        @ @<图片信息.纹理ID> = (INT_P)image_texture;
        @ @<图片信息.宽度> = image_width;
        @ @<图片信息.高度> = image_height;
        @ return true;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCE((WORD)@<图片资源>), RT_RCDATA);
        @ if (!hSrc) return false;
        @ HGLOBAL resdata = ::LoadResource(hModule, hSrc);
        @ if (!resdata) return false;
        @ unsigned char* data = (unsigned char*)::LockResource(resdata);
        @ int len = (int)::SizeofResource(hModule, hSrc);
        @ int image_width = 0, image_height = 0;
        @ unsigned char* image_data = stbi_load_from_memory(data, len, &image_width, &image_height, nullptr, 4);
        @ if (!image_data) return false;
        @ GLuint image_texture;
        @ glGenTextures(1, &image_texture);
        @ glBindTexture(GL_TEXTURE_2D, image_texture);
        // Setup filtering parameters for display
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); // This is required on WebGL for non power-of-two textures
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); // Same
        // Upload pixels into texture
        @ #if defined(GL_UNPACK_ROW_LENGTH) && !defined(__EMSCRIPTEN__)
        @     glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
        @ #endif
        @ glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image_width, image_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);
        @ stbi_image_free(image_data);
        @ @<图片信息.纹理ID> = (INT_P)image_texture;
        @ @<图片信息.宽度> = image_width;
        @ @<图片信息.高度> = image_height;
        @ return true;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ int image_width = 0, image_height = 0;
        @ unsigned char* image_data = stbi_load_from_memory(@<图片数据>.GetPtr(), (int)@<图片数据>.GetSize(), &image_width, &image_height, nullptr, 4);
        @ if (!image_data) return false;
        @ GLuint image_texture;
        @ glGenTextures(1, &image_texture);
        @ glBindTexture(GL_TEXTURE_2D, image_texture);
        // Setup filtering parameters for display
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); // This is required on WebGL for non power-of-two textures
        @ glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); // Same
        // Upload pixels into texture
        @ #if defined(GL_UNPACK_ROW_LENGTH) && !defined(__EMSCRIPTEN__)
        @ glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
        @ #endif
        @ glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image_width, image_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);
        @ stbi_image_free(image_data);
        @ @<图片信息.纹理ID> = (INT_P)image_texture;
        @ @<图片信息.宽度> = image_width;
        @ @<图片信息.高度> = image_height;
        @ return true;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回的图片信息">
    {
        如果 (图片信息.纹理ID != 0)
        {
            @ glDeleteTextures(1, (GLuint*)&@<图片信息.纹理ID>);
        }
        图片信息.重置为空对象 ()
    }

    # Win32平台 ---

    方法 创建设备 <公开 类型 = 逻辑型 折叠 折叠2 @视窗.外部库 = "OpenGL32.lib" @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ @<CreateDeviceWGL>((HWND)@<窗口句柄>, &m_MainWindow);
        @ if (!g_hRC)
        @     g_hRC = wglCreateContext(m_MainWindow.hDC);
        @ wglMakeCurrent(m_MainWindow.hDC, g_hRC);
        @ if (!gladLoadGL())
        @ {
        @     this->@<释放设备>(@<窗口句柄>);
        @     return FALSE;
        @ }
        @ return TRUE;
    }

    方法 释放设备 <公开 折叠>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ wglMakeCurrent(NULL, NULL);
        @ ::ReleaseDC((HWND)@<窗口句柄>, m_MainWindow.hDC);
        @ m_MainWindow.hDC = nullptr;
        @ if (!g_hRC)
        @ {
        @     wglDeleteContext(g_hRC);
        @     g_hRC = nullptr;
        @ }
    }

    方法 重置尺寸 <公开 折叠>
    参数 宽度 <类型 = 整数>
    参数 高度 <类型 = 整数>
    {
        @ glViewport(0, 0, @<宽度>, @<高度>);
    }

    方法 渲染 <公开 折叠>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ ImGui::Render();
        @ ImVec4* clear_color = @<背景颜色>.pdata();
        @ glClearColor(clear_color->x * clear_color->w, clear_color->y * clear_color->w, clear_color->z * clear_color->w, clear_color->w);
        @ glClear(GL_COLOR_BUFFER_BIT);
        @ ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @     wglMakeCurrent(m_MainWindow.hDC, g_hRC);
        @ }
        @ ::SwapBuffers(m_MainWindow.hDC);
    }

    方法 准备 <公开 折叠>
    {
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
        @     platform_io.Renderer_CreateWindow = Hook_Renderer_CreateWindow;
        @     platform_io.Renderer_DestroyWindow = Hook_Renderer_DestroyWindow;
        @     platform_io.Renderer_SwapBuffers = Hook_Renderer_SwapBuffers;
        @     platform_io.Platform_RenderWindow = Hook_Platform_RenderWindow;
        @ }
    }

    方法 CreateDeviceWGL <静态 类型 = 逻辑型 @禁止流程检查 = 真>
    参数 hWnd <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/HWND" @输出名 = "hWnd">
    参数 data <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/WGL_WindowData*" @输出名 = "data">
    {
        @ HDC hDc = ::GetDC(hWnd);
        @ PIXELFORMATDESCRIPTOR pfd = { sizeof(pfd), 1, PFD_DRAW_TO_WINDOW | PFD_DRAW_TO_BITMAP | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER | PFD_STEREO_DONTCARE,
        @                               PFD_TYPE_RGBA, 32, 8, 16, 8, 8, 8, 0, 8, 24, 64, 16, 16, 16, 32, 8, 4, PFD_MAIN_PLANE, 0, 0, 0, 0};
        @ const int pf = ::ChoosePixelFormat(hDc, &pfd);
        @ if (pf == 0 || ::SetPixelFormat(hDc, pf, &pfd) == FALSE)
        @     return FALSE;
        @ ::ReleaseDC(hWnd, hDc);
        @ data->hDC = ::GetDC(hWnd);
        @ return TRUE;
    }

    # GLFW平台 ---

    方法 加载_GLFW <公开 类型 = 逻辑型 注释 = "*适用于GLFW平台" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ (BOOL)gladLoadGL()
    }

    方法 渲染_GLFW <公开 折叠>
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ ImGui::Render();
        @ int display_w, display_h;
        @ glfwGetFramebufferSize((GLFWwindow*)@<窗口句柄>, &display_w, &display_h);
        @ glViewport(0, 0, display_w, display_h);
        @ ImVec4* clear_color = @<背景颜色>.pdata();
        @ glClearColor(clear_color->x * clear_color->w, clear_color->y * clear_color->w, clear_color->z * clear_color->w, clear_color->w);
        @ glClear(GL_COLOR_BUFFER_BIT);
        @ ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     GLFWwindow* backup_current_context = glfwGetCurrentContext();
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @     glfwMakeContextCurrent(backup_current_context);
        @ }
        @ glfwSwapBuffers((GLFWwindow*)@<窗口句柄>); // 双缓冲: 交换缓冲区
    }

    方法 清理 <公开>

    # SDL2平台 ---

    方法 加载_SDL <公开 类型 = 逻辑型 注释 = "*适用于GLFW平台" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    {
        @ (BOOL)gladLoadGL()
    }

    方法 渲染_SDL <公开 折叠 @视窗.外部头文件 = "SDL2\\include\\SDL_opengl.h">
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ ImGui::Render();
        @ ImVec4* clear_color = @<背景颜色>.pdata();
        @ glClearColor(clear_color->x * clear_color->w, clear_color->y * clear_color->w, clear_color->z * clear_color->w, clear_color->w);
        @ glClear(GL_COLOR_BUFFER_BIT);
        @ ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     SDL_Window* backup_current_window = SDL_GL_GetCurrentWindow();
        @     SDL_GLContext backup_current_context = SDL_GL_GetCurrentContext();
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @     SDL_GL_MakeCurrent(backup_current_window, backup_current_context);
        @ }
        @ SDL_GL_SwapWindow((SDL_Window*)@<窗口句柄>);
    }
}

类 IM_Vulkan渲染器 <公开 注释 = "基于Vulkan的渲染器后端,Vulkan是OpenGL的下一代GPU API,目的就是取代OpenGL."
        注释 = "注意旧型号的显卡和显卡驱动可能不支持Vulkan." 折叠 折叠2 @文档 = "category = \"渲染器\""
        @视窗.预定义宏 = "ImTextureID=ImU64\r\nGLFW_INCLUDE_VULKAN"
        @视窗.外部头文件 = "imgui\\backends\\imgui_impl_vulkan.h"
        @视窗.外部源文件 = "imgui\\backends\\imgui_impl_vulkan.cpp"
        @视窗.外部库 = "FrameWork\\vulkan\\$(p)\\vulkan-1.lib" @视窗.附属文件 = "FrameWork\\vulkan\\$(p)\\vulkan-1.dll">
{
    方法 渲染器类型 <公开 属性读 类型 = 整数 注释 = "返回渲染器类型(固定返回2,表示Vulkan渲染器)" 折叠>
    {
        返回 (2)
    }

    方法 加载_GLFW <公开 类型 = 逻辑型 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ if (!glfwVulkanSupported()) return FALSE;
        @ ImVector<const char*> extensions;
        @ uint32_t extensions_count = 0;
        @ const char** glfw_extensions = glfwGetRequiredInstanceExtensions(&extensions_count);
        @ for (uint32_t i = 0; i < extensions_count; i++)
        @     extensions.push_back(glfw_extensions[i]);
        // SetupVulkan ---
        @ VkResult err;
        @ // Create Vulkan Instance
        @ {
        @     VkInstanceCreateInfo create_info = {};
        @     create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
        @     // Enumerate available extensions
        @     uint32_t properties_count;
        @     ImVector<VkExtensionProperties> properties;
        @     vkEnumerateInstanceExtensionProperties(nullptr, &properties_count, nullptr);
        @     properties.resize(properties_count);
        @     err = vkEnumerateInstanceExtensionProperties(nullptr, &properties_count, properties.Data);
        @     check_vk_result(err);
        @     // Enable required extensions
        @     for (const VkExtensionProperties& p : properties) {
        @         if (strcmp(p.extensionName, VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME) == 0)
        @             extensions.push_back(VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);
        @     }
        @ #ifdef VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME
        @     for (const VkExtensionProperties& p : properties) {
        @         if (strcmp(p.extensionName, VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME) == 0)
        @             extensions.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
        @             create_info.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
        @     }
        @ #endif
        @     // Create Vulkan Instance
        @     create_info.enabledExtensionCount = (uint32_t)extensions.Size;
        @     create_info.ppEnabledExtensionNames = extensions.Data;
        @     err = vkCreateInstance(&create_info, g_Allocator, &g_Instance);
        @     check_vk_result(err);
        @ }
        @ // Select Physical Device (GPU)
        @ uint32_t gpu_count;
        @ err = vkEnumeratePhysicalDevices(g_Instance, &gpu_count, nullptr);
        @ check_vk_result(err);
        @ IM_ASSERT(gpu_count > 0);
        @ ImVector<VkPhysicalDevice> gpus;
        @ gpus.resize(gpu_count);
        @ err = vkEnumeratePhysicalDevices(g_Instance, &gpu_count, gpus.Data);
        @ check_vk_result(err);
        @ for (VkPhysicalDevice& device : gpus)
        @ {
        @     VkPhysicalDeviceProperties properties;
        @     vkGetPhysicalDeviceProperties(device, &properties);
        @     if (properties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
        @         g_PhysicalDevice = device; break;
        @     }
        @ }
        @ if (g_PhysicalDevice == VK_NULL_HANDLE && gpu_count > 0)
        @     g_PhysicalDevice = gpus[0];
        @ // Select graphics queue family
        @ {
        @     uint32_t count;
        @     vkGetPhysicalDeviceQueueFamilyProperties(g_PhysicalDevice, &count, nullptr);
        @     VkQueueFamilyProperties* queues = (VkQueueFamilyProperties*)malloc(sizeof(VkQueueFamilyProperties) * count);
        @     vkGetPhysicalDeviceQueueFamilyProperties(g_PhysicalDevice, &count, queues);
        @     for (uint32_t i = 0; i < count; i++)
        @         if (queues[i].queueFlags & VK_QUEUE_GRAPHICS_BIT)
        @         {
        @             g_QueueFamily = i; break;
        @         }
        @     free(queues);
        @     IM_ASSERT(g_QueueFamily != (uint32_t)-1);
        @ }
        @ // Create Logical Device (with 1 queue)
        @ {
        @     ImVector<const char*> device_extensions;
        @     device_extensions.push_back("VK_KHR_swapchain");
        @     // Enumerate physical device extension
        @     uint32_t properties_count;
        @     ImVector<VkExtensionProperties> properties;
        @     vkEnumerateDeviceExtensionProperties(g_PhysicalDevice, nullptr, &properties_count, nullptr);
        @     properties.resize(properties_count);
        @     vkEnumerateDeviceExtensionProperties(g_PhysicalDevice, nullptr, &properties_count, properties.Data);
        @ #ifdef VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME
        @     for (const VkExtensionProperties& p : properties) {
        @         if (strcmp(p.extensionName, VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME) == 0)
        @             device_extensions.push_back(VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME);
        @     }
        @ #endif
        @     const float queue_priority[] = { 1.0f };
        @     VkDeviceQueueCreateInfo queue_info[1] = {};
        @     queue_info[0].sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
        @     queue_info[0].queueFamilyIndex = g_QueueFamily;
        @     queue_info[0].queueCount = 1;
        @     queue_info[0].pQueuePriorities = queue_priority;
        @     VkDeviceCreateInfo create_info = {};
        @     create_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
        @     create_info.queueCreateInfoCount = sizeof(queue_info) / sizeof(queue_info[0]);
        @     create_info.pQueueCreateInfos = queue_info;
        @     create_info.enabledExtensionCount = (uint32_t)device_extensions.Size;
        @     create_info.ppEnabledExtensionNames = device_extensions.Data;
        @     err = vkCreateDevice(g_PhysicalDevice, &create_info, g_Allocator, &g_Device);
        @     check_vk_result(err);
        @     vkGetDeviceQueue(g_Device, g_QueueFamily, 0, &g_Queue);
        @ }
        @ // Create Descriptor Pool
        @ {
        @     VkDescriptorPoolSize pool_sizes[] =
        @     {
        @         { VK_DESCRIPTOR_TYPE_SAMPLER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1000 },
        @         { VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 1000 },
        @         { VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 1000 },
        @         { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, 1000 },
        @         { VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, 1000 }
        @     };
        @     VkDescriptorPoolCreateInfo pool_info = {};
        @     pool_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
        @     pool_info.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
        @     pool_info.maxSets = 1000 * IM_ARRAYSIZE(pool_sizes);
        @     pool_info.poolSizeCount = (uint32_t)IM_ARRAYSIZE(pool_sizes);
        @     pool_info.pPoolSizes = pool_sizes;
        @     err = vkCreateDescriptorPool(g_Device, &pool_info, g_Allocator, &g_DescriptorPool);
        @     check_vk_result(err);
        @ }
        // ---
        @ VkSurfaceKHR surface;
        @ err = glfwCreateWindowSurface(g_Instance, (GLFWwindow*)@<窗口句柄>, g_Allocator, &surface);
        @ check_vk_result(err);
        @ int width, height;
        @ glfwGetFramebufferSize((GLFWwindow*)@<窗口句柄>, &width, &height);
        @ // SetupVulkanWindow
        @ m_MainWindowData.Surface = surface;
        @ // Check for WSI support
        @ VkBool32 res;
        @ vkGetPhysicalDeviceSurfaceSupportKHR(g_PhysicalDevice, g_QueueFamily, m_MainWindowData.Surface, &res);
        @ if (res != VK_TRUE) exit(-1);
        @ // Select Surface Format
        @ const VkFormat requestSurfaceImageFormat[] = { VK_FORMAT_B8G8R8A8_UNORM, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_B8G8R8_UNORM, VK_FORMAT_R8G8B8_UNORM };
        @ const VkColorSpaceKHR requestSurfaceColorSpace = VK_COLORSPACE_SRGB_NONLINEAR_KHR;
        @ m_MainWindowData.SurfaceFormat = ImGui_ImplVulkanH_SelectSurfaceFormat(g_PhysicalDevice, m_MainWindowData.Surface, requestSurfaceImageFormat, (size_t)IM_ARRAYSIZE(requestSurfaceImageFormat), requestSurfaceColorSpace);
        @ // Select Present Mode
        @ #ifdef IMGUI_UNLIMITED_FRAME_RATE
        @     VkPresentModeKHR present_modes[] = { VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_IMMEDIATE_KHR, VK_PRESENT_MODE_FIFO_KHR };
        @ #else
        @     VkPresentModeKHR present_modes[] = { VK_PRESENT_MODE_FIFO_KHR };
        @ #endif
        @ m_MainWindowData.PresentMode = ImGui_ImplVulkanH_SelectPresentMode(g_PhysicalDevice, m_MainWindowData.Surface, &present_modes[0], IM_ARRAYSIZE(present_modes));
        @ // Create SwapChain, RenderPass, Framebuffer, etc.
        @ IM_ASSERT(g_MinImageCount >= 2);
        @ ImGui_ImplVulkanH_CreateOrResizeWindow(g_Instance, g_PhysicalDevice, g_Device, &m_MainWindowData, g_QueueFamily, g_Allocator, width, height, g_MinImageCount);
        @ return TRUE;
    }

    方法 初始化 <公开 类型 = 逻辑型 注释 = "在\"创建设备\"和\"ImGui.创建环境()\"后才能调用." 折叠 @禁止流程检查 = 真>
    {
        @ ImGui_ImplVulkan_InitInfo init_info = {
        @         g_Instance, g_PhysicalDevice, g_Device, g_QueueFamily, g_Queue, g_PipelineCache, g_DescriptorPool, 0,
        @         g_MinImageCount, m_MainWindowData.ImageCount, VK_SAMPLE_COUNT_1_BIT, g_Allocator, @sn<current_class>::check_vk_result
        @ };
        @ return ImGui_ImplVulkan_Init(&init_info, m_MainWindowData.RenderPass);
    }

    方法 新建帧 <公开 折叠 @嵌入式方法 = "">
    {
        @ ImGui_ImplVulkan_NewFrame()
    }

    方法 关闭 <公开 折叠>
    {
        @ VkResult err = vkDeviceWaitIdle(g_Device);
        @ check_vk_result(err);
        @ ImGui_ImplVulkan_Shutdown();
    }

    方法 渲染数据 <公开 折叠 @嵌入式方法 = "">
    参数 绘制数据 <类型 = 变整数 注释 = "由\"ImGui.取渲染数据()\"返回">
    {
        @ ImGui_ImplVulkan_RenderDrawData((ImDrawData*)@<绘制数据>)
    }

    方法 渲染_GLFW <公开 折叠>
    参数 窗口句柄 <类型 = 变整数 @默认值 = 0>
    参数 背景颜色 <类型 = ImVec4 注释 = "必须为4个以上成员的单精度小数数组的地址">
    {
        @ ImGui::Render();
        @ ImDrawData* main_draw_data = ImGui::GetDrawData();
        @ const bool main_is_minimized = (main_draw_data->DisplaySize.x <= 0.0f || main_draw_data->DisplaySize.y <= 0.0f);
        @ ImVec4* clear_color = @<背景颜色>.pdata();
        @ m_MainWindowData.ClearValue.color.float32[0] = clear_color->x * clear_color->w;
        @ m_MainWindowData.ClearValue.color.float32[1] = clear_color->y * clear_color->w;
        @ m_MainWindowData.ClearValue.color.float32[2] = clear_color->z * clear_color->w;
        @ m_MainWindowData.ClearValue.color.float32[3] = clear_color->w;
        @ if (!main_is_minimized)
        @     @<_FrameRender>(main_draw_data);
        // Update and Render additional Platform Windows
        @ if (ImGui::GetIO().ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        @ {
        @     ImGui::UpdatePlatformWindows();
        @     ImGui::RenderPlatformWindowsDefault();
        @ }
        // Present Main Platform Window
        @ if (!main_is_minimized)
        @     @<_FramePresent>();
    }

    方法 加载字体纹理 <公开 折叠>
    {
        @ VkCommandPool command_pool = m_MainWindowData.Frames[m_MainWindowData.FrameIndex].CommandPool;
        @ VkCommandBuffer command_buffer = m_MainWindowData.Frames[m_MainWindowData.FrameIndex].CommandBuffer;
        @ VkResult err = vkResetCommandPool(g_Device, command_pool, 0);
        @ check_vk_result(err);
        @ VkCommandBufferBeginInfo begin_info = {};
        @ begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        @ begin_info.flags |= VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
        @ err = vkBeginCommandBuffer(command_buffer, &begin_info);
        @ check_vk_result(err);
        @ ImGui_ImplVulkan_CreateFontsTexture(command_buffer);
        @ VkSubmitInfo end_info = {};
        @ end_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        @ end_info.commandBufferCount = 1;
        @ end_info.pCommandBuffers = &command_buffer;
        @ err = vkEndCommandBuffer(command_buffer);
        @ check_vk_result(err);
        @ err = vkQueueSubmit(g_Queue, 1, &end_info, VK_NULL_HANDLE);
        @ check_vk_result(err);
        @ err = vkDeviceWaitIdle(g_Device);
        @ check_vk_result(err);
        @ ImGui_ImplVulkan_DestroyFontUploadObjects();
    }

    方法 清理 <公开 折叠>
    {
        @ ImGui_ImplVulkanH_DestroyWindow(g_Instance, g_Device, &m_MainWindowData, g_Allocator);
        @ vkDestroyDescriptorPool(g_Device, g_DescriptorPool, g_Allocator);
        @ vkDestroyDevice(g_Device, g_Allocator);
        @ vkDestroyInstance(g_Instance, g_Allocator);
    }

    方法 重置尺寸 <公开 折叠>
    参数 宽度 <类型 = 整数>
    参数 高度 <类型 = 整数>

    方法 _FrameRender <注释 = "仅限内部嵌入式使用" 折叠>
    参数 draw_data <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/ImDrawData*" @输出名 = "draw_data">
    {
        @ VkResult err;
        @ VkSemaphore image_acquired_semaphore  = m_MainWindowData.FrameSemaphores[m_MainWindowData.SemaphoreIndex].ImageAcquiredSemaphore;
        @ VkSemaphore render_complete_semaphore = m_MainWindowData.FrameSemaphores[m_MainWindowData.SemaphoreIndex].RenderCompleteSemaphore;
        @ err = vkAcquireNextImageKHR(g_Device, m_MainWindowData.Swapchain, UINT64_MAX, image_acquired_semaphore, VK_NULL_HANDLE, &m_MainWindowData.FrameIndex);
        @ if (err == VK_ERROR_OUT_OF_DATE_KHR || err == VK_SUBOPTIMAL_KHR)
        @ {
        @     g_SwapChainRebuild = true; return;
        @ }
        @ check_vk_result(err);
        @ ImGui_ImplVulkanH_Frame* fd = &m_MainWindowData.Frames[m_MainWindowData.FrameIndex];
        @ {
        @     err = vkWaitForFences(g_Device, 1, &fd->Fence, VK_TRUE, UINT64_MAX);    // wait indefinitely instead of periodically checking
        @     check_vk_result(err);
        @     err = vkResetFences(g_Device, 1, &fd->Fence);
        @     check_vk_result(err);
        @ }
        @ {
        @     err = vkResetCommandPool(g_Device, fd->CommandPool, 0);
        @     check_vk_result(err);
        @     VkCommandBufferBeginInfo info = {};
        @     info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        @     info.flags |= VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
        @     err = vkBeginCommandBuffer(fd->CommandBuffer, &info);
        @     check_vk_result(err);
        @ }
        @ {
        @     VkRenderPassBeginInfo info = {};
        @     info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
        @     info.renderPass = m_MainWindowData.RenderPass;
        @     info.framebuffer = fd->Framebuffer;
        @     info.renderArea.extent.width = m_MainWindowData.Width;
        @     info.renderArea.extent.height = m_MainWindowData.Height;
        @     info.clearValueCount = 1;
        @     info.pClearValues = &m_MainWindowData.ClearValue;
        @     vkCmdBeginRenderPass(fd->CommandBuffer, &info, VK_SUBPASS_CONTENTS_INLINE);
        @ }
        // Record dear imgui primitives into command buffer
        @ ImGui_ImplVulkan_RenderDrawData(draw_data, fd->CommandBuffer);
        // Submit command buffer
        @ vkCmdEndRenderPass(fd->CommandBuffer);
        @ {
        @     VkPipelineStageFlags wait_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        @     VkSubmitInfo info = {};
        @     info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        @     info.waitSemaphoreCount = 1;
        @     info.pWaitSemaphores = &image_acquired_semaphore;
        @     info.pWaitDstStageMask = &wait_stage;
        @     info.commandBufferCount = 1;
        @     info.pCommandBuffers = &fd->CommandBuffer;
        @     info.signalSemaphoreCount = 1;
        @     info.pSignalSemaphores = &render_complete_semaphore;
        @     err = vkEndCommandBuffer(fd->CommandBuffer);
        @     check_vk_result(err);
        @     err = vkQueueSubmit(g_Queue, 1, &info, fd->Fence);
        @     check_vk_result(err);
        @ }
    }

    方法 _FramePresent <注释 = "仅限内部嵌入式使用" 折叠>
    {
        @ if (g_SwapChainRebuild) return;
        @ VkSemaphore render_complete_semaphore = m_MainWindowData.FrameSemaphores[m_MainWindowData.SemaphoreIndex].RenderCompleteSemaphore;
        @ VkPresentInfoKHR info = {};
        @ info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
        @ info.waitSemaphoreCount = 1;
        @ info.pWaitSemaphores = &render_complete_semaphore;
        @ info.swapchainCount = 1;
        @ info.pSwapchains = &m_MainWindowData.Swapchain;
        @ info.pImageIndices = &m_MainWindowData.FrameIndex;
        @ VkResult err = vkQueuePresentKHR(g_Queue, &info);
        @ if (err == VK_ERROR_OUT_OF_DATE_KHR || err == VK_SUBOPTIMAL_KHR)
        @ {
        @     g_SwapChainRebuild = true; return;
        @ }
        @ check_vk_result(err);
        @ m_MainWindowData.SemaphoreIndex = (m_MainWindowData.SemaphoreIndex + 1) % m_MainWindowData.ImageCount; // Now we can use the next set of semaphores
    }

    # 纹理图片 ---

    方法 加载图片文件 <公开 类型 = 逻辑型 注释 = "从指定的图片文件加载纹理到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_Vulkan渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 文件名 <类型 = 文本型 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (g_Device == VK_NULL_HANDLE) return false;
        @ FILE* file = _wfopen(@<文件名>.GetText(), L"rb");
        @ if (!file) return false;
        @ unsigned char* image_data = stbi_load_from_file(file, &@<图片信息.宽度>, &@<图片信息.高度>, nullptr, 4);
        @ fclose(file);
        @ if (!image_data) return false;
        @ MyTextureData* tex_data = new MyTextureData{};
        @ @<图片信息._内部数据> = (INT_P)tex_data;
        @ tex_data->Width = @<图片信息.宽度>;
        @ tex_data->Height = @<图片信息.高度>;
        @ tex_data->Channels = 4;
        @ @<_加载图片>(image_data, tex_data);
        @ @<图片信息.纹理ID> = (INT_P)tex_data->DS;
        @ return true;
    }

    方法 加载图片资源 <公开 类型 = 逻辑型 注释 = "将程序文件中的图片资源加载到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_Vulkan渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片资源 <类型 = 视窗文件资源 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (g_Device == VK_NULL_HANDLE) return false;
        @ HMODULE hModule = g_objVolApp.GetInstanceHandle();
        @ HRSRC hSrc = ::FindResourceW(hModule, MAKEINTRESOURCE((WORD)@<图片资源>), RT_RCDATA);
        @ if (!hSrc) return false;
        @ HGLOBAL resdata = ::LoadResource(hModule, hSrc);
        @ if (!resdata) return false;
        @ unsigned char* data = (unsigned char*)::LockResource(resdata);
        @ int len = (int)::SizeofResource(hModule, hSrc);
        @ unsigned char* image_data = stbi_load_from_memory(data, len, &@<图片信息.宽度>, &@<图片信息.高度>, nullptr, 4);
        @ if (!image_data) return false;
        @ MyTextureData* tex_data = new MyTextureData{};
        @ tex_data->Width = @<图片信息.宽度>;
        @ tex_data->Height = @<图片信息.高度>;
        @ tex_data->Channels = 4;
        @ @<图片信息._内部数据> = (INT_P)tex_data;
        @ @<_加载图片>(image_data, tex_data);
        @ @<图片信息.纹理ID> = (INT_P)tex_data->DS;
        @ return true;
    }

    方法 加载图片字节集 <公开 类型 = 逻辑型 注释 = "从指定的图片字节集加载纹理到渲染器中,不再使用时请调用\"释放纹理\"."
            注释 = "注意: 只能在\"IM_Vulkan渲染器.初始化\"之后使用,即\"准备渲染\"事件中." 返回值注释 = "返回是否加载成功" 折叠 @禁止流程检查 = 真>
    参数 图片数据 <类型 = 字节集类 注释 = "支持格式: jpg,jpeg,png,bmp,psd,tga,gif,hdr,pic,pnm">
    参数 图片信息 <类型 = IM图片信息类 注释 = "成功在此返回图片的信息">
    {
        @ if (g_Device == VK_NULL_HANDLE) return false;
        @ unsigned char* image_data = stbi_load_from_memory(@<图片数据>.GetPtr(), (int)@<图片数据>.GetSize(), &@<图片信息.宽度>, &@<图片信息.高度>, nullptr, 4);
        @ if (!image_data) return false;
        @ MyTextureData* tex_data = new MyTextureData{};
        @ @<图片信息._内部数据> = (INT_P)tex_data;
        @ tex_data->Width = @<图片信息.宽度>;
        @ tex_data->Height = @<图片信息.高度>;
        @ tex_data->Channels = 4;
        @ @<_加载图片>(image_data, tex_data);
        @ @<图片信息.纹理ID> = (INT_P)tex_data->DS;
        @ return true;
    }

    方法 释放纹理 <公开 注释 = "释放图片纹理和对应的内存,之后不能再使用这个纹理ID." 折叠>
    参数 图片信息 <类型 = IM图片信息类 注释 = "提供由\"本对象.加载图片××\"返回图片的信息,释放后会清空信息.">
    {
        如果 (图片信息._内部数据 != 0)
        {
            @ MyTextureData* tex_data = (MyTextureData*)@<图片信息._内部数据>;
            @ vkFreeMemory(g_Device, tex_data->UploadBufferMemory, nullptr);
            @ vkDestroyBuffer(g_Device, tex_data->UploadBuffer, nullptr);
            @ vkDestroySampler(g_Device, tex_data->Sampler, nullptr);
            @ vkDestroyImageView(g_Device, tex_data->ImageView, nullptr);
            @ vkDestroyImage(g_Device, tex_data->Image, nullptr);
            @ vkFreeMemory(g_Device, tex_data->ImageMemory, nullptr);
            @ ImGui_ImplVulkan_RemoveTexture(tex_data->DS);
        }
        图片信息.重置为空对象 ()
    }

    方法 _加载图片 <注释 = "仅限内部嵌入式使用" 折叠>
    参数 image_data <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/unsigned char*" @输出名 = "image_data">
    参数 tex_data <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/MyTextureData*" @输出名 = "tex_data">
    {
        // Calculate allocation size (in number of bytes)
        @ size_t image_size = tex_data->Width * tex_data->Height * tex_data->Channels;
        @ VkResult err;
        // Create the Vulkan image.
        @ {
        @     VkImageCreateInfo info = {};
        @     info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
        @     info.imageType = VK_IMAGE_TYPE_2D;
        @     info.format = VK_FORMAT_R8G8B8A8_UNORM;
        @     info.extent.width = tex_data->Width;
        @     info.extent.height = tex_data->Height;
        @     info.extent.depth = 1;
        @     info.mipLevels = 1;
        @     info.arrayLayers = 1;
        @     info.samples = VK_SAMPLE_COUNT_1_BIT;
        @     info.tiling = VK_IMAGE_TILING_OPTIMAL;
        @     info.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;
        @     info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
        @     info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        @     err = vkCreateImage(g_Device, &info, g_Allocator, &tex_data->Image);
        @     check_vk_result(err);
        @     VkMemoryRequirements req;
        @     vkGetImageMemoryRequirements(g_Device, tex_data->Image, &req);
        @     VkMemoryAllocateInfo alloc_info = {};
        @     alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        @     alloc_info.allocationSize = req.size;
        @     alloc_info.memoryTypeIndex = @<_findMemoryType>(req.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
        @     err = vkAllocateMemory(g_Device, &alloc_info, g_Allocator, &tex_data->ImageMemory);
        @     check_vk_result(err);
        @     err = vkBindImageMemory(g_Device, tex_data->Image, tex_data->ImageMemory, 0);
        @     check_vk_result(err);
        @ }
        // Create the Image View
        @ {
        @     VkImageViewCreateInfo info = {};
        @     info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        @     info.image = tex_data->Image;
        @     info.viewType = VK_IMAGE_VIEW_TYPE_2D;
        @     info.format = VK_FORMAT_R8G8B8A8_UNORM;
        @     info.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        @     info.subresourceRange.levelCount = 1;
        @     info.subresourceRange.layerCount = 1;
        @     err = vkCreateImageView(g_Device, &info, g_Allocator, &tex_data->ImageView);
        @     check_vk_result(err);
        @ }
        // Create Sampler
        @ {
        @     VkSamplerCreateInfo sampler_info{};
        @     sampler_info.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
        @     sampler_info.magFilter = VK_FILTER_LINEAR;
        @     sampler_info.minFilter = VK_FILTER_LINEAR;
        @     sampler_info.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
        @     sampler_info.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT; // outside image bounds just use border color
        @     sampler_info.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        @     sampler_info.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
        @     sampler_info.minLod = -1000;
        @     sampler_info.maxLod = 1000;
        @     sampler_info.maxAnisotropy = 1.0f;
        @     err = vkCreateSampler(g_Device, &sampler_info, g_Allocator, &tex_data->Sampler);
        @     check_vk_result(err);
        @ }
        // Create Descriptor Set using ImGUI's implementation
        @ tex_data->DS = ImGui_ImplVulkan_AddTexture(tex_data->Sampler, tex_data->ImageView, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
        // Create Upload Buffer
        @ {
        @     VkBufferCreateInfo buffer_info = {};
        @     buffer_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        @     buffer_info.size = image_size;
        @     buffer_info.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
        @     buffer_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
        @     err = vkCreateBuffer(g_Device, &buffer_info, g_Allocator, &tex_data->UploadBuffer);
        @     check_vk_result(err);
        @     VkMemoryRequirements req;
        @     vkGetBufferMemoryRequirements(g_Device, tex_data->UploadBuffer, &req);
        @     VkMemoryAllocateInfo alloc_info = {};
        @     alloc_info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        @     alloc_info.allocationSize = req.size;
        @     alloc_info.memoryTypeIndex = @<_findMemoryType>(req.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
        @     err = vkAllocateMemory(g_Device, &alloc_info, g_Allocator, &tex_data->UploadBufferMemory);
        @     check_vk_result(err);
        @     err = vkBindBufferMemory(g_Device, tex_data->UploadBuffer, tex_data->UploadBufferMemory, 0);
        @     check_vk_result(err);
        @ }
        // Upload to Buffer:
        @ {
        @     void* map = NULL;
        @     err = vkMapMemory(g_Device, tex_data->UploadBufferMemory, 0, image_size, 0, &map);
        @     check_vk_result(err);
        @     memcpy(map, image_data, image_size);
        @     VkMappedMemoryRange range[1] = {};
        @     range[0].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
        @     range[0].memory = tex_data->UploadBufferMemory;
        @     range[0].size = image_size;
        @     err = vkFlushMappedMemoryRanges(g_Device, 1, range);
        @     check_vk_result(err);
        @     vkUnmapMemory(g_Device, tex_data->UploadBufferMemory);
        @ }
        // Release image memory using stb
        @ stbi_image_free(image_data);
        // Create a command buffer that will perform following steps when hit in the command queue.
        // TODO: this works in the example, but may need input if this is an acceptable way to access the pool/create the command buffer.
        @ VkCommandPool command_pool = m_MainWindowData.Frames[m_MainWindowData.FrameIndex].CommandPool;
        @ VkCommandBuffer command_buffer;
        @ {
        @     VkCommandBufferAllocateInfo alloc_info{};
        @     alloc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        @     alloc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        @     alloc_info.commandPool = command_pool;
        @     alloc_info.commandBufferCount = 1;
        @     err = vkAllocateCommandBuffers(g_Device, &alloc_info, &command_buffer);
        @     check_vk_result(err);
        @     VkCommandBufferBeginInfo begin_info = {};
        @     begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        @     begin_info.flags |= VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
        @     err = vkBeginCommandBuffer(command_buffer, &begin_info);
        @     check_vk_result(err);
        @ }
        // Copy to Image
        @ {
        @     VkImageMemoryBarrier copy_barrier[1] = {};
        @     copy_barrier[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
        @     copy_barrier[0].dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        @     copy_barrier[0].oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        @     copy_barrier[0].newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        @     copy_barrier[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        @     copy_barrier[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        @     copy_barrier[0].image = tex_data->Image;
        @     copy_barrier[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        @     copy_barrier[0].subresourceRange.levelCount = 1;
        @     copy_barrier[0].subresourceRange.layerCount = 1;
        @     vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_HOST_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, NULL, 0, NULL, 1, copy_barrier);
        @     VkBufferImageCopy region = {};
        @     region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        @     region.imageSubresource.layerCount = 1;
        @     region.imageExtent.width = tex_data->Width;
        @     region.imageExtent.height = tex_data->Height;
        @     region.imageExtent.depth = 1;
        @     vkCmdCopyBufferToImage(command_buffer, tex_data->UploadBuffer, tex_data->Image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);
        @     VkImageMemoryBarrier use_barrier[1] = {};
        @     use_barrier[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
        @     use_barrier[0].srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        @     use_barrier[0].dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
        @     use_barrier[0].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        @     use_barrier[0].newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
        @     use_barrier[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        @     use_barrier[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
        @     use_barrier[0].image = tex_data->Image;
        @     use_barrier[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
        @     use_barrier[0].subresourceRange.levelCount = 1;
        @     use_barrier[0].subresourceRange.layerCount = 1;
        @     vkCmdPipelineBarrier(command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, NULL, 0, NULL, 1, use_barrier);
        @ }
        // End command buffer
        @ {
        @     VkSubmitInfo end_info = {};
        @     end_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        @     end_info.commandBufferCount = 1;
        @     end_info.pCommandBuffers = &command_buffer;
        @     err = vkEndCommandBuffer(command_buffer);
        @     check_vk_result(err);
        @     err = vkQueueSubmit(g_Queue, 1, &end_info, VK_NULL_HANDLE);
        @     check_vk_result(err);
        @     err = vkDeviceWaitIdle(g_Device);
        @     check_vk_result(err);
        @ }
    }

    方法 _findMemoryType <类型 = 整数 注释 = "仅限内部嵌入式使用" 折叠 @禁止流程检查 = 真>
    参数 type_filter <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/uint32_t" @输出名 = "type_filter">
    参数 properties <类型 = 变整数 @视窗.前缀文本 = "/*" @视窗.后缀文本 = "*/VkMemoryPropertyFlags" @输出名 = "properties">
    参数 ""
    {
        @ VkPhysicalDeviceMemoryProperties mem_properties;
        @ vkGetPhysicalDeviceMemoryProperties(g_PhysicalDevice, &mem_properties);
        @ for (uint32_t i = 0; i < mem_properties.memoryTypeCount; i++)
        @     if ((type_filter & (1 << i)) && (mem_properties.memoryTypes[i].propertyFlags & properties) == properties)
        @         return i;
        @ return 0xFFFFFFFF; // Unable to find memoryType
    }

    # SDL2

    方法 加载_SDL <公开 类型 = 逻辑型 折叠 @视窗.外部头文件 = "SDL2\\include\\SDL_vulkan.h" @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ SDL_Window* window = (SDL_Window*)@<窗口句柄>;
        @ ImVector<const char*> extensions;
        @ uint32_t extensions_count = 0;
        @ SDL_Vulkan_GetInstanceExtensions(window, &extensions_count, nullptr);
        @ extensions.resize(extensions_count);
        @ SDL_Vulkan_GetInstanceExtensions(window, &extensions_count, extensions.Data);

        // SetupVulkan ---
        @ VkResult err;
        @ // Create Vulkan Instance
        @ {
        @     VkInstanceCreateInfo create_info = {};
        @     create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
        @     // Enumerate available extensions
        @     uint32_t properties_count;
        @     ImVector<VkExtensionProperties> properties;
        @     vkEnumerateInstanceExtensionProperties(nullptr, &properties_count, nullptr);
        @     properties.resize(properties_count);
        @     err = vkEnumerateInstanceExtensionProperties(nullptr, &properties_count, properties.Data);
        @     check_vk_result(err);
        @     // Enable required extensions
        @     for (const VkExtensionProperties& p : properties) {
        @         if (strcmp(p.extensionName, VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME) == 0)
        @             extensions.push_back(VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);
        @     }
        @ #ifdef VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME
        @     for (const VkExtensionProperties& p : properties) {
        @         if (strcmp(p.extensionName, VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME) == 0)
        @             extensions.push_back(VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME);
        @             create_info.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
        @     }
        @ #endif
        @     // Create Vulkan Instance
        @     create_info.enabledExtensionCount = (uint32_t)extensions.Size;
        @     create_info.ppEnabledExtensionNames = extensions.Data;
        @     err = vkCreateInstance(&create_info, g_Allocator, &g_Instance);
        @     check_vk_result(err);
        @ }
        @ // Select Physical Device (GPU)
        @ uint32_t gpu_count;
        @ err = vkEnumeratePhysicalDevices(g_Instance, &gpu_count, nullptr);
        @ check_vk_result(err);
        @ IM_ASSERT(gpu_count > 0);
        @ ImVector<VkPhysicalDevice> gpus;
        @ gpus.resize(gpu_count);
        @ err = vkEnumeratePhysicalDevices(g_Instance, &gpu_count, gpus.Data);
        @ check_vk_result(err);
        @ for (VkPhysicalDevice& device : gpus)
        @ {
        @     VkPhysicalDeviceProperties properties;
        @     vkGetPhysicalDeviceProperties(device, &properties);
        @     if (properties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
        @         g_PhysicalDevice = device; break;
        @     }
        @ }
        @ if (g_PhysicalDevice == VK_NULL_HANDLE && gpu_count > 0)
        @     g_PhysicalDevice = gpus[0];
        @ // Select graphics queue family
        @ {
        @     uint32_t count;
        @     vkGetPhysicalDeviceQueueFamilyProperties(g_PhysicalDevice, &count, nullptr);
        @     VkQueueFamilyProperties* queues = (VkQueueFamilyProperties*)malloc(sizeof(VkQueueFamilyProperties) * count);
        @     vkGetPhysicalDeviceQueueFamilyProperties(g_PhysicalDevice, &count, queues);
        @     for (uint32_t i = 0; i < count; i++)
        @         if (queues[i].queueFlags & VK_QUEUE_GRAPHICS_BIT)
        @         {
        @             g_QueueFamily = i; break;
        @         }
        @     free(queues);
        @     IM_ASSERT(g_QueueFamily != (uint32_t)-1);
        @ }
        @ // Create Logical Device (with 1 queue)
        @ {
        @     ImVector<const char*> device_extensions;
        @     device_extensions.push_back("VK_KHR_swapchain");
        @     // Enumerate physical device extension
        @     uint32_t properties_count;
        @     ImVector<VkExtensionProperties> properties;
        @     vkEnumerateDeviceExtensionProperties(g_PhysicalDevice, nullptr, &properties_count, nullptr);
        @     properties.resize(properties_count);
        @     vkEnumerateDeviceExtensionProperties(g_PhysicalDevice, nullptr, &properties_count, properties.Data);
        @ #ifdef VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME
        @     for (const VkExtensionProperties& p : properties) {
        @         if (strcmp(p.extensionName, VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME) == 0)
        @             device_extensions.push_back(VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME);
        @     }
        @ #endif
        @     const float queue_priority[] = { 1.0f };
        @     VkDeviceQueueCreateInfo queue_info[1] = {};
        @     queue_info[0].sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
        @     queue_info[0].queueFamilyIndex = g_QueueFamily;
        @     queue_info[0].queueCount = 1;
        @     queue_info[0].pQueuePriorities = queue_priority;
        @     VkDeviceCreateInfo create_info = {};
        @     create_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
        @     create_info.queueCreateInfoCount = sizeof(queue_info) / sizeof(queue_info[0]);
        @     create_info.pQueueCreateInfos = queue_info;
        @     create_info.enabledExtensionCount = (uint32_t)device_extensions.Size;
        @     create_info.ppEnabledExtensionNames = device_extensions.Data;
        @     err = vkCreateDevice(g_PhysicalDevice, &create_info, g_Allocator, &g_Device);
        @     check_vk_result(err);
        @     vkGetDeviceQueue(g_Device, g_QueueFamily, 0, &g_Queue);
        @ }
        @ // Create Descriptor Pool
        @ {
        @     VkDescriptorPoolSize pool_sizes[] =
        @     {
        @         { VK_DESCRIPTOR_TYPE_SAMPLER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1000 },
        @         { VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 1000 },
        @         { VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1000 },
        @         { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 1000 },
        @         { VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, 1000 },
        @         { VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, 1000 }
        @     };
        @     VkDescriptorPoolCreateInfo pool_info = {};
        @     pool_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
        @     pool_info.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
        @     pool_info.maxSets = 1000 * IM_ARRAYSIZE(pool_sizes);
        @     pool_info.poolSizeCount = (uint32_t)IM_ARRAYSIZE(pool_sizes);
        @     pool_info.pPoolSizes = pool_sizes;
        @     err = vkCreateDescriptorPool(g_Device, &pool_info, g_Allocator, &g_DescriptorPool);
        @     check_vk_result(err);
        @ }
        // Create Window Surface ---
        @ VkSurfaceKHR surface;
        @ if (SDL_Vulkan_CreateSurface(window, g_Instance, &surface) == 0)
        @     return FALSE;
        // Create Framebuffers
        @ int width, height;
        @ SDL_GetWindowSize(window, &width, &height);
        // SetupVulkanWindow
        @ m_MainWindowData.Surface = surface;
        @ // Check for WSI support
        @ VkBool32 res;
        @ vkGetPhysicalDeviceSurfaceSupportKHR(g_PhysicalDevice, g_QueueFamily, m_MainWindowData.Surface, &res);
        @ if (res != VK_TRUE) exit(-1);
        @ // Select Surface Format
        @ const VkFormat requestSurfaceImageFormat[] = { VK_FORMAT_B8G8R8A8_UNORM, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_B8G8R8_UNORM, VK_FORMAT_R8G8B8_UNORM };
        @ const VkColorSpaceKHR requestSurfaceColorSpace = VK_COLORSPACE_SRGB_NONLINEAR_KHR;
        @ m_MainWindowData.SurfaceFormat = ImGui_ImplVulkanH_SelectSurfaceFormat(g_PhysicalDevice, m_MainWindowData.Surface, requestSurfaceImageFormat, (size_t)IM_ARRAYSIZE(requestSurfaceImageFormat), requestSurfaceColorSpace);
        @ // Select Present Mode
        @ #ifdef IMGUI_UNLIMITED_FRAME_RATE
        @     VkPresentModeKHR present_modes[] = { VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_IMMEDIATE_KHR, VK_PRESENT_MODE_FIFO_KHR };
        @ #else
        @     VkPresentModeKHR present_modes[] = { VK_PRESENT_MODE_FIFO_KHR };
        @ #endif
        @ m_MainWindowData.PresentMode = ImGui_ImplVulkanH_SelectPresentMode(g_PhysicalDevice, m_MainWindowData.Surface, &present_modes[0], IM_ARRAYSIZE(present_modes));
        @ // Create SwapChain, RenderPass, Framebuffer, etc.
        @ IM_ASSERT(g_MinImageCount >= 2);
        @ ImGui_ImplVulkanH_CreateOrResizeWindow(g_Instance, g_PhysicalDevice, g_Device, &m_MainWindowData, g_QueueFamily, g_Allocator, width, height, g_MinImageCount);
        @ return TRUE;
    }

    方法 渲染_SDL <公开 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 背景颜色 <类型 = ImVec4>
    {
        @ @sn<this>.@<渲染_GLFW>(@<窗口句柄>, @<背景颜色>)
    }

    # @begin
    # <> <include>
    # VkAllocationCallbacks*   g_Allocator        = nullptr;
    # VkInstance               g_Instance         = VK_NULL_HANDLE;
    # VkPhysicalDevice         g_PhysicalDevice   = VK_NULL_HANDLE;
    # VkDevice                 g_Device           = VK_NULL_HANDLE;
    # uint32_t                 g_QueueFamily      = (uint32_t)-1;
    # VkQueue                  g_Queue            = VK_NULL_HANDLE;
    # VkDebugReportCallbackEXT g_DebugReport      = VK_NULL_HANDLE;
    # VkPipelineCache          g_PipelineCache    = VK_NULL_HANDLE;
    # VkDescriptorPool         g_DescriptorPool   = VK_NULL_HANDLE;
    # ImGui_ImplVulkanH_Window m_MainWindowData   = {};
    # uint32_t                 g_MinImageCount    = 2;
    # bool                     g_SwapChainRebuild = false;
    # struct MyTextureData // A struct to manage data related to one image in vulkan
    # {
    #     VkDescriptorSet DS;         // Descriptor set: this is what you'll pass to Image()
    #     int             Width;
    #     int             Height;
    #     int             Channels;
    #
    #     // Need to keep track of these to properly cleanup
    #     VkImageView     ImageView;
    #     VkImage         Image;
    #     VkDeviceMemory  ImageMemory;
    #     VkSampler       Sampler;
    #     VkBuffer        UploadBuffer;
    #     VkDeviceMemory  UploadBufferMemory;
    #     MyTextureData() { memset(this, 0, sizeof(*this)); }
    # };
    # static void check_vk_result(VkResult err)
    # {
    #     if (err == 0) return;
    #     if (err < 0) abort();
    # }
    # <> </include>
    # @end
}

#
