<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" 注释 = "封装了std::vector容器,容器可以当作火山数组类使用,用法基本没什么区别."
        注释 = "注意: std::vector非线程安全,多线程同时读写记得加锁.">

# std::vector 容器的模板基础类 ===

类 容器基础操作类 <公开 基础类 = 扩展对象类 注释 = "封装了容器的基本操作方法,容器(std::vector)相当于火山的数组类." 折叠
        @文档 = "category = \"容器操作.模板类\"" @视窗.外部头文件 = "<vector>" @模板基础类 = 真>
{

    # 分配器

    方法 预分配尺寸 <公开 属性读 类型 = 变整数 注释 = "  返回当前已经分配了空间的成员数量,此容量值会大于或等于数组成员数."
            注释 = "  当容器数组成员数超过此容量,将会重新分配内存.因此合理设置该容量值," 注释 = "可以有效减少重新分配的次数.值越大,批量加入/删除数组成员时所实际需要"
            注释 = "重分配空间的次数就越少,操作速度越快,但是多余内存占用就越大." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.data().capacity())
    }

    方法 预分配尺寸 <公开 属性写 注释 = "  将容器的容量增加到大于或等于新设置的值,这会触发重新分配内存,如果" 注释 = "提供的值小于当前容量,将不执行任何操作."
            注释 = "  当容器数组成员数超过此容量,将会重新分配内存.因此合理设置该容量值," 注释 = "可以有效减少重新分配的次数.值越大,批量加入/删除数组成员时所实际需要"
            注释 = "重分配空间的次数就越少,操作速度越快,但是多余内存占用就越大." 折叠>
    参数 所欲设置的容量 <类型 = 变整数 注释 = "单位为容器的成员数量">
    {
        @ data().reserve(static_cast<size_t>(@<所欲设置的容量>));
    }

    方法 取数组容量 <公开 类型 = 变整数 注释 = "  跟\"预分配尺寸\"一样." 注释 = "  返回当前已经分配了空间的成员数量,此容量值会大于或等于数组成员数."
            注释 = "  当容器数组成员数超过此容量,将会重新分配内存.因此合理设置该容量值," 注释 = "可以有效减少重新分配的次数.值越大,批量加入/删除数组成员时所实际需要"
            注释 = "重分配空间的次数就越少,操作速度越快,但是多余内存占用就越大." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.data().capacity())
    }

    方法 置数组容量 <公开 注释 = "  跟\"预分配尺寸\"一样." 注释 = "  将容器的容量增加到大于或等于新设置的值,这会触发重新分配内存,如果"
            注释 = "提供的值小于当前容量,将不执行任何操作." 注释 = "  当容器数组成员数超过此容量,将会重新分配内存.因此合理设置该容量值,"
            注释 = "可以有效减少重新分配的次数.值越大,批量加入/删除数组成员时所实际需要" 注释 = "重分配空间的次数就越少,操作速度越快,但是多余内存占用就越大." 折叠 @嵌入式方法 = "">
    参数 所欲设置的容量 <类型 = 变整数 注释 = "单位为容器的成员数量">
    {
        @ @sn<this>.data().reserve(static_cast<size_t>(@<所欲设置的容量>))
    }

    方法 取最大可用数 <公开 类型 = 变整数 注释 = "返回容器能够容纳的最大成员数,此值通常反映容器的理论限制,一般限制为小于可用的内存." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.data().max_size())
    }

    方法 释放空闲容量 <公开 注释 = "释放容器中未使用的容量.本方法可能会重新分配内存." 注释 = "执行后会将数组容量(\"取数组容量\")减小到跟\"取成员数\"一样." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.data().shrink_to_fit()
    }

    # 方法

    方法 取容器类指针 <公开 类型 = 变整数 注释 = "获取容器类自身的指针(std::vector<类型> *)." 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.pdata())
    }

    方法 取数组指针 <公开 类型 = 变整数 注释 = "返回当前容器数组内容的数据指针值." 注释 = "除非必要且对指针概念有透彻的了解,不要使用本方法." 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.data().data())
    }

    方法 索引是否有效 <公开 类型 = 逻辑型 注释 = "返回所指定的索引值是否大于等于0且小于本容器数组的成员数." 折叠 @禁止流程检查 = 真>
    参数 所欲检查的索引值 <类型 = 变整数>
    {
        @ return static_cast<size_t>(@<所欲检查的索引值>) >= 0 && static_cast<size_t>(@<所欲检查的索引值>) < data().size();
    }

    方法 取成员数 <公开 类型 = 变整数 注释 = "返回容器数组中的当前已有成员数目" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.data().size())
    }

    方法 取最大索引 <公开 类型 = 变整数 注释 = "返回容器数组中尾成员的索引位置" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.data().size() - 1)
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回本容器数组是否为空" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<BOOL>(@sn<this>.data().empty())
    }

    方法 删除所有成员 <公开 注释 = "删除容器数组中的当前所有成员" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().clear()
    }

    方法 删除成员 <公开 注释 = "删除容器数组中所指定索引范围的单个或多个成员" 折叠>
    参数 删除索引位置 <类型 = 变整数 注释 = "提供所欲删除的索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 结束索引位置 <类型 = 变整数 注释 = "默认为-1,即只删除单个成员." 注释 = "提供所欲删除的尾成员的索引位置,必须大于\"所欲删除首位置\"且小于等于容器数组成员数目."
            @默认值 = -1>
    {
        @ auto it = data().begin();
        @ if (@<结束索引位置> != -1){
        @     data().erase(it + static_cast<size_t>(@<删除索引位置>), it + static_cast<size_t>(@<结束索引位置>) + 1);
        @ } else {
        @     data().erase(it + static_cast<size_t>(@<删除索引位置>), it + static_cast<size_t>(@<删除索引位置>) + 1);
        @ }
    }

    方法 删除尾成员 <公开 注释 = "删除容器数组尾部的单个成员" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().pop_back()
    }

    方法 交换数组 <公开 注释 = "交换两个容器数组的数据内存." 折叠 @嵌入式方法 = "">
    参数 欲交换的数组 <类型 = 容器基础操作类>
    {
        @ @sn<this>.data().swap(@<欲交换的数组>.data())
    }

    方法 是否相等 <公开 类型 = 逻辑型 注释 = "返回所指定容器数组的内容是否与本容器数组相同" 折叠 @嵌入式方法 = "">
    参数 所欲比较的容器 <类型 = 容器基础操作类>
    {
        @ @sn<this>.data() == @<所欲比较的容器>.data()
    }

    方法 取成员指针 <公开 类型 = 变整数 注释 = "返回所指定索引位置处的成员值指针." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 索引 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ reinterpret_cast<INT_P>(&@sn<this>.data()[static_cast<size_t>(@<索引>)])
    }

    # @begin
    # <> <include>
    # #define PIV_VECTOR_FOR_FORWARD(cThis) for (cThis.m_index = 0; cThis.m_index < cThis.data().size (); cThis.m_index++)
    # #define PIV_VECTOR_FOR_REVERSE(cThis) for (cThis.m_index = cThis.data().size () - 1; cThis.m_index >= 0; cThis.m_index--)
    # #define PIV_VECTOR_FOR_GET_VALUES(cThis) cThis.data()[cThis.m_index]
    # size_t m_index;
    # <> </include>
    # @end
}

类 容器基础模板类 <公开 基础类 = 容器基础操作类 注释 = "  封装了基本数值数据类型容器的基本操作方法." 注释 = "  注意: 请勿直接继承本类来设置模板实现类."
        注释 = "  模板类型1: 容器成员的数据类型" 折叠 @文档 = "category = \"容器操作.模板类\"" @模板基础类 = 真>
{

    # 方法

    方法 枚举循环 <公开 注释 = "  启动一个循环来枚举容器数组的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = counter\r\nhas_loop_body = true">
    {
        @ PIV_VECTOR_FOR_FORWARD(@sn<this>)
    }

    方法 逆向枚举循环 <公开 注释 = "  启动一个逆向循环来枚举容器数组的每一个成员,在循环中可以调" 注释 = "用\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = rcounter\r\nhas_loop_body = true">
    {
        @ PIV_VECTOR_FOR_REVERSE(@sn<this>)
    }

    方法 取枚举值 <公开 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到的成员值."
            注释 = "跟官方库的不一样,即使有多层本类或本类继承类的\"枚举循环\"嵌套,本方法仍能正确" 注释 = "返回枚举成员值." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"" @视窗.返回参考 = 真>
    {
        @ PIV_VECTOR_FOR_GET_VALUES(@sn<this>)
    }

    方法 取枚举索引 <公开 类型 = 变整数 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到成员的索引位置."
            注释 = "跟官方库的不一样,即使有多层本类或本类继承类的\"枚举循环\"嵌套,本方法仍能正确返回" 注释 = "枚举到成员的索引位置." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"">
    {
        @ static_cast<INT_P>(@sn<this>.m_index)
    }

    方法 重置数组 <公开 注释 = "重置容器数组中的成员数为所指定的数目,数组原有的数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 欲重置的成员数目 <类型 = 变整数 注释 = "重置后的数组成员数">
    参数 值 <类型 = 模板类型1 注释 = "数组成员的值,将按此值填满整个数组">
    {
        @ @sn<this>.data().assign(static_cast<size_t>(@<欲重置的成员数目>), @<值>)
    }

    方法 取成员 <公开 类型 = 模板类型1 注释 = "返回所指定索引位置处的成员值." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 索引 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引>)]
    }

    方法 取成员2 <公开 类型 = 模板类型1 注释 = "返回所指定索引位置处的成员值." 注释 = "低效率,带边界检查,索引无效会抛出异常std::out_of_range" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 索引 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ @sn<this>.data().at(static_cast<size_t>(@<索引>))
    }

    方法 置成员值 <公开 注释 = "设置容器数组中所指定索引位置处的成员值,本方法不执行索引检查,索引无效直接崩溃." 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    参数 所欲设置的值 <类型 = 模板类型1 注释 = "提供所欲设置的成员值,先前的值将被覆盖.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)] = @<所欲设置的值>
    }

    方法 置成员值2 <公开 注释 = "设置容器数组中所指定索引位置处的成员值,如果索引无效会抛出异常std::out_of_range" 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    参数 所欲设置的值 <类型 = 模板类型1 注释 = "提供所欲设置的成员值,先前的值将被覆盖.">
    {
        @ @sn<this>.data().at(static_cast<size_t>(@<索引位置>)) = @<所欲设置的值>
    }

    方法 加入成员 <公开 注释 = "将一个或多个成员值加入到容器数组尾部" 折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @sn<this>.data().emplace_back(v); }
    }

    方法 加入成员2 <公开 类型 = 变整数 注释 = "将一个成员值加入到容器数组尾部,返回所加入的索引位置." 返回值注释 = "返回所加入成员在数组中的记录索引位置" 折叠 @禁止流程检查 = 真>
    参数 所欲添加成员值 <类型 = 模板类型1 "">
    {
        @ data().push_back(@<所欲添加成员值>);
        @ return static_cast<INT_P>(data().size() - 1);
    }

    方法 插入成员 <公开 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().emplace(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>);
    }

    方法 插入成员2 <公开 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().insert(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>);
    }

    方法 取首成员 <公开 类型 = 模板类型1 注释 = "返回容器数组首部的单个成员值." 注释 = "注意: 执行本方法前必须确保容器不为空" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    {
        @ @sn<this>.data().front()
    }

    方法 取尾成员 <公开 类型 = 模板类型1 注释 = "返回容器数组尾部的单个成员值." 注释 = "注意: 执行本方法前必须确保容器不为空" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    {
        @ @sn<this>.data().back()
    }

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](@dt<模板类型1>& lhs, @dt<模板类型1>& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<容器数组> 总共 " + 到文本 (取成员数 ()) + " 成员:\r\n"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 基本容器模板类 <公开 基础类 = 容器基础模板类 注释 = "  使用本模板基础类的容器类将使用值内容复制的方式传递数组数据."
        注释 = "  即: 执行类似赋值操作\"变量容器1 = 变量容器2\"后,变量容器1中将" 注释 = "获得变量容器2中的所有数组数据的一个完全独立拷贝,修改变量容器1"
        注释 = "的内容不会对变量容器2造成影响." 折叠 @文档 = "category = \"容器操作.模板类\"" @模板基础类 = 真>
{

    # --
    # @begin
    # <> <include>
    # std::vector<@dt<模板类型1>> m_vecData;
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_vecData = objCopyFrom.m_vecData; }
    # inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { m_vecData = std::move(rhs.m_vecData); return *this; }
    # inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_vecData == objCompare.m_vecData); }
    # inline std::vector<@dt<模板类型1>> &data() { return m_vecData; }
    # inline std::vector<@dt<模板类型1>> *pdata() { return &m_vecData; }
    # <> </include>
    # @end
}

类 基本容器参考模板类 <公开 基础类 = 容器基础模板类 注释 = "  使用本模板基础类的容器类将使用参考的方式传递数组数据."
        注释 = "  即: 执行类似赋值操作\"变量容器1 = 变量容器2\"后,变量容器1将与变量容器2指向" 注释 = "同一份数组数据,对两个变量进行数组操作将基于同一份实际数组数据."
        注释 = "  容器以参考方式赋值要比完全的值内容复制快得多,但是需要了解两种方式的不同性." 注释 = "  需要注意的是: 无论哪种类型的容器,在传递到方法参数上时,均采用参考方式传递."
        注释 = "  模板类型2: 对应的值传递类型容器数据类型" 折叠 @文档 = "category = \"容器操作.模板类\"" @模板基础类 = 真>
{

    # @ @m<DECLARE_REF_OBJECT_CLASS_WITH_DATA> (std::vector<@dt<模板类型1>>)

    方法 复制数组 <公开 注释 = "将本容器的内容复制到一个对应的值传递类型组中" 折叠 @嵌入式方法 = "">
    参数 数据接收容器 <类型 = 模板类型2 注释 = "提供用作接收被复制数据的值传递类型容器">
    {
        @ @<数据接收容器>.data() = @sn<this>.data()
    }
}

类 对象容器模板类 <公开 基础类 = 容器基础操作类 注释 = "  使用本模板可封装任意对象类型的容器数组." 注释 = "  注意: 请勿直接继承本类来设置模板实现类."
        注释 = "  模板类型1: 容器成员的对象类型" 折叠 @文档 = "category = \"容器操作.模板类\"" @视窗.外部头文件 = "<vector>\r\n<type_traits>"
        @模板基础类 = 真>
{

    # 方法

    方法 枚举循环 <公开 注释 = "  启动一个循环来枚举容器数组的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = counter\r\nhas_loop_body = true">
    {
        @ PIV_VECTOR_FOR_FORWARD(@sn<this>)
    }

    方法 逆向枚举循环 <公开 注释 = "  启动一个逆向循环来枚举容器数组的每一个成员,在循环中可以调" 注释 = "用\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = rcounter\r\nhas_loop_body = true">
    {
        @ PIV_VECTOR_FOR_REVERSE(@sn<this>)
    }

    方法 取枚举值 <公开 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到的成员值."
            注释 = "跟官方库的不一样,即使有多层本类或本类继承类的\"枚举循环\"嵌套,本方法仍能正确" 注释 = "返回枚举成员值." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"" @视窗.返回参考 = 真>
    {
        @ (@dt<模板类型1>&)PIV_VECTOR_FOR_GET_VALUES(@sn<this>)
    }

    方法 取指定类型枚举值 <公开 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到的指定数据类型的"
            注释 = "成员值,如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"" 注释 = "的枚举成员值." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"" @视窗.返回参考 = 真>
    参数 所欲获取对象的类型 <类型 = 模板类型1 注释 = "提供所欲获取对象的数据类型,必须提供正确的类型,否则会报错." @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ (@<所欲获取对象的类型>&)PIV_VECTOR_FOR_GET_VALUES(@sn<this>)
    }

    方法 取枚举索引 <公开 类型 = 变整数 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到成员的索引位置."
            注释 = "跟官方库的不一样,即使有多层本类或本类继承类的\"枚举循环\"嵌套,本方法仍能正确返回" 注释 = "枚举到成员的索引位置." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"">
    {
        @ static_cast<INT_P>(@sn<this>.m_index)
    }

    方法 重置数组 <公开 注释 = "重置容器数组中的成员数为所指定的数目,数组原有的数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 欲重置的成员数目 <类型 = 变整数 注释 = "重置后的数组成员数">
    参数 所欲填入对象的类型 <类型 = 模板类型1 注释 = "数组成员的值,将按此值填满整个数组" @需求类型 = 数据类型>
    {
        @ @sn<this>.data().assign(static_cast<INT_P>(@<欲重置的成员数目>), @<所欲填入对象的类型> ())
    }

    方法 取成员 <公开 类型 = 模板类型1 注释 = "返回所指定索引位置处的成员值." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠 @嵌入式方法 = ""
            @视窗.返回参考 = 真>
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ (@dt<模板类型1>&)@sn<this>.data()[static_cast<size_t>(@<索引位置>)]
    }

    方法 取成员2 <公开 类型 = 模板类型1 注释 = "返回所指定索引位置处的成员值." 注释 = "低效率,带边界检查,索引无效会抛出异常std::out_of_range" 折叠
            @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ (@dt<模板类型1>&)@sn<this>.data().at(static_cast<size_t>(@<索引位置>))
    }

    方法 取指定类型成员 <公开 注释 = "返回所指定索引位置处的成员值." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    参数 所欲获取对象的类型 <类型 = 模板类型1 注释 = "提供所欲获取对象的数据类型,必须提供正确的类型,否则会报错." @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ (@<所欲获取对象的类型>&)@sn<this>.data()[static_cast<size_t>(@<索引位置>)]
    }

    方法 置成员值 <公开 注释 = "设置容器数组中所指定索引位置处的成员值,本方法不执行索引检查,索引无效直接崩溃." 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    参数 所欲设置的值 <类型 = 模板类型1 注释 = "提供所欲设置的成员值,先前的值将被覆盖.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)] = @<所欲设置的值>
    }

    方法 置成员值2 <公开 注释 = "设置容器数组中所指定索引位置处的成员值,如果索引无效会抛出异常std::out_of_range" 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    参数 所欲设置的值 <类型 = 模板类型1 注释 = "提供所欲设置的成员值,先前的值将被覆盖.">
    {
        @ @sn<this>.data().at(static_cast<size_t>(@<索引位置>)) = @<所欲设置的值>
    }

    方法 加入成员 <公开 注释 = "将一个或多个成员值加入到容器数组尾部" 折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 @可扩展 = "">
    {
        @ for (auto&& v : { @<值> }) { @sn<this>.data().emplace_back(v); }
    }

    方法 加入成员2 <公开 类型 = 变整数 注释 = "将一个成员值加入到容器数组尾部,返回所加入的索引位置." 返回值注释 = "返回所加入成员在数组中的记录索引位置" 折叠 @禁止流程检查 = 真>
    参数 所欲添加成员值 <类型 = 模板类型1 "">
    {
        @ data().push_back(@<所欲添加成员值>);
        @ return static_cast<INT_P>(data().size() - 1);
    }

    方法 加入并返回成员 <公开 类型 = 模板类型1 注释 = "将所指定的对象复制一份后加入到本数组中,返回所加入复制对象的参考."
            注释 = "注意: 如果所返回对象成员需要动态挂接事件,请按类似以下格式挂接:" 注释 = "  挂接事件 ((对象实际数据类型)数组1.加入并返回成员 (...))"
            注释 = "  因为火山视窗的赋值操作采用的是值复制方式,所以如果将返回对象赋值到另一" 注释 = "个变量后再挂接这个变量的话,将导致事件挂接在一个复制出来的对象上而不是所"
            注释 = "期望的数组中保存的对象." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 所欲添加成员值 <类型 = 模板类型1 注释 = "提供所欲加入的对象值,该对象将被复制一份后加入到本数组中.">
    {
        @ data().push_back(@<所欲添加成员值>);
        @ return (@dt<模板类型1>&)data().back();
    }

    方法 加入并返回成员2 <公开 类型 = 模板类型1 注释 = "将所指定的对象复制一份后加入到本数组中,返回所加入复制对象的参考."
            注释 = "注意: 如果所返回对象成员需要动态挂接事件,请按类似以下格式挂接:" 注释 = "  挂接事件 ((对象实际数据类型)数组1.加入并返回成员2 (...))"
            注释 = "  因为火山视窗的赋值操作采用的是值复制方式,所以如果将返回对象赋值到另一" 注释 = "个变量后再挂接这个变量的话,将导致事件挂接在一个复制出来的对象上而不是所"
            注释 = "期望的数组中保存的对象." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 所欲添加成员值 <类型 = 模板类型1 注释 = "提供所欲加入的对象值,该对象将被复制一份后加入到本数组中.">
    参数 所加入索引位置 <类型 = 变整数类 注释 = "在其中返回所加入新对象在数组中的索引位置">
    {
        @ data().push_back(@<所欲添加成员值>);
        @ @<所加入索引位置.值> = static_cast<INT_P>(data().size() - 1);
        @ return (@dt<模板类型1>&)data().back();
    }

    方法 加入新成员 <公开 注释 = "建立所指定类的一个实例对象并将其加入到本数组中." 折叠 @嵌入式方法 = "">
    参数 所欲添加对象的类型 <类型 = 模板类型1 注释 = "提供所欲新建并加入对象的数据类型" @需求类型 = 数据类型>
    {
        @ @sn<this>.data().push_back(@<所欲添加对象的类型>{})
    }

    方法 加入新成员2 <公开 类型 = 变整数 注释 = "建立所指定类的一个实例对象并将其加入到本数组中,返回所加入成员的索引位置." 折叠 @嵌入式方法 = "">
    参数 所欲添加对象的类型 <类型 = 模板类型1 注释 = "提供所欲新建并加入对象的数据类型" @需求类型 = 数据类型>
    {
        @ [&](auto& vec) {
        @     vec.push_back(@<所欲添加对象的类型>{});
        @     return static_cast<INT_P>(vec.size() - 1);
        @ } (@sn<this>.data())
    }

    方法 批量加入新成员 <公开 注释 = "建立所指定类的一个或多个实例对象并将其加入到本数组中." 折叠 @嵌入式方法 = "">
    参数 所欲添加对象的类型 <类型 = 模板类型1 注释 = "提供所欲新建并加入对象的数据类型" @需求类型 = 数据类型>
    参数 所欲加入成员的数目 <类型 = 变整数 注释 = "提供所欲加入的新建对象的数目" @默认值 = 1>
    {
        @ [&] {
        @     for (size_t i = 0; i < static_cast<size_t>(@<所欲加入成员的数目>); i++) {
        @         @sn<this>.data().push_back(@<所欲添加对象的类型>{});
        @     }
        @ } ()
    }

    方法 加入并返回新成员 <公开 类型 = 模板类型1 注释 = "建立所指定类的一个实例对象并将其加入到本数组中,返回所加入对象的参考."
            注释 = "注意: 如果所创建对象需要动态挂接事件,请按类似以下格式挂接:" 注释 = "  挂接事件 ((对象数据类型)数组1.加入并返回新成员 (对象数据类型))"
            注释 = "  因为火山视窗的赋值操作采用的是值复制方式,所以如果将返回对象赋值到另一" 注释 = "个变量后再挂接这个变量的话,将导致事件挂接在一个复制出来的对象上而不是所"
            注释 = "期望的数组中保存的对象." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    {
        @ data().push_back(@dt<模板类型1>{});
        @ return (@dt<模板类型1>&)data().back();
    }

    方法 加入并返回新成员2 <公开 类型 = 模板类型1 注释 = "建立所指定类的一个实例对象并将其加入到本数组中,返回所加入对象的参考."
            注释 = "注意: 如果所创建对象需要动态挂接事件,请按类似以下格式挂接:" 注释 = "  挂接事件 ((对象数据类型)数组1.加入并返回新成员2 (对象数据类型, ...))"
            注释 = "  因为火山视窗的赋值操作采用的是值复制方式,所以如果将返回对象赋值到另一" 注释 = "个变量后再挂接这个变量的话,将导致事件挂接在一个复制出来的对象上而不是所"
            注释 = "期望的数组中保存的对象." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 所加入索引位置 <类型 = 变整数类 注释 = "在其中返回所加入新对象在数组中的索引位置">
    {
        @ data().push_back(@dt<模板类型1>{});
        @ @<所加入索引位置.值> = static_cast<INT_P>(data().size() -1);
        @ return (@dt<模板类型1>&)data().back();
    }

    方法 插入成员 <公开 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().emplace(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>);
    }

    方法 插入成员2 <公开 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().insert(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>);
    }

    方法 插入新成员 <公开 类型 = 模板类型1 注释 = "建立所指定类的一个实例对象并将其插入到本数组中的指定索引位置,返回所插入对象的参考."
            注释 = "注意: 如果所创建对象需要动态挂接事件,请按类似以下格式挂接:" 注释 = "  挂接事件 ((对象数据类型)数组1.插入新成员 (索引位置, 对象数据类型))"
            注释 = "  因为火山视窗的赋值操作采用的是值复制方式,所以如果将返回对象赋值到另一" 注释 = "个变量后再挂接这个变量的话,将导致事件挂接在一个复制出来的对象上而不是所"
            注释 = "期望的数组中保存的对象." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目.">
    {
        @ auto iter = data().emplace(data().begin() + static_cast<size_t>(@<插入索引位置>), @dt<模板类型1>{});
        @ return (@dt<模板类型1>&)*iter;
    }

    方法 取首成员 <公开 类型 = 模板类型1 注释 = "返回容器数组首部的单个成员值." 注释 = "注意: 执行本方法前必须确保容器不为空" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    {
        @ (@dt<模板类型1>&)@sn<this>.data().front()
    }

    方法 取尾成员 <公开 类型 = 模板类型1 注释 = "返回容器数组尾部的单个成员值." 注释 = "注意: 执行本方法前必须确保容器不为空" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    {
        @ (@dt<模板类型1>&)@sn<this>.data().back()
    }

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序." 注释 = "注意: 必须在接收事件\"小于比较\"中实现比较函数,才能正确排序." 折叠>
    {
        @ std::sort(data().begin(), data().end(), [this](@dt<模板类型1>& lhs, @dt<模板类型1>& rhs) { return (bool)this->@<小于比较>(lhs, rhs); });
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序." 注释 = "注意: 必须在接收事件\"大于比较\"中实现比较函数,才能正确排序." 折叠>
    {
        @ std::sort(data().begin(), data().end(), [this](@dt<模板类型1>& lhs, @dt<模板类型1>& rhs) { return (bool)this->@<大于比较>(lhs, rhs); });
    }

    方法 小于比较 <公开 定义事件 类型 = 整数 注释 = "请在本事件中实现小于比较函数,即\"对象1\"<\"对象2\"时返回1."
            注释 = "注: 如未在本事件实现正确的比较,将不能正确进行\"升序排序\"." 返回值注释 = "返回1表示\"对象1\"<\"对象2\",其他情况请返回0." 折叠>
    参数 对象1 <类型 = 模板类型1>
    参数 对象2 <类型 = 模板类型1>

    方法 大于比较 <公开 定义事件 类型 = 整数 注释 = "请在本事件中实现小于比较函数,即\"对象1\">\"对象2\"时返回1."
            注释 = "注: 如未在本事件实现正确的比较,将不能正确进行\"降序排序\"." 返回值注释 = "返回1表示\"对象1\">\"对象2\",其他情况请返回0." 折叠>
    参数 对象1 <类型 = 模板类型1>
    参数 对象2 <类型 = 模板类型1>

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<容器数组> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # @begin
    # <> <include>
    # std::vector<std::remove_pointer<@dt<模板类型1> *>::type> m_vecData;
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_vecData = objCopyFrom.m_vecData; }
    # inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { m_vecData = std::move(rhs.m_vecData); return *this; }
    # inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_vecData == objCompare.m_vecData); }
    # inline std::vector<std::remove_pointer<@dt<模板类型1> *>::type> &data() { return m_vecData; }
    # inline std::vector<std::remove_pointer<@dt<模板类型1> *>::type> *pdata() { return &m_vecData; }
    # <> </include>
    # @end
}

类 数据容器模板类 <公开 基础类 = 容器基础操作类 注释 = "  使用本模板可封装对象中的C++数据成员的容器数组." 注释 = "  注意: 请勿直接继承本类来设置模板实现类."
        注释 = "  模板类型1: 容器成员的对象类型,必须是可以通过" 注释 = "data() 获取对象内的C++数据成员."
        注释 = "  本类唯一可以使用的位置为作为使用 PIV_DECLARE_VECTOR_CLASS" 注释 = "宏进行封装的类的基础类." 折叠
        @文档 = "category = \"容器操作.模板类\"" @模板基础类 = 真>
{
    方法 枚举循环 <公开 注释 = "  启动一个循环来枚举容器数组的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = counter\r\nhas_loop_body = true">
    {
        @ PIV_VECTOR_FOR_FORWARD(@sn<this>)
    }

    方法 逆向枚举循环 <公开 注释 = "  启动一个逆向循环来枚举容器数组的每一个成员,在循环中可以调" 注释 = "用\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = rcounter\r\nhas_loop_body = true">
    {
        @ PIV_VECTOR_FOR_REVERSE(@sn<this>)
    }

    方法 取枚举索引 <公开 类型 = 变整数 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到成员的索引位置."
            注释 = "跟官方库的不一样,即使有多层本类或本类继承类的\"枚举循环\"嵌套,本方法仍能正确返回" 注释 = "枚举到成员的索引位置." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"">
    {
        @ static_cast<INT_P>(@sn<this>.m_index)
    }

    方法 取枚举值 <公开 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前枚举到的成员值."
            注释 = "跟官方库的不一样,即使有多层本类或本类继承类的\"枚举循环\"嵌套,本方法仍能正确" 注释 = "返回枚举成员值." 折叠
            @嵌入式方法 = "parent = \"counter, rcounter\"">
    {
        @ @dt<模板类型1>(PIV_VECTOR_FOR_GET_VALUES (@sn<this>))
    }

    方法 重置数组 <公开 注释 = "重置容器数组中的成员数为所指定的数目,数组原有的数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 欲重置的成员数目 <类型 = 整数 注释 = "重置后的数组成员数">
    参数 值 <类型 = 模板类型1 注释 = "数组成员的值,将按此值填满整个数组">
    {
        @ @sn<this>.data().assign(@<欲重置的成员数目>, @<值>.data())
    }

    方法 取成员 <公开 类型 = 模板类型1 注释 = "返回所指定索引位置处的成员值(非返回参数,必然产生复制)." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠
            @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ @dt<模板类型1> (@sn<this>.data()[static_cast<size_t>(@<索引位置>)])
    }

    方法 取成员2 <公开 类型 = 模板类型1 注释 = "返回所指定索引位置处的成员值(非返回参数,必然产生复制)." 注释 = "低效率,带边界检查,索引无效会抛出异常std::out_of_range"
            折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ @dt<模板类型1> (@sn<this>.data().at(static_cast<size_t>(@<索引位置>)))
    }

    方法 置成员值 <公开 注释 = "设置容器数组中所指定索引位置处的成员值,本方法不执行索引检查,索引无效直接崩溃." 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    参数 所欲设置的值 <类型 = 模板类型1 注释 = "提供所欲设置的成员值,先前的值将被覆盖.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)] = @<所欲设置的值>.data()
    }

    方法 置成员值2 <公开 注释 = "设置容器数组中所指定索引位置处的成员值,如果索引无效会抛出异常std::out_of_range" 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    参数 所欲设置的值 <类型 = 模板类型1 注释 = "提供所欲设置的成员值,先前的值将被覆盖.">
    {
        @ @sn<this>.data().at(static_cast<size_t>(@<索引位置>)) = @<所欲设置的值>.data()
    }

    方法 加入成员 <公开 注释 = "将一个或多个成员值加入到容器数组尾部" 折叠 @嵌入式方法 = "">
    参数 值 <类型 = 模板类型1 @可扩展 = "">
    {
        @ for (auto&& v : { @<值>.data() }) { @sn<this>.data().emplace_back(v); }
    }

    方法 加入成员2 <公开 类型 = 变整数 注释 = "将一个成员值加入到容器数组尾部,返回所加入的索引位置." 返回值注释 = "返回所加入成员在数组中的记录索引位置" 折叠 @禁止流程检查 = 真>
    参数 所欲添加成员值 <类型 = 模板类型1 "">
    {
        @ data().push_back(@<所欲添加成员值>.data());
        @ return static_cast<INT_P>(data().size() - 1);
    }

    方法 插入成员 <公开 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().emplace(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>.data());
    }

    方法 插入成员2 <公开 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().insert(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>.data());
    }

    方法 取首成员 <公开 类型 = 模板类型1 注释 = "返回容器数组首部的单个成员值." 注释 = "注意: 执行本方法前必须确保容器不为空" 折叠 @嵌入式方法 = "">
    {
        @ @dt<模板类型1> (@sn<this>.data().front())
    }

    方法 取尾成员 <公开 类型 = 模板类型1 注释 = "返回容器数组尾部的单个成员值." 注释 = "注意: 执行本方法前必须确保容器不为空" @嵌入式方法 = "">
    {
        @ @dt<模板类型1> (@sn<this>.data().back())
    }
}

# @begin
# @def_macro PIV_DECLARE_VECTOR_CLASS(data_type)  \
# <>     <include>  \
#     using DATA_TYPE = std::vector<data_type>;  \
#     DATA_TYPE m_vecData;  \
#     inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_vecData = objCopyFrom.m_vecData; }  \
#     inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { m_vecData = std::move(rhs.m_vecData); return *this; }  \
#     inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_vecData == objCompare.m_vecData); }  \
#     inline DATA_TYPE &data() { return m_vecData; }  \
#     inline DATA_TYPE *pdata() { return &m_vecData; }  \
# <>     </include>
# @end
# std::vector 基本容器类 ===

类 字节容器类 <公开 基础类 = 基本容器模板类 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "字节">
{
    方法 取参考数组 <公开 注释 = "将本容器的内容复制到一个对应的参考类型组中" 折叠 @嵌入式方法 = "">
    参数 数据接收容器 <类型 = 字节参考容器类 注释 = "提供用作接收被复制数据的参考类型容器">
    {
        @ @<数据接收容器>.pdata() = @sn<this>.pdata()
    }
}

类 短整数容器类 <公开 基础类 = 基本容器模板类 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "短整数">
{
    方法 取参考数组 <公开 注释 = "将本容器的内容复制到一个对应的参考类型组中" 折叠 @嵌入式方法 = "">
    参数 数据接收容器 <类型 = 短整数参考容器类 注释 = "提供用作接收被复制数据的参考类型容器">
    {
        @ @<数据接收容器>.pdata() = @sn<this>.pdata()
    }
}

类 字符容器类 <公开 基础类 = 基本容器模板类 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "字符">
{
    方法 取参考数组 <公开 注释 = "将本容器的内容复制到一个对应的参考类型组中" 折叠 @嵌入式方法 = "">
    参数 数据接收容器 <类型 = 字符参考容器类 注释 = "提供用作接收被复制数据的参考类型容器">
    {
        @ @<数据接收容器>.pdata() = @sn<this>.pdata()
    }
}

类 整数容器类 <公开 基础类 = 基本容器模板类 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "整数">
{
    方法 取参考数组 <公开 注释 = "将本容器的内容复制到一个对应的参考类型组中" 折叠 @嵌入式方法 = "">
    参数 数据接收容器 <类型 = 整数参考容器类 注释 = "提供用作接收被复制数据的参考类型容器">
    {
        @ @<数据接收容器>.pdata() = @sn<this>.pdata()
    }
}

类 变整数容器类 <公开 基础类 = 基本容器模板类 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "变整数">
{
    方法 取参考数组 <公开 注释 = "将本容器的内容复制到一个对应的参考类型组中" 折叠 @嵌入式方法 = "">
    参数 数据接收容器 <类型 = 变整数参考容器类 注释 = "提供用作接收被复制数据的参考类型容器">
    {
        @ @<数据接收容器>.pdata() = @sn<this>.pdata()
    }
}

类 长整数容器类 <公开 基础类 = 基本容器模板类 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "长整数">
{
    方法 取参考数组 <公开 注释 = "将本容器的内容复制到一个对应的参考类型组中" 折叠 @嵌入式方法 = "">
    参数 数据接收容器 <类型 = 长整数参考容器类 注释 = "提供用作接收被复制数据的参考类型容器">
    {
        @ @<数据接收容器>.pdata() = @sn<this>.pdata()
    }
}

类 单精度小数容器类 <公开 基础类 = 基本容器模板类 注释 = "提供基于<std::vector>容器的单精度小数数组封装."
        注释 = "单精度小数的有效值范围从-3.402823E38到-1.401298E-45,有效浮点数为7位,占4字节." 折叠 @文档 = "category = \"容器操作.数组容器\""
        @模板实现类 = "单精度小数">
{
    方法 取参考数组 <公开 注释 = "将本容器的内容复制到一个对应的参考类型组中" 折叠 @嵌入式方法 = "">
    参数 数据接收容器 <类型 = 小数参考容器类 注释 = "提供用作接收被复制数据的参考类型容器">
    {
        @ @<数据接收容器>.pdata() = @sn<this>.pdata()
    }
}

类 小数容器类 <公开 基础类 = 基本容器模板类 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "小数">
{
    方法 取参考数组 <公开 注释 = "将本容器的内容复制到一个对应的参考类型组中" 折叠 @嵌入式方法 = "">
    参数 数据接收容器 <类型 = 小数参考容器类 注释 = "提供用作接收被复制数据的参考类型容器">
    {
        @ @<数据接收容器>.pdata() = @sn<this>.pdata()
    }
}

类 文本容器类 <公开 基础类 = 基本容器模板类 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "文本型">
{
    方法 取参考数组 <公开 注释 = "将本容器的内容复制到一个对应的参考类型组中" 折叠 @嵌入式方法 = "">
    参数 数据接收容器 <类型 = 文本参考容器类 注释 = "提供用作接收被复制数据的参考类型容器">
    {
        @ @<数据接收容器>.pdata() = @sn<this>.pdata()
    }
}

类 字节集容器类 <公开 基础类 = 对象容器模板类 注释 = "排序仅比较字节集大小" 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "字节集类">
{
    方法 取参考数组 <公开 注释 = "将本容器的内容复制到一个对应的参考类型组中" 折叠 @嵌入式方法 = "">
    参数 数据接收容器 <类型 = 字节集参考容器类 注释 = "提供用作接收被复制数据的参考类型容器">
    {
        @ @<数据接收容器>.pdata() = @sn<this>.pdata()
    }

    方法 字节集容器类_小于比较 <接收事件 类型 = 整数 注释 = "请在本事件中实现小于比较函数,即\"对象1\"<\"对象2\"时返回1."
            注释 = "注: 如未在本事件实现正确的比较,将不能正确进行\"升序排序\"." 返回值注释 = "返回1表示\"对象1\"<\"对象2\",其他情况请返回0." 折叠>
    参数 来源对象 <类型 = 字节集容器类 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 对象1 <类型 = 字节集类>
    参数 对象2 <类型 = 字节集类>
    {
        如果 (对象1.取字节集长度 () < 对象2.取字节集长度 ())
        {
            返回 (1)
        }
        返回 (0)
    }

    方法 字节集容器类_大于比较 <接收事件 类型 = 整数 注释 = "请在本事件中实现小于比较函数,即\"对象1\">\"对象2\"时返回1."
            注释 = "注: 如未在本事件实现正确的比较,将不能正确进行\"降序排序\"." 返回值注释 = "返回1表示\"对象1\">\"对象2\",其他情况请返回0." 折叠>
    参数 来源对象 <类型 = 字节集容器类 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 对象1 <类型 = 字节集类>
    参数 对象2 <类型 = 字节集类>
    {
        如果 (对象1.取字节集长度 () > 对象2.取字节集长度 ())
        {
            返回 (1)
        }
        返回 (0)
    }
}

类 对象容器类 <公开 基础类 = 对象容器模板类 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "对象类">

# ---

类 标准文本容器类 <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::wstring>的文本数组封装." 注释 = "文本编码为Unicode(UTF-16LE)"
        折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "标准文本类">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS>(std::wstring)

    方法 取文本成员 <公开 类型 = 文本型 注释 = "返回所指定索引位置处的成员值." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ @an<CVolString>(@sn<this>.data()[static_cast<size_t>(@<索引位置>)].c_str())
    }

    方法 加入多个文本 <公开 注释 = "将一个或多个文本型成员值加入到容器数组尾部" 折叠 @嵌入式方法 = "">
    参数 所欲添加成员值 <类型 = 文本型 @可扩展 = "">
    {
        @ for (auto&& v : { @<所欲添加成员值> }) { @sn<this>.data().push_back(v.GetText()); }
    }

    方法 插入文本成员 <公开 注释 = "将所指定的多个成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲插入的成员值 <类型 = 文本型>
    {
        @ data().emplace(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>.GetText());
    }

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::wstring& lhs, std::wstring& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<标准文本容器数组> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 标准文本容器类U <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::string>的文本数组封装." 注释 = "文本编码为UTF-8" 折叠
        @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "标准文本类U">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (std::string)

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::string& lhs, std::string& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<标准文本容器数组U> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 标准文本容器类A <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::string>的文本数组封装." 注释 = "文本编码为ANSI本地多字节" 折叠
        @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "标准文本类A">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (std::string)

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::string& lhs, std::string& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<标准文本容器数组A> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 文本视图容器类 <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::wstring_view>的文本视图数组封装."
        注释 = "文本编码为Unicode(UTF-16LE)" 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "文本视图类">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (std::wstring_view)

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::wstring_view& lhs, std::wstring_view& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<文本视图容器类> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 文本视图容器类U <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::string_view>的文本视图数组封装." 注释 = "文本编码为UTF-8" 折叠
        @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "文本视图类U">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (std::string_view)

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::string_view& lhs, std::string_view& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<文本视图容器类U> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 文本视图容器类A <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::string_view>文本视图数组封装." 注释 = "文本编码为ANSI本地多字节" 折叠
        @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "文本视图类A">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (std::string_view)

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::string_view& lhs, std::string_view& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<文本视图容器类A> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

# std::vector 参考容器类 ===

类 字节参考容器类 <公开 基础类 = 基本容器参考模板类 @文档 = "category = \"容器操作.参考容器类\"" @模板实现类 = "字节, 字节容器类">

类 字符参考容器类 <公开 基础类 = 基本容器参考模板类 @文档 = "category = \"容器操作.参考容器类\"" @模板实现类 = "字符, 字符容器类">

类 短整数参考容器类 <公开 基础类 = 基本容器参考模板类 @文档 = "category = \"容器操作.参考容器类\"" @模板实现类 = "短整数, 短整数容器类">

类 整数参考容器类 <公开 基础类 = 基本容器参考模板类 @文档 = "category = \"容器操作.参考容器类\"" @模板实现类 = "整数, 整数容器类">

类 变整数参考容器类 <公开 基础类 = 基本容器参考模板类 @文档 = "category = \"容器操作.参考容器类\"" @模板实现类 = "变整数, 变整数容器类">

类 长整数参考容器类 <公开 基础类 = 基本容器参考模板类 @文档 = "category = \"容器操作.参考容器类\"" @模板实现类 = "长整数, 长整数容器类">

类 小数参考容器类 <公开 基础类 = 基本容器参考模板类 @文档 = "category = \"容器操作.参考容器类\"" @模板实现类 = "小数, 小数容器类">

类 文本参考容器类 <公开 基础类 = 基本容器参考模板类 @文档 = "category = \"容器操作.参考容器类\"" @模板实现类 = "文本型, 文本容器类">

类 字节集参考容器类 <公开 基础类 = 基本容器参考模板类 @文档 = "category = \"容器操作.参考容器类\"" @模板实现类 = "字节集类, 字节集容器类">

#
