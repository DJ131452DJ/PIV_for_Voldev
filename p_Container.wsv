<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" 注释 = "封装了std::vector容器,容器可以当作火山数组类使用,用法基本没什么区别."
        注释 = "注意: std::vector非线程安全,多线程同时读写记得加锁.">

# std::vector 容器的模板基础类 ===

类 容器基础操作类 <公开 基础类 = 扩展对象类 注释 = "封装了容器的基本操作方法,容器(std::vector)相当于火山的数组类." 折叠
        @文档 = "category = \"容器操作.模板类\"" @视窗.外部头文件 = "<vector>\r\n<algorithm>\r\n<type_traits>" @模板基础类 = 真>
{

    # 分配器

    方法 预分配尺寸 <公开 属性读 类型 = 变整数 注释 = "返回本数组已分配了空间的成员数量,此容量值会大于或等于数组成员数." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.data().capacity())
    }

    方法 预分配尺寸 <公开 属性写 注释 = "提前为本数组分配指定数目成员的空间,用作支持在后面快速进行成员添加." 折叠>
    参数 所欲设置的容量 <类型 = 变整数 注释 = "单位为容器的成员数量">
    {
        @ data().reserve(static_cast<size_t>(@<所欲设置的容量>));
    }

    方法 取最大可用数 <公开 类型 = 变整数 注释 = "返回容器能够容纳的最大成员数,此值通常反映容器的理论限制,一般限制为小于可用的内存." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT_P>(@sn<this>.data().max_size())
    }

    方法 释放空闲容量 <公开 注释 = "释放数组中未使用的内存空间,可能会重新分配内存." 注释 = "执行后会将数组容量(\"预分配尺寸\")缩减到跟\"取成员数\"一样." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().shrink_to_fit()
    }

    # 方法

    方法 枚举循环 <公开 注释 = "  启动一个循环来枚举本数组中的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值,调用\"取枚举索引\""
            注释 = "方法来获取当前所枚举到成员的索引位置." 折叠 @嵌入式方法 = "name = vector_for\r\nhas_loop_body = true">
    {
        @ for (size_t __piv_vector_for = 0; __piv_vector_for < @sn<this>.data().size(); __piv_vector_for++)
    }

    方法 逆向枚举循环 <公开 注释 = "  启动一个循环来逆向枚举本数组中的每一个成员,在循环中可以调用" 注释 = "\"取枚举索引\"/\"取枚举值\"方法来获取当前所枚举索引和对应值."
            注释 = "注意: 不能嵌套使用本循环,否则编译将报错." 折叠 @嵌入式方法 = "name = vector_rfor\r\nhas_loop_body = true">
    {
        @ for (size_t __piv_vector_for = @sn<this>.data().size() - 1; __piv_vector_for >= 0; __piv_vector_for--)
    }

    方法 取枚举索引 <公开 类型 = 整数 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前枚举到成员的索引位置,如果有"
            注释 = "多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"枚举到成员的索" 注释 = "引位置." 折叠
            @嵌入式方法 = "parent = \"vector_for, vector_rfor\"">
    {
        @ static_cast<INT>(__piv_vector_for)
    }

    方法 取容器指针 <公开 类型 = 变整数 注释 = "获取数组类自身的指针(std::vector<模板类型1> *)." 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.pdata())
    }

    方法 取数组指针 <公开 类型 = 变整数 注释 = "返回当前数组内容的第一个元素的指针" 折叠 @嵌入式方法 = "">
    {
        @ reinterpret_cast<INT_P>(@sn<this>.data().data())
    }

    方法 索引是否有效 <公开 类型 = 逻辑型 注释 = "返回所指定的索引值是否大于等于0且小于本数组的成员数" 折叠 @禁止流程检查 = 真>
    参数 所欲检查的索引值 <类型 = 变整数>
    {
        @ return static_cast<size_t>(@<所欲检查的索引值>) >= 0 && static_cast<size_t>(@<所欲检查的索引值>) < data().size();
    }

    方法 取成员数 <公开 类型 = 整数 注释 = "返回数组中的当前已有成员数目" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().size())
    }

    方法 取最大索引 <公开 类型 = 整数 注释 = "返回数组中尾成员的索引位置,如果当前数组为空,则返回-1." 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().size()) - 1
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回本数组是否为空" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().empty()
    }

    方法 删除所有成员 <公开 注释 = "删除当前数组中的所有成员" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().clear()
    }

    方法 重置成员数 <公开 注释 = "重置当前数组的成员数量,如果新的成员数小于当前成员数,则多余的成员值会被删除." 折叠 @嵌入式方法 = "">
    参数 新成员数 <类型 = 整数>
    {
        @ @sn<this>.data().resize(@<新成员数>)
    }

    方法 取成员指针 <公开 类型 = 变整数 注释 = "返回所指定索引位置处的成员值指针" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 索引 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ reinterpret_cast<INT_P>(&@sn<this>.data()[static_cast<size_t>(@<索引>)])
    }

    方法 添加数组 <公开 注释 = "将另一个同类型数组的内容添加到本数组尾部" 折叠>
    参数 所欲添加的数组 <类型 = 容器基础操作类>
    {
        @ data().insert(data().end(), @<所欲添加的数组>.data().begin(), @<所欲添加的数组>.data().end());
    }

    方法 添加部分数组 <公开 注释 = "将另一个同类型数组内容中的一部分添加到本数组尾部" 折叠>
    参数 所欲添加的数组 <类型 = 容器基础操作类>
    参数 起始索引位置 <类型 = 整数 注释 = "必须大于等于0且加上\"所欲添加的成员数\"后小于等于\"所欲添加的数组\"的成员数目">
    参数 所欲添加的成员数 <类型 = 整数 注释 = "必须大于等于0且加上\"起始索引位置\"后小于等于\"所欲添加的数组\"的成员数目">
    {
        @ data().insert(data().end(), @<所欲添加的数组>.data().begin() + @<起始索引位置>, @<所欲添加的数组>.data().begin() + @<起始索引位置> + @<所欲添加的成员数>);
    }

    方法 从数组复制 <公开 注释 = "将另一个同类型数组的内容复制到本数组中" 折叠>
    参数 欲复制的数组 <类型 = 容器基础操作类>
    {
        @ data().resize(@<欲复制的数组>.data().size());
        @ std::move(@<欲复制的数组>.data().begin(), @<欲复制的数组>.data().end(), data().begin());
    }

    方法 加入新成员 <公开 注释 = "原位默认构造一个成员值,并将其加入到本数组的尾部." 注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().emplace_back()
    }

    方法 批量加入新成员 <公开 注释 = "原位默认构造一个或多个成员值,并将其加入到本数组的尾部." 注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @嵌入式方法 = "">
    参数 所欲加入的成员数目 <类型 = 变整数 注释 = "提供所欲加入的成员数目" @默认值 = 1>
    {
        @ for (INT_P i = 0; i < @<所欲加入的成员数目>; i++) {
        @     @sn<this>.data().emplace_back();
        @ }
    }

    方法 插入新成员 <公开 类型 = 模板类型1 注释 = "原位构造一个成员值并将其插入到本数组中的指定索引位置,返回所插入成员的参考."
            注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目.">
    {
        @ return (@dt<模板类型1>&)*data().emplace(data().begin() + @<插入索引位置>);
    }

    方法 删除尾成员 <公开 注释 = "删除数组尾部的单个成员,数组不能为空." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().pop_back()
    }

    方法 删除成员 <公开 注释 = "删除数组中所指定索引范围的单个或多个成员" 折叠>
    参数 删除索引位置 <类型 = 变整数 注释 = "提供所欲删除的索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲删除成员数目 <类型 = 变整数 注释 = "提供所欲删除成员的数目,必须大于等于0且加上\"删除索引位置\"参数值后小于等于数组成员数目." @默认值 = 1>
    {
        @ data().erase(data().begin() + @<删除索引位置>, data().begin() + @<删除索引位置> + @<所欲删除成员数目>);
    }

    方法 删除到尾部 <公开 注释 = "删除数组中所指定索引位置后(包括该位置)的所有成员" 折叠>
    参数 起始索引位置 <类型 = 变整数 注释 = "提供所欲删除起始成员的索引位置,必须大于等于0且小于等于数组成员数目.">
    {
        @ data().erase(data().begin() + @<起始索引位置>, data().end());
    }

    方法 查找删除成员 <公开 类型 = 逻辑型 注释 = "查找第一个等于所指定值的成员,如果找到则将其删除并返回真,否则返回假." 折叠>
    参数 所欲查找成员值 <类型 = 模板类型1 注释 = "提供所欲查找并删除的成员值">
    {
        变量 索引值 <类型 = 整数>
        索引值 = 本对象.查找首成员 (所欲查找成员值)
        如果 (索引值 == -1)
        {
            返回 (假)
        }
        本对象.删除成员 (索引值)
        返回 (真)
    }

    方法 交换成员 <公开 注释 = "将两个索引位置处的成员值相互交换" 折叠>
    参数 索引位置1 <类型 = 整数 注释 = "提供成员1的索引位置,必须大于等于0且小于数组成员数目.">
    参数 索引位置2 <类型 = 整数 注释 = "提供成员2的索引位置,必须大于等于0且小于数组成员数目.">
    {
        @ std::swap(data()[@<索引位置1>], data()[@<索引位置2>]);
    }

    方法 交换所有成员 <公开 注释 = "将当前数组的成员和另外一个数组的成员进行交换" 折叠 @嵌入式方法 = "">
    参数 欲交换的数组 <类型 = 容器基础操作类>
    {
        @ std::swap(@sn<this>.data(), @<欲交换的数组>.data())
    }

    方法 交换数组 <公开 注释 = "交换两个容器数组的数据内容." 折叠 @嵌入式方法 = "">
    参数 欲交换的数组 <类型 = 容器基础操作类>
    {
        @ @sn<this>.data().swap(@<欲交换的数组>.data())
    }

    方法 成员是否存在 <公开 类型 = 逻辑型 注释 = "返回数组中是否存在为所指定值的成员" 折叠>
    参数 所欲查找的成员值 <类型 = 模板类型1>
    {
        返回 (本对象.查找首成员 (所欲查找的成员值) != -1)
    }

    方法 替换成员值 <公开 注释 = "将所有等于指定值的成员替换为另一个值" 折叠>
    参数 所欲替换的成员值 <类型 = 模板类型1>
    参数 所替换到的成员值 <类型 = 模板类型1>
    {
        @ std::replace(data().begin(), data().end(), @<所欲替换的成员值>, @<所替换到的成员值>);
    }

    方法 取指定成员数量 <公开 类型 = 整数 注释 = "获取指定成员值在数组内的数量" 折叠 @禁止流程检查 = 真>
    参数 欲检查的成员值 <类型 = 模板类型1>
    {
        @ return std::count(data().begin(), data().end(), @<欲检查的成员值>);
    }

    方法 "// 排序" <公开 注释 = "对数组中的所有成员进行排序." 注释 = "注意: 需要<模板类型1>支持小于和大于比较." 折叠>
    参数 从小到大排序 <类型 = 逻辑型 注释 = "为真表示从小到大进行排序,为假表示从大到小进行排序." @默认值 = 真>
    {
        @ if (@<从小到大排序>) {
        @    std::sort(data().begin(), data().end());
        @ } else {
        @    std::sort(data().begin(), data().end(), [](@dt<模板类型1>& a, @dt<模板类型1>& b) {
        @        return a > b;
        @    });
        @ }
    }

    方法 反转顺序 <公开 注释 = "反转数组顺序,例如: 1,2,3 变 3,2,1" 折叠>
    {
        @ std::reverse(data().begin(), data().end());
    }

    方法 是否相等 <公开 类型 = 逻辑型 注释 = "返回所指定容器数组的内容是否与本容器数组相同" 折叠 @嵌入式方法 = "">
    参数 所欲比较的容器 <类型 = 容器基础操作类>
    {
        @ @sn<this>.data() == @<所欲比较的容器>.data()
    }
}

类 容器基础模板类 <公开 基础类 = 容器基础操作类 注释 = "  封装了基本数值数据类型容器的基本操作方法." 注释 = "  注意: 请勿直接继承本类来设置模板实现类."
        注释 = "  模板类型1: 容器成员的数据类型" 折叠 @文档 = "category = \"容器操作.模板类\"" @模板基础类 = 真>
{

    # 方法

    方法 取枚举值 <公开 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前枚举到的成员值,如果有多层"
            注释 = "本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"的枚举成员值." 折叠
            @嵌入式方法 = "parent = \"vector_for, vector_rfor\"" @视窗.返回参考 = 真>
    {
        @ (@dt<模板类型1>&)@sn<this>.data()[__piv_vector_for]
    }

    方法 取成员 <公开 类型 = 模板类型1 注释 = "返回所指定索引位置处的成员值" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ (@dt<模板类型1>&)@sn<this>.data()[static_cast<size_t>(@<索引位置>)]
    }

    方法 重置数组 <公开 注释 = "重置数组中的成员数为所指定的数目,数组原有的数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 欲重置的成员数目 <类型 = 变整数 注释 = "重置后的数组成员数">
    参数 初始值 <类型 = 模板类型1 注释 = "用于提供每个成员的初始值">
    {
        @ @sn<this>.data().assign(static_cast<INT_P>(@<欲重置的成员数目>), @<初始值>)
    }

    方法 置成员值 <公开 注释 = "设置数组中所指定索引位置处的成员值" 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    参数 所欲设置的值 <类型 = 模板类型1 注释 = "提供所欲设置的成员值,先前的值将被覆盖.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)] = @<所欲设置的值>
    }

    方法 初始化 <公开 注释 = "从一系列所提供成员值初始化当前对象" 折叠 @嵌入式方法 = "">
    参数 欲添加成员 <类型 = 模板类型1 @可扩展 = "">
    {
        @ @sn<this>.data() = {@<欲添加成员>}
    }

    方法 加入成员 <公开 注释 = "将一个或多个所指定类型的成员值加入到本数组的尾部" 折叠 @嵌入式方法 = "">
    参数 所欲添加成员值 <类型 = 模板类型1 @可扩展 = "">
    {
        @ piv::push_backs(@sn<this>.data(), @<所欲添加成员值>)
    }

    方法 加入并返回成员 <公开 类型 = 模板类型1 注释 = "将一个所指定类型的成员值加入到本数组的尾部,并返回所加入的成员." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    参数 所欲添加成员值 <类型 = 模板类型1 注释 = "提供所欲加入的成员值">
    {
        @ data().push_back(@<所欲添加成员值>);
        @ return (@dt<模板类型1>&)data().back();
    }

    方法 加入并返回新成员 <公开 静态 类型 = 模板类型1 注释 = "原位默认构造一个成员值并将其加入到本数组的尾部,返回所加入成员的参考."
            注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @禁止流程检查 = 真 @视窗.返回参考 = 真>
    {
        @ data().emplace_back();
        @ return (@dt<模板类型1>&)data().back();
    }

    方法 插入成员 <公开 静态 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().insert(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>);
    }

    方法 插入相同成员 <公开 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目.">
    参数 插入数量 <类型 = 整数>
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().insert(data().begin() + @<插入索引位置>, @<插入数量>, @<所欲插入的成员值>);
    }

    方法 弹出成员 <公开 类型 = 模板类型1 注释 = "返回并删除数组尾部的单个成员." 注释 = "注意: 执行本方法前必须确保数组不为空" 折叠 @禁止流程检查 = 真>
    {
        @ @dt<模板类型1> last_element = data().back();
        @ data().pop_back();
        @ return last_element;
    }

    方法 取首成员 <公开 类型 = 模板类型1 注释 = "取第一个成员." 注释 = "注意: 执行本方法前必须确保容器不为空" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    {
        @ (@dt<模板类型1>&)@sn<this>.data().front()
    }

    方法 取尾成员 <公开 类型 = 模板类型1 注释 = "返回数组尾部的成员值." 注释 = "注意: 执行本方法前必须确保容器不为空" 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    {
        @ (@dt<模板类型1>&)@sn<this>.data().back()
    }

    方法 查找首成员 <公开 类型 = 整数 注释 = "正向查找等于所指定值的第一个成员,找到返回其索引位置,未找到返回-1." 折叠 @禁止流程检查 = 真>
    参数 所欲查找的成员值 <类型 = 模板类型1>
    {
        @ auto it = std::find(data().begin(), data().end(), @<所欲查找的成员值>);
        @ return (it != data().end () ? std::distance(data().begin(), it) : -1);
    }

    方法 查找尾成员 <公开 类型 = 整数 注释 = "逆向查找等于所指定值的最后一个成员,找到返回其索引位置,未找到返回-1." 折叠 @禁止流程检查 = 真>
    参数 所欲查找的成员值 <类型 = 模板类型1>
    {
        @ auto it = std::find(data().rbegin(), data().rend(), @<所欲查找的成员值>);
        @ return (it != data().rend() ? data().size() - std::distance(data().rbegin(), it) - 1 : -1);
    }
}

类 基本容器模板类 <公开 基础类 = 容器基础模板类 注释 = "  使用本模板基础类的容器类将使用值内容复制的方式传递数组数据."
        注释 = "  即: 执行类似赋值操作\"变量容器1 = 变量容器2\"后,变量容器1中将" 注释 = "获得变量容器2中的所有数组数据的一个完全独立拷贝,修改变量容器1"
        注释 = "的内容不会对变量容器2造成影响." 折叠 @文档 = "category = \"容器操作.模板类\"" @模板基础类 = 真>
{
    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](@dt<模板类型1>& lhs, @dt<模板类型1>& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<容器数组> 总共 " + 到文本 (取成员数 ()) + " 成员:\r\n"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # --
    # @begin
    # <> <include>
    # std::vector<@dt<模板类型1>> m_vecData;
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_vecData = objCopyFrom.m_vecData; }
    # inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { m_vecData = std::move(rhs.m_vecData); return *this; }
    # inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_vecData == objCompare.m_vecData); }
    # inline std::vector<@dt<模板类型1>> &data() { return m_vecData; }
    # inline std::vector<@dt<模板类型1>> *pdata() { return &m_vecData; }
    # <> </include>
    # @end
}

类 对象容器模板类 <公开 基础类 = 容器基础模板类 注释 = "  使用本模板可封装任意对象类型的容器数组." 注释 = "  注意: 请勿直接继承本类来设置模板实现类."
        注释 = "  模板类型1: 容器成员的对象类型" 折叠 @文档 = "category = \"容器操作.模板类\"" @模板基础类 = 真>
{

    # 方法

    方法 取指定类型枚举值 <公开 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前枚举到的指定数据类型的成员值,"
            注释 = "如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"的枚举成员值." 折叠
            @嵌入式方法 = "parent = \"vector_for, vector_rfor\"" @视窗.返回参考 = 真>
    参数 所欲获取对象的类型 <类型 = 模板类型1 注释 = "提供所欲获取对象的数据类型,必须提供正确的类型,否则会报错." @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ (@<所欲获取对象的类型>&)@sn<this>.data()[__piv_vector_for]
    }

    方法 取指定类型成员 <公开 注释 = "返回所指定索引位置处的成员值." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    参数 所欲获取对象的类型 <类型 = 模板类型1 注释 = "提供所欲获取对象的数据类型,必须提供正确的类型,否则会报错." @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ (@<所欲获取对象的类型>&)@sn<this>.data()[static_cast<size_t>(@<索引位置>)]
    }

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序." 注释 = "注意: 必须在接收事件\"小于比较\"中实现比较函数,才能正确排序." 折叠>
    {
        @ std::sort(data().begin(), data().end(), [this](@dt<模板类型1>& lhs, @dt<模板类型1>& rhs) { return (bool)this->@<小于比较>(lhs, rhs); });
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序." 注释 = "注意: 必须在接收事件\"大于比较\"中实现比较函数,才能正确排序." 折叠>
    {
        @ std::sort(data().begin(), data().end(), [this](@dt<模板类型1>& lhs, @dt<模板类型1>& rhs) { return (bool)this->@<大于比较>(lhs, rhs); });
    }

    方法 小于比较 <公开 定义事件 类型 = 整数 注释 = "请在本事件中实现小于比较函数,即\"对象1\"<\"对象2\"时返回1."
            注释 = "注: 如未在本事件实现正确的比较,将不能正确进行\"升序排序\"." 返回值注释 = "返回1表示\"对象1\"<\"对象2\",其他情况请返回0." 折叠>
    参数 对象1 <类型 = 模板类型1>
    参数 对象2 <类型 = 模板类型1>

    方法 大于比较 <公开 定义事件 类型 = 整数 注释 = "请在本事件中实现小于比较函数,即\"对象1\">\"对象2\"时返回1."
            注释 = "注: 如未在本事件实现正确的比较,将不能正确进行\"降序排序\"." 返回值注释 = "返回1表示\"对象1\">\"对象2\",其他情况请返回0." 折叠>
    参数 对象1 <类型 = 模板类型1>
    参数 对象2 <类型 = 模板类型1>

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<容器数组> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # @begin
    # <> <include>
    # std::vector<std::remove_pointer<@dt<模板类型1> *>::type> m_vecData;
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_vecData = objCopyFrom.m_vecData; }
    # inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { m_vecData = std::move(rhs.m_vecData); return *this; }
    # inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_vecData == objCompare.m_vecData); }
    # inline std::vector<std::remove_pointer<@dt<模板类型1> *>::type> &data() { return m_vecData; }
    # inline std::vector<std::remove_pointer<@dt<模板类型1> *>::type> *pdata() { return &m_vecData; }
    # <> </include>
    # @end
}

类 数据容器模板类 <公开 基础类 = 容器基础操作类 注释 = "  使用本模板可封装对象中的C++数据成员的容器数组." 注释 = "  注意: 请勿直接继承本类来设置模板实现类."
        注释 = "  模板类型1: 容器成员的对象类型,必须是可以通过" 注释 = "data() 获取对象内的C++数据成员."
        注释 = "  本类唯一可以使用的位置为作为使用 PIV_DECLARE_VECTOR_CLASS" 注释 = "宏进行封装的类的基础类." 折叠
        @文档 = "category = \"容器操作.模板类\"" @模板基础类 = 真>
{
    方法 取枚举值 <公开 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前枚举到的成员值,如果有多层"
            注释 = "本类或本类继承类的\"枚举循环\"嵌套,本方法将返回所处最近层\"枚举循环\"的枚举成员值." 折叠
            @嵌入式方法 = "parent = \"vector_for, vector_rfor\"">
    {
        @ @dt<模板类型1>(@sn<this>.data()[__piv_vector_for])
    }

    方法 取成员 <公开 类型 = 模板类型1 注释 = "返回所指定索引位置处的成员值" 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ @dt<模板类型1>(@sn<this>.data()[static_cast<size_t>(@<索引位置>)])
    }

    方法 重置数组 <公开 注释 = "重置数组中的成员数为所指定的数目,数组原有的数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 欲重置的成员数目 <类型 = 变整数 注释 = "重置后的数组成员数">
    参数 初始值 <类型 = 模板类型1 注释 = "用于提供每个成员的初始值">
    {
        @ @sn<this>.data().assign(static_cast<INT_P>(@<欲重置的成员数目>), @<初始值>.data())
    }

    方法 置成员值 <公开 注释 = "设置数组中所指定索引位置处的成员值" 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    参数 所欲设置的值 <类型 = 模板类型1 注释 = "提供所欲设置的成员值,先前的值将被覆盖.">
    {
        @ @sn<this>.data()[static_cast<size_t>(@<索引位置>)] = @<所欲设置的值>.data()
    }

    方法 加入成员 <公开 注释 = "将一个或多个所指定类型的成员值加入到本数组的尾部" 折叠 @嵌入式方法 = "">
    参数 所欲添加成员值 <类型 = 模板类型1 @可扩展 = "">
    {
        @ for (auto&& v : { @<所欲添加成员值> }) { @sn<this>.data().push_back(v.data()); }
    }

    方法 加入并返回成员 <公开 类型 = 模板类型1 注释 = "将一个所指定类型的成员值加入到本数组的尾部,并返回所加入的成员." 折叠 @禁止流程检查 = 真>
    参数 所欲添加成员值 <类型 = 模板类型1 注释 = "提供所欲加入的成员值">
    {
        @ data().push_back(@<所欲添加成员值>.data());
        @ return @dt<模板类型1>(data().back());
    }

    方法 加入并返回新成员 <公开 静态 类型 = 模板类型1 注释 = "原位默认构造一个成员值并将其加入到本数组的尾部,返回所加入成员的参考."
            注释 = "注意: \"模板类型1\"必须满足可移动插入和可原位构造." 折叠 @禁止流程检查 = 真>
    {
        @ data().emplace_back();
        @ return @dt<模板类型1>(data().back());
    }

    方法 插入成员 <公开 静态 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().insert(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>.data());
    }

    方法 插入相同成员 <公开 注释 = "将所指定的成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于数组成员数目.">
    参数 插入数量 <类型 = 整数>
    参数 所欲插入的成员值 <类型 = 模板类型1>
    {
        @ data().insert(data().begin() + @<插入索引位置>, @<插入数量>, @<所欲插入的成员值>.data());
    }

    方法 弹出成员 <公开 类型 = 模板类型1 注释 = "返回并删除数组尾部的单个成员." 注释 = "注意: 执行本方法前必须确保数组不为空" 折叠 @禁止流程检查 = 真>
    {
        @ auto& last_element = data().back();
        @ data().pop_back();
        @ return @dt<模板类型1>(last_element);
    }

    方法 取首成员 <公开 类型 = 模板类型1 注释 = "取第一个成员." 注释 = "注意: 执行本方法前必须确保容器不为空" 折叠 @嵌入式方法 = "">
    {
        @ @dt<模板类型1>(@sn<this>.data().front())
    }

    方法 取尾成员 <公开 类型 = 模板类型1 注释 = "返回数组尾部的成员值." 注释 = "注意: 执行本方法前必须确保容器不为空" 折叠 @嵌入式方法 = "">
    {
        @ @dt<模板类型1>(@sn<this>.data().back())
    }

    方法 查找首成员 <公开 类型 = 整数 注释 = "正向查找等于所指定值的第一个成员,找到返回其索引位置,未找到返回-1." 折叠 @禁止流程检查 = 真>
    参数 所欲查找的成员值 <类型 = 模板类型1>
    {
        @ auto it = std::find(data().begin(), data().end(), @<所欲查找的成员值>.data());
        @ return (it != data().end () ? std::distance(data().begin(), it) : -1);
    }

    方法 查找尾成员 <公开 类型 = 整数 注释 = "逆向查找等于所指定值的最后一个成员,找到返回其索引位置,未找到返回-1." 折叠 @禁止流程检查 = 真>
    参数 所欲查找的成员值 <类型 = 模板类型1>
    {
        @ auto it = std::find(data().rbegin(), data().rend(), @<所欲查找的成员值>.data());
        @ return (it != data().rend() ? data().size() - std::distance(data().rbegin(), it) - 1 : -1);
    }
}

# @begin
# @def_macro PIV_DECLARE_VECTOR_CLASS(data_type)  \
# <>     <include>  \
#     using DATA_TYPE = std::vector<data_type>;  \
#     DATA_TYPE m_vecData;  \
#     inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_vecData = objCopyFrom.m_vecData; }  \
#     inline @sn<current_class>& operator=(@sn<current_class>&& rhs) { m_vecData = std::move(rhs.m_vecData); return *this; }  \
#     inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_vecData == objCompare.m_vecData); }  \
#     inline DATA_TYPE &data() { return m_vecData; }  \
#     inline DATA_TYPE *pdata() { return &m_vecData; }  \
# <>     </include>
# @end
# ---
# std::vector 基本容器类 ===

类 字节容器类 <公开 基础类 = 基本容器模板类 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "字节">

类 短整数容器类 <公开 基础类 = 基本容器模板类 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "短整数">

类 字符容器类 <公开 基础类 = 基本容器模板类 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "字符">

类 整数容器类 <公开 基础类 = 基本容器模板类 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "整数">

类 变整数容器类 <公开 基础类 = 基本容器模板类 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "变整数">

类 长整数容器类 <公开 基础类 = 基本容器模板类 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "长整数">

类 单精度小数容器类 <公开 基础类 = 基本容器模板类 注释 = "提供基于<std::vector>容器的单精度小数数组封装."
        注释 = "单精度小数的有效值范围从-3.402823E38到-1.401298E-45,有效浮点数为7位,占4字节." @文档 = "category = \"容器操作.数组容器\""
        @模板实现类 = "单精度小数">

类 小数容器类 <公开 基础类 = 基本容器模板类 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "小数">

类 文本容器类 <公开 基础类 = 基本容器模板类 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "文本型">

类 字节集容器类 <公开 基础类 = 对象容器模板类 注释 = "排序仅比较字节集大小" 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "字节集类">
{
    方法 字节集容器类_小于比较 <接收事件 类型 = 整数 注释 = "请在本事件中实现小于比较函数,即\"对象1\"<\"对象2\"时返回1."
            注释 = "注: 如未在本事件实现正确的比较,将不能正确进行\"升序排序\"." 返回值注释 = "返回1表示\"对象1\"<\"对象2\",其他情况请返回0." 折叠>
    参数 来源对象 <类型 = 字节集容器类 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 对象1 <类型 = 字节集类>
    参数 对象2 <类型 = 字节集类>
    {
        如果 (对象1.取字节集长度 () < 对象2.取字节集长度 ())
        {
            返回 (1)
        }
        返回 (0)
    }

    方法 字节集容器类_大于比较 <接收事件 类型 = 整数 注释 = "请在本事件中实现小于比较函数,即\"对象1\">\"对象2\"时返回1."
            注释 = "注: 如未在本事件实现正确的比较,将不能正确进行\"降序排序\"." 返回值注释 = "返回1表示\"对象1\">\"对象2\",其他情况请返回0." 折叠>
    参数 来源对象 <类型 = 字节集容器类 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 对象1 <类型 = 字节集类>
    参数 对象2 <类型 = 字节集类>
    {
        如果 (对象1.取字节集长度 () > 对象2.取字节集长度 ())
        {
            返回 (1)
        }
        返回 (0)
    }
}

类 对象容器类 <公开 基础类 = 对象容器模板类 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "对象类">

# ---

类 标准文本容器类 <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::wstring>的文本数组封装." 注释 = "文本编码为Unicode(UTF-16LE)"
        折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "标准文本类W">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS>(std::wstring)

    方法 取文本成员 <公开 类型 = 文本型 注释 = "返回所指定索引位置处的成员值." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ @an<CVolString>(@sn<this>.data()[static_cast<size_t>(@<索引位置>)].c_str())
    }

    方法 加入多个文本 <公开 注释 = "将一个或多个文本型成员值加入到容器数组尾部" 折叠 @嵌入式方法 = "">
    参数 所欲添加成员值 <类型 = 文本型 @可扩展 = "">
    {
        @ for (auto&& v : { @<所欲添加成员值> }) { @sn<this>.data().push_back(v.GetText()); }
    }

    方法 插入文本成员 <公开 注释 = "将所指定的多个成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲插入的成员值 <类型 = 文本型>
    {
        @ data().emplace(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>.GetText());
    }

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::wstring& lhs, std::wstring& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<标准文本容器数组> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 标准文本容器类W <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::wstring>的文本数组封装." 注释 = "文本编码为Unicode(UTF-16LE)"
        折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "标准文本类W">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS>(std::wstring)

    方法 取文本成员 <公开 类型 = 文本型 注释 = "返回所指定索引位置处的成员值." 注释 = "高效率,不检查边界,不抛出异常,索引无效直接崩溃." 折叠 @嵌入式方法 = "">
    参数 索引位置 <类型 = 变整数 注释 = "提供所欲操作成员的索引位置,必须大于等于0且小于容器数组成员数目.">
    {
        @ @an<CVolString>(@sn<this>.data()[static_cast<size_t>(@<索引位置>)].c_str())
    }

    方法 加入多个文本 <公开 注释 = "将一个或多个文本型成员值加入到容器数组尾部" 折叠 @嵌入式方法 = "">
    参数 所欲添加成员值 <类型 = 文本型 @可扩展 = "">
    {
        @ for (auto&& v : { @<所欲添加成员值> }) { @sn<this>.data().push_back(v.GetText()); }
    }

    方法 插入文本成员 <公开 注释 = "将所指定的多个成员值插入到所指定的索引位置" 折叠>
    参数 插入索引位置 <类型 = 变整数 注释 = "提供所欲插入的成员索引位置,必须大于等于0且小于等于容器数组成员数目.">
    参数 所欲插入的成员值 <类型 = 文本型>
    {
        @ data().emplace(data().begin() + static_cast<size_t>(@<插入索引位置>), @<所欲插入的成员值>.GetText());
    }

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::wstring& lhs, std::wstring& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<标准文本容器数组> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 标准文本容器类U <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::string>的文本数组封装." 注释 = "文本编码为UTF-8" 折叠
        @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "标准文本类U">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (std::string)

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::string& lhs, std::string& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<标准文本容器数组U> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 标准文本容器类A <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::string>的文本数组封装." 注释 = "文本编码为ANSI本地多字节" 折叠
        @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "标准文本类A">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (std::string)

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::string& lhs, std::string& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<标准文本容器数组A> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 文本视图容器类 <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::wstring_view>的文本视图数组封装."
        注释 = "文本编码为Unicode(UTF-16LE)" 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "文本视图类W">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (std::wstring_view)

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::wstring_view& lhs, std::wstring_view& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<文本视图容器类> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 文本视图容器类W <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::wstring_view>的文本视图数组封装."
        注释 = "文本编码为Unicode(UTF-16LE)" 折叠 @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "文本视图类W">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (std::wstring_view)

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::wstring_view& lhs, std::wstring_view& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<文本视图容器类> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 文本视图容器类U <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::string_view>的文本视图数组封装." 注释 = "文本编码为UTF-8" 折叠
        @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "文本视图类U">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (std::string_view)

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::string_view& lhs, std::string_view& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<文本视图容器类U> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

类 文本视图容器类A <公开 基础类 = 数据容器模板类 注释 = "提供基于std::vector<std::string_view>文本视图数组封装." 注释 = "文本编码为ANSI本地多字节" 折叠
        @文档 = "category = \"容器操作.数组容器\"" @模板实现类 = "文本视图类A">
{

    # @ @m<PIV_DECLARE_VECTOR_CLASS> (std::string_view)

    方法 升序排序 <公开 注释 = "将容器数组的所有成员按升序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end());
    }

    方法 降序排序 <公开 注释 = "将容器数组的所有成员按降序排序" 折叠>
    {
        @ std::sort(data().begin(), data().end(), [](std::string_view& lhs, std::string_view& rhs) { return lhs > rhs; });
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        展示内容 = "<文本视图容器类A> 总共 " + 到文本 (取成员数 ()) + " 成员:"
        枚举循环 ()
        {
            加入格式文本 (展示内容, "\r\n%d. %s", 取枚举索引 (), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }
}

#
