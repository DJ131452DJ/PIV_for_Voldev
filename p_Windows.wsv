<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" "">

# 函数HOOK ===

类 简易HOOK类 <公开 注释 = "MinHook原版: https://github.com/TsudaKageyu/minhook"
        注释 = "MultiHook分支: https://github.com/m417z/minhook" 注释 = "  GitHub上非常热门的一个Inline Hook库,原作者2017年后"
        注释 = "就没有再提交更新,所以选择了MultiHook这个分支." 注释 = "  跟官方的\"硬件及键鼠和钩子操作类\"-\"系统API钩子类\"是" 注释 = "同一个开源的不同分支." 折叠
        @文档 = "category = \"HOOK\"" @视窗.外部头文件 = "minhook\\include\\MinHook.h"
        @视窗.外部源文件 = "minhook\\include\\MultiHook.c">
{
    方法 类_初始化 <折叠>
    {
        @ MH_Initialize (); // 初始化MinHook库,必须在HOOK之前执行一次.
    }

    方法 类_清理 <折叠>
    {
        @ MH_Uninitialize (); // 取消初始化MinHook库,必须在退出程序前执行一次.
    }

    方法 置线程释放方法 <公开 类型 = MH状态码 注释 = "设置\"启用钩子\"和\"停用钩子\"时,挂起和恢复线程的方法." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 释放方法 <类型 = MH线程释放方法 注释 = "所欲设置的方法." @默认值 = MH线程释放方法.快速释放>
    {
        @ MH_SetThreadFreezeMethod ((MH_THREAD_FREEZE_METHOD)@<释放方法>)
    }

    方法 取状态码描述 <公开 类型 = 文本型 注释 = "将状态码翻译为文本,比如\"MH_OK\"." 折叠 @嵌入式方法 = "">
    参数 状态码 <类型 = MH状态码 注释 = "所欲翻译的状态码.">
    {
        @ @an<CVolString> (GetWideText (MH_StatusToString ((MH_STATUS)@<状态码>), @an<CVolMem> (), NULL))
    }

    # MinHook ---

    方法 安装钩子 <公开 类型 = MH状态码 注释 = "  创建一个钩子来拦截目标函数,钩子默认处于停用" 注释 = "状态,需要\"启用钩子\"才会开始拦截."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "提供所欲HOOK的目标函数地址,它将被钩子函数控制.">
    参数 钩子函数地址 <类型 = 变整数 注释 = "  提供钩子函数的地址,钩子函数的参数和返回值类型" 注释 = "必须跟目标函数相同.">
    参数 跳板函数地址 <类型 = 变整数 注释 = "  返回目标函数被挂钩后的跳板函数地址,在钩子函数" 注释 = "中调用跳板函数可以执行原始的目标函数." @需求类型 = 可写入变量>
    {
        @ MH_CreateHook ((LPVOID)@<目标函数地址>,
        @                (LPVOID)@<钩子函数地址>, (LPVOID*)&@<跳板函数地址>)
    }

    方法 安装API钩子 <公开 类型 = MH状态码 注释 = "  创建一个钩子来拦截指定的API函数,钩子默认处于" 注释 = "停用状态,需要\"启用钩子\"才会开始拦截."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 模块名称 <类型 = 文本型 注释 = "提供目标函数所在模块名称,比如\"User32.dll\".">
    参数 函数名称 <类型 = 文本型 注释 = "提供所欲HOOK的目标函数名称,比如\"MessageBoxW\".">
    参数 钩子函数地址 <类型 = 变整数 注释 = "  提供钩子函数的地址,钩子函数的参数和返回值类型" 注释 = "必须跟目标函数相同." "">
    参数 跳板函数地址 <类型 = 变整数 注释 = "  返回API被挂钩后的跳板函数地址,在钩子函数中调用" 注释 = "跳板函数可以执行API的原始函数." @需求类型 = 可写入变量>
    参数 目标函数地址 <类型 = 变整数 注释 = "  返回API的原始函数地址,可用于\"启用钩子/停用钩子\"" 注释 = "和\"卸载钩子\",启用钩子后执行该地址会进入钩子函数,"
            注释 = "因此请勿在钩子函数中执行该地址." @需求类型 = 可写入变量>
    {
        @ MH_CreateHookApiEx (@<模块名称>.GetText (),
        @                     GetMbsText (@<函数名称>.GetText (), CVolMem (), NULL),
        @                     (LPVOID)@<钩子函数地址>, (LPVOID*)&@<跳板函数地址>, (LPVOID*)&@<目标函数地址>)
    }

    方法 安装API钩子2 <公开 类型 = MH状态码 注释 = "  创建一个钩子来拦截指定的API函数,钩子默认处于" 注释 = "停用状态,需要\"启用钩子\"才会开始拦截."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠>
    参数 模块名称 <类型 = 文本型 注释 = "提供目标函数所在模块名称,比如\"User32.dll\".">
    参数 函数名称 <类型 = 文本型 注释 = "提供所欲HOOK的目标函数名称,比如\"MessageBoxW\".">
    参数 钩子信息 <类型 = HOOK信息类 注释 = "  设置和返回钩子信息,必须先设置好\"钩子\"函数," 注释 = "执行成功后会自动填入跳板和目标函数." "">
    {
        返回 (安装API钩子 (模块名称, 函数名称, 钩子信息.钩子, 钩子信息.跳板, 钩子信息.目标))
    }

    方法 卸载钩子 <公开 类型 = MH状态码 注释 = "卸载一个或全部已经安装的钩子,卸载前会自动停用钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲卸载钩子的目标函数地址,若提供的" 注释 = "参数为0,将一次性卸载所有已安装的钩子.">
    {
        @ MH_RemoveHook ((LPVOID)@<目标函数地址>)
    }

    方法 卸载空闲钩子 <公开 类型 = MH状态码 注释 = "卸载所有处于停用状态的钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    {
        @ MH_RemoveDisabledHooks ()
    }

    方法 启用钩子 <公开 类型 = MH状态码 注释 = "  启用一个或全部已安装的钩子,钩子函数在启用后" 注释 = "才会开始拦截." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_EnableHook ((LPVOID)@<目标函数地址>)
    }

    方法 停用钩子 <公开 类型 = MH状态码 注释 = "  停用一个或全部已安装的钩子,钩子函数在停用后" 注释 = "会暂停拦截." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_DisableHook ((LPVOID)@<目标函数地址>)
    }

    方法 请求启用钩子 <公开 类型 = MH状态码 注释 = "  请求启用一个或全部已安装的钩子,后续需要调用" 注释 = "\"应用请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_QueueEnableHook ((LPVOID)@<目标函数地址>)
    }

    方法 请求停用钩子 <公开 类型 = MH状态码 注释 = "  请求停用一个或全部已安装的钩子,后续需要调用" 注释 = "\"应用请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_QueueDisableHook ((LPVOID)@<目标函数地址>)
    }

    方法 应用请求 <公开 类型 = MH状态码 注释 = "一次性应用所有请求的更改." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    {
        @ MH_ApplyQueued ()
    }
}

类 多重HOOK类 <公开 注释 = "  MultiHook 这个分支在原版的基础上增加了给同一个函数" 注释 = "安装多个钩子的功能,这些多重钩子可以同时启用和生效." 折叠
        @文档 = "category = \"HOOK\"" @强制依赖 = "简易HOOK类">
{
    方法 类_初始化 <折叠>
    {
        @ MH_Initialize (); // 初始化MinHook库,必须在HOOK之前执行一次.
    }

    方法 类_清理 <折叠>
    {
        @ MH_Uninitialize (); // 取消初始化MinHook库,必须在退出程序前执行一次.
    }

    方法 置线程释放方法 <公开 类型 = MH状态码 注释 = "设置\"启用钩子\"和\"停用钩子\"时,挂起和恢复线程的方法." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 释放方法 <类型 = MH线程释放方法 注释 = "所欲设置的方法." @默认值 = MH线程释放方法.快速释放>
    {
        @ MH_SetThreadFreezeMethod ((MH_THREAD_FREEZE_METHOD)@<释放方法>)
    }

    方法 取状态码描述 <公开 类型 = 文本型 注释 = "将状态码翻译为文本,比如\"MH_OK\"." 折叠 @嵌入式方法 = "">
    参数 状态码 <类型 = MH状态码 注释 = "所欲翻译的状态码.">
    {
        @ @an<CVolString> (GetWideText (MH_StatusToString ((MH_STATUS)@<状态码>), @an<CVolMem> (), NULL))
    }

    # MultiHook ---

    方法 安装钩子 <公开 类型 = MH状态码 注释 = "  创建一个自定义ID的钩子来拦截目标函数,默认处于" 注释 = "停用状态,需要\"启用钩子\"才会开始拦截."
            注释 = "  安装到同一个函数的多个钩子可以同时生效,在钩子" 注释 = "函数中只能调用同一个方法返回的跳板函数." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "  提供自定义的钩子标识符(从1开始),用于在同一个" 注释 = "目标函数上安装多个不同的钩子函数." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "提供所欲HOOK的目标函数地址,它将被钩子函数控制.">
    参数 钩子函数地址 <类型 = 变整数 注释 = "  提供钩子函数的地址,钩子函数的参数和返回值类型" 注释 = "必须跟目标函数相同.">
    参数 跳板函数地址 <类型 = 变整数 注释 = "  返回目标函数被挂钩后的跳板函数地址,在钩子函数" 注释 = "中调用跳板函数可以执行原始的目标函数." @需求类型 = 可写入变量>
    {
        @ MH_CreateHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>,
        @                  (LPVOID)@<钩子函数地址>, (LPVOID*)&@<跳板函数地址>)
    }

    方法 卸载钩子 <公开 类型 = MH状态码 注释 = "卸载指定钩子ID的一个或全部已经安装的钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "  所欲卸载的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲卸载钩子的目标函数地址,若提供的" 注释 = "参数为0,将一次性卸载所有已安装的钩子.">
    {
        @ MH_RemoveHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 卸载空闲钩子 <公开 类型 = MH状态码 注释 = "卸载指定钩子ID的所有处于停用状态的钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "所欲卸载的自定义钩子标识符(从1开始)." @默认值 = 1>
    {
        @ MH_RemoveDisabledHooksEx ((ULONG_PTR)@<钩子ID>)
    }

    方法 启用钩子 <公开 类型 = MH状态码 注释 = "  启用指定钩子ID的一个或全部已安装的钩子,钩子" 注释 = "函数在启用后才会开始拦截." 返回值注释 = "返回0表示成功,其他值为失败."
            折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲启用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_EnableHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 停用钩子 <公开 类型 = MH状态码 注释 = "  停用指定钩子ID的一个或全部已安装的钩子,钩子" 注释 = "函数在停用后会暂停拦截." 返回值注释 = "返回0表示成功,其他值为失败."
            折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲停用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_DisableHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 请求启用钩子 <公开 类型 = MH状态码 注释 = "  请求启用指定钩子ID的一个或全部已安装的钩子," 注释 = "后续需要调用\"应用请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲启用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_QueueEnableHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 请求停用钩子 <公开 类型 = MH状态码 注释 = "  请求停用指定钩子ID的一个或全部已安装的钩子," 注释 = "后续需要调用\"应用多重请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲停用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_QueueDisableHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 应用请求 <公开 类型 = MH状态码 注释 = "一次性应用指定钩子ID所有请求的更改." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲应用请求的自定义钩子标识符(从1开始)." @默认值 = 1>
    {
        @ MH_ApplyQueuedEx ((ULONG_PTR)@<钩子ID>)
    }
}

类 MH状态码 <公开 注释 = "执行函数返回的状态码(MH_STATUS),0表示成功,其他表示失败." 折叠 @文档 = "category = \"HOOK.辅助类\"" @常量类 = 整数
        @强制依赖 = "简易HOOK类">
{
    常量 未知错误 <公开 值 = @MH_UNKNOWN 注释 = "-1 未知错误">
    常量 成功 <公开 值 = @MH_OK 注释 = "0  成功无错误">
    常量 已初始化 <公开 值 = @MH_ERROR_ALREADY_INITIALIZED 注释 = "1  MinHook已经初始化">
    常量 未初始化 <公开 值 = @MH_ERROR_NOT_INITIALIZED 注释 = "2  MinHook尚未初始化,或已经被卸载.">
    常量 已创建 <公开 值 = @MH_ERROR_ALREADY_CREATED 注释 = "3  目标函数已经安装了钩子">
    常量 未创建 <公开 值 = @MH_ERROR_NOT_CREATED 注释 = "4  目标函数尚未安装钩子">
    常量 已启用 <公开 值 = @MH_ERROR_ENABLED 注释 = "5  目标函数的钩子已被启用">
    常量 已停用 <公开 值 = @MH_ERROR_DISABLED 注释 = "6  目标函数的钩子已被停用">
    常量 不可执行 <公开 值 = @MH_ERROR_NOT_EXECUTABLE 注释 = "7  函数指针无效,指向的地址不是可执行区域.">
    常量 不支持的函数 <公开 值 = @MH_ERROR_UNSUPPORTED_FUNCTION 注释 = "8  目标函数不能安装钩子">
    常量 内存分配失败 <公开 值 = @MH_ERROR_MEMORY_ALLOC 注释 = "9  内存分配失败">
    常量 内存受保护 <公开 值 = @MH_ERROR_MEMORY_PROTECT 注释 = "10 更改内存的保护属性失败">
    常量 找不到模块 <公开 值 = @MH_ERROR_MODULE_NOT_FOUND 注释 = "11 指定的模块可能未加载">
    常量 找不到函数 <公开 值 = @MH_ERROR_FUNCTION_NOT_FOUND 注释 = "12 模块中找不到指定的函数">
    常量 互斥锁错误 <公开 值 = @MH_ERROR_MUTEX_FAILURE 注释 = "13 创建或等待主互斥锁时失败">
}

类 MH线程释放方法 <公开 注释 = "\"置线程释放方法\"的参数(MH_THREAD_FREEZE_METHOD)" 折叠 @文档 = "category = \"HOOK.辅助类\""
        @常量类 = 整数 @强制依赖 = "简易HOOK类">
{
    常量 原始方法 <公开 值 = @MH_FREEZE_METHOD_ORIGINAL 注释 = "  MinHook原来提供的方法,使用CreateToolhelp32Snapshot,"
            注释 = "有文档和支持所有的Windows版本,但速度很慢和可靠性较低.">
    常量 快速释放 <公开 值 = @MH_FREEZE_METHOD_FAST_UNDOCUMENTED 注释 = "  使用NtGetNextThread,速度更快且可靠性更高,但没有文档."
            注释 = "支持Windows Vista之后的系统,旧系统会自动回退到原始方法.">
    常量 不作释放 <公开 值 = @MH_FREEZE_METHOD_NONE_UNSAFE 注释 = "  不挂起线程也不调整指令指针寄存器.除非你了解它的含义并"
            注释 = "确定它是安全的,否则不要使用本方法.">
}

类 HOOK信息类 <公开 注释 = "为了方便用户使用而定义的一个类型." 注释 = "用来记录HOOK的相关信息,比如函数地址和多重钩子ID." 折叠
        @文档 = "category = \"HOOK.辅助类\"">
{
    变量 ID <公开 类型 = 变整数 注释 = "多重钩子ID">
    变量 钩子 <公开 类型 = 变整数 注释 = "钩子函数地址">
    变量 跳板 <公开 类型 = 变整数 注释 = "跳板函数地址">
    变量 目标 <公开 类型 = 变整数 注释 = "目标函数地址">
}

类 HOOK信息数组类 <公开 基础类 = 对象数组模板类 注释 = "\"HOOK信息类\"的数组" @文档 = "category = \"HOOK.辅助类\"" @模板实现类 = "HOOK信息类">

#
# 键鼠标模拟 API版 ===

类 发送输入类 <公开 折叠 @文档 = "category = \"系统操作.发送输入\"" @全局类 = 真>
{
    方法 发送鼠标输入 <公开 静态 类型 = 整数 返回值注释 = "成功返回插入的输入事件数,0为表示输入被另一个线程阻止了." 折叠 @禁止流程检查 = 真>
    参数 输入数组 <类型 = 鼠标输入数组类>
    {
        @ UINT cInputs = (UINT)@<输入数组>.GetCount ();
        @ LPINPUT pInputs = (LPINPUT)malloc (sizeof(INPUT) * cInputs);
        @ for (UINT i = 0; i < cInputs; i++)
        @ {
        @     ((@dt<鼠标输入类>&)@<输入数组>.GetAt (i)).GetStruct ((@dt<鼠标输入类>::S*)&pInputs[i]);
        @ }
        @ UINT ret = SendInput (cInputs, pInputs, sizeof(INPUT));
        @ free (pInputs);
        @ return (INT)ret;
    }

    方法 发送键盘输入 <公开 静态 类型 = 整数 返回值注释 = "成功返回插入的输入事件数,0为表示输入被另一个线程阻止了." 折叠 @禁止流程检查 = 真>
    参数 输入数组 <类型 = 键盘输入数组类>
    {
        @ UINT cInputs = (UINT)@<输入数组>.GetCount ();
        @ LPINPUT pInputs = (LPINPUT)malloc (sizeof(INPUT) * cInputs);
        @ for (UINT i = 0; i < cInputs; i++)
        @ {
        @     ((@dt<键盘输入类>&)@<输入数组>.GetAt (i)).GetStruct ((@dt<键盘输入类>::S*)&pInputs[i]);
        @ }
        @ UINT ret = SendInput (cInputs, pInputs, sizeof(INPUT));
        @ free (pInputs);
        @ return (INT)ret;
    }

    方法 发送硬件输入 <公开 静态 类型 = 整数 返回值注释 = "成功返回插入的输入事件数,0为表示输入被另一个线程阻止了." 折叠 @禁止流程检查 = 真>
    参数 输入数组 <类型 = 硬件输入数组类>
    {
        @ UINT cInputs = (UINT)@<输入数组>.GetCount ();
        @ LPINPUT pInputs = (INPUT*)malloc (sizeof(INPUT) * cInputs);
        @ for (UINT i = 0; i < cInputs; i++)
        @ {
        @     ((@dt<硬件输入类>&)@<输入数组>.GetAt (i)).GetStruct ((@dt<硬件输入类>::S*)&pInputs[i]);
        @ }
        @ UINT ret = SendInput (cInputs, pInputs, sizeof(INPUT));
        @ free (pInputs);
        @ return (INT)ret;
    }
}

类 鼠标输入类 <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 type <公开 类型 = 整数 值 = 0 注释 = "固定为0=INPUT_MOUSE">
    变量 mi <公开 类型 = MOUSEINPUT>
}

类 MOUSEINPUT <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 dx <公开 类型 = 整数 注释 = "鼠标x坐标">
    变量 dy <公开 类型 = 整数 注释 = "鼠标y坐标">
    变量 mouseData <公开 类型 = 整数 注释 = "按dwFlags的备注填写">
    变量 dwFlags <公开 类型 = 整数 注释 = "可使用\"鼠标事件常量类\"的位或组合值.">
    变量 time <公开 类型 = 整数 注释 = "事件的时间戳,以毫秒为单位.如果此参数为0,系统将提供自己的时间戳.">
    变量 dwExtraInfo <公开 类型 = 变整数 注释 = "与鼠标事件关联的附加值.应用程序调用GetMessageExtraInfo可获取此额外信息.">
}

类 鼠标输入数组类 <公开 基础类 = 对象数组模板类 @文档 = "category = \"系统操作.发送输入.辅助类\"" @模板实现类 = "鼠标输入类">

类 鼠标事件常量类 <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"">
{
    常量 鼠标移动 <公开 类型 = 整数 值 = @MOUSEEVENTF_MOVE>
    常量 按下左键 <公开 类型 = 整数 值 = @MOUSEEVENTF_LEFTDOWN>
    常量 释放左键 <公开 类型 = 整数 值 = @MOUSEEVENTF_LEFTUP>
    常量 按下右键 <公开 类型 = 整数 值 = @MOUSEEVENTF_RIGHTDOWN>
    常量 释放右键 <公开 类型 = 整数 值 = @MOUSEEVENTF_RIGHTUP>
    常量 按下中键 <公开 类型 = 整数 值 = @MOUSEEVENTF_MIDDLEDOWN>
    常量 释放中键 <公开 类型 = 整数 值 = @MOUSEEVENTF_MIDDLEUP>
    常量 按下X键 <公开 类型 = 整数 值 = @MOUSEEVENTF_XDOWN 注释 = "mouseData的值1为按下第一个X键,2为按下第二个X键">
    常量 释放X键 <公开 类型 = 整数 值 = @MOUSEEVENTF_XUP 注释 = "mouseData的值1为释放第一个X键,2为释放第二个X键">
    常量 鼠标滚轮 <公开 类型 = 整数 值 = @MOUSEEVENTF_WHEEL 注释 = "mouseData的值为滚轮的垂直移动量">
    常量 水平滚轮 <公开 类型 = 整数 值 = 0x1000 注释 = "mouseData的值为滚轮的水平移动量">
    常量 不合并消息 <公开 类型 = 整数 值 = 0x2000 注释 = "WM_MOUSEMOVE消息将不会合并,默认是合并WM_MOUSEMOVE消息.">
    常量 虚拟桌面 <公开 类型 = 整数 值 = @MOUSEEVENTF_VIRTUALDESK 注释 = "将坐标映射到整个桌面,必须与\"绝对坐标\"配合使用。">
    常量 绝对坐标 <公开 类型 = 整数 值 = @MOUSEEVENTF_ABSOLUTE 注释 = "dx和dy使用绝对坐标值,否则为相对坐标.">
}

类 键盘输入类 <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 type <公开 类型 = 整数 值 = 1 注释 = "固定为1=INPUT_KEYBOARD">
    变量 ki <公开 类型 = KEYBDINPUT>
}

类 KEYBDINPUT <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 wVk <公开 类型 = 短整数 注释 = "虚拟按键代码,范围为1-254." 注释 = "如果dwFlags为KEYEVENTF_UNICODE,本成员必须为0.">
    变量 wScan <公开 类型 = 短整数 注释 = "按键的硬件扫描代码." 注释 = "如果dwFlags为KEYEVENTF_UNICODE,则本在成员指定发送到前台应用的UNICODE字符.">
    变量 dwFlags <公开 类型 = 整数 注释 = "为以下整数的位或组合值." 注释 = "1=KEYEVENTF_EXTENDEDKEY,扫描代码前面会有一个值为0xE0(224)的前缀字节."
            注释 = "2=KEYEVENTF_KEYUP,指定本值为释放按键,未指定本值为按下按键." 注释 = "8=KEYEVENTF_SCANCODE,指定本值后将忽略wVk,使用wScan识别按键."
            注释 = "4=KEYEVENTF_UNICODE,系统将合成VK_PACKET按键,wVk的值必须为0,本值只能与KEYEVENTF_KEYUP组合使用.">
    变量 time <公开 类型 = 整数 注释 = "事件的时间戳,以毫秒为单位.如果此参数为0,系统将提供自己的时间戳.">
    变量 dwExtraInfo <公开 类型 = 变整数 注释 = "与鼠标事件关联的附加值.应用程序调用GetMessageExtraInfo可获取此额外信息.">
}

类 键盘输入数组类 <公开 基础类 = 对象数组模板类 @文档 = "category = \"系统操作.发送输入.辅助类\"" @模板实现类 = "键盘输入类">

类 硬件输入类 <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 type <公开 类型 = 整数 值 = 2 注释 = "固定为2=INPUT_HARDWARE">
    变量 hi <公开 类型 = HARDWAREINPUT>
}

类 HARDWAREINPUT <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 uMsg <公开 类型 = 整数 注释 = "此消息由输入硬件生成.">
    变量 wParamL <公开 类型 = 短整数 注释 = "uMsg的LPRAM参数的低位值.">
    变量 wParamH <公开 类型 = 短整数 注释 = "uMsg的LPRAM参数的高位值.">
}

类 硬件输入数组类 <公开 基础类 = 对象数组模板类 @文档 = "category = \"系统操作.发送输入.辅助类\"" @模板实现类 = "硬件输入类">

#
