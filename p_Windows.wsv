<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" "">

# 函数HOOK ===

类 简易HOOK类 <公开 注释 = "MinHook原版: https://github.com/TsudaKageyu/minhook"
        注释 = "MultiHook分支: https://github.com/m417z/minhook" 注释 = "  GitHub上非常热门的一个Inline Hook库,原作者2017年后"
        注释 = "就没有再提交更新,所以选择了MultiHook这个分支." 注释 = "  跟官方的\"硬件及键鼠和钩子操作类\"-\"系统API钩子类\"是" 注释 = "同一个开源的不同分支." 折叠
        @文档 = "category = \"HOOK\"" @视窗.外部头文件 = "minhook\\include\\MinHook.h"
        @视窗.外部源文件 = "minhook\\include\\MultiHook.c">
{
    方法 置线程释放方法 <公开 类型 = MH状态码 注释 = "设置\"启用钩子\"和\"停用钩子\"时,挂起和恢复线程的方法." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 释放方法 <类型 = MH线程释放方法 注释 = "所欲设置的方法." @默认值 = MH线程释放方法.快速释放>
    {
        @ MH_SetThreadFreezeMethod ((MH_THREAD_FREEZE_METHOD)@<释放方法>)
    }

    方法 取状态码描述 <公开 类型 = 文本型 注释 = "将状态码翻译为文本,比如\"MH_OK\"." 折叠 @嵌入式方法 = "">
    参数 状态码 <类型 = MH状态码 注释 = "所欲翻译的状态码.">
    {
        @ @an<CVolString> (GetWideText (MH_StatusToString ((MH_STATUS)@<状态码>), @an<CVolMem> (), NULL))
    }

    # MinHook ---

    方法 安装钩子 <公开 类型 = MH状态码 注释 = "  创建一个钩子来拦截目标函数,钩子默认处于停用" 注释 = "状态,需要\"启用钩子\"才会开始拦截."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "提供所欲HOOK的目标函数地址,它将被钩子函数控制.">
    参数 钩子函数地址 <类型 = 变整数 注释 = "  提供钩子函数的地址,钩子函数的参数和返回值类型" 注释 = "必须跟目标函数相同.">
    参数 跳板函数地址 <类型 = 变整数 注释 = "  返回目标函数被挂钩后的跳板函数地址,在钩子函数" 注释 = "中调用跳板函数可以执行原始的目标函数." @需求类型 = 可写入变量>
    {
        @ MH_CreateHook ((LPVOID)@<目标函数地址>,
        @                (LPVOID)@<钩子函数地址>, (LPVOID*)&@<跳板函数地址>)
    }

    方法 安装API钩子 <公开 类型 = MH状态码 注释 = "  创建一个钩子来拦截指定的API函数,钩子默认处于" 注释 = "停用状态,需要\"启用钩子\"才会开始拦截."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 模块名称 <类型 = 文本型 注释 = "提供目标函数所在模块名称,比如\"User32.dll\".">
    参数 函数名称 <类型 = 文本型 注释 = "提供所欲HOOK的目标函数名称,比如\"MessageBoxW\".">
    参数 钩子函数地址 <类型 = 变整数 注释 = "  提供钩子函数的地址,钩子函数的参数和返回值类型" 注释 = "必须跟目标函数相同." "">
    参数 跳板函数地址 <类型 = 变整数 注释 = "  返回API被挂钩后的跳板函数地址,在钩子函数中调用" 注释 = "跳板函数可以执行API的原始函数." @需求类型 = 可写入变量>
    参数 目标函数地址 <类型 = 变整数 注释 = "  返回API的原始函数地址,可用于\"启用钩子/停用钩子\"" 注释 = "和\"卸载钩子\",启用钩子后执行该地址会进入钩子函数,"
            注释 = "因此请勿在钩子函数中执行该地址." @需求类型 = 可写入变量>
    {
        @ MH_CreateHookApiEx (@<模块名称>.GetText (),
        @                     GetMbsText (@<函数名称>.GetText (), CVolMem (), NULL),
        @                     (LPVOID)@<钩子函数地址>, (LPVOID*)&@<跳板函数地址>, (LPVOID*)&@<目标函数地址>)
    }

    方法 安装API钩子2 <公开 类型 = MH状态码 注释 = "  创建一个钩子来拦截指定的API函数,钩子默认处于" 注释 = "停用状态,需要\"启用钩子\"才会开始拦截."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠>
    参数 模块名称 <类型 = 文本型 注释 = "提供目标函数所在模块名称,比如\"User32.dll\".">
    参数 函数名称 <类型 = 文本型 注释 = "提供所欲HOOK的目标函数名称,比如\"MessageBoxW\".">
    参数 钩子信息 <类型 = HOOK信息类 注释 = "  设置和返回钩子信息,必须先设置好\"钩子\"函数," 注释 = "执行成功后会自动填入跳板和目标函数." "">
    {
        返回 (安装API钩子 (模块名称, 函数名称, 钩子信息.钩子, 钩子信息.跳板, 钩子信息.目标))
    }

    方法 卸载钩子 <公开 类型 = MH状态码 注释 = "卸载一个或全部已经安装的钩子,卸载前会自动停用钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲卸载钩子的目标函数地址,若提供的" 注释 = "参数为0,将一次性卸载所有已安装的钩子.">
    {
        @ MH_RemoveHook ((LPVOID)@<目标函数地址>)
    }

    方法 卸载空闲钩子 <公开 类型 = MH状态码 注释 = "卸载所有处于停用状态的钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    {
        @ MH_RemoveDisabledHooks ()
    }

    方法 启用钩子 <公开 类型 = MH状态码 注释 = "  启用一个或全部已安装的钩子,钩子函数在启用后" 注释 = "才会开始拦截." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_EnableHook ((LPVOID)@<目标函数地址>)
    }

    方法 停用钩子 <公开 类型 = MH状态码 注释 = "  停用一个或全部已安装的钩子,钩子函数在停用后" 注释 = "会暂停拦截." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_DisableHook ((LPVOID)@<目标函数地址>)
    }

    方法 请求启用钩子 <公开 类型 = MH状态码 注释 = "  请求启用一个或全部已安装的钩子,后续需要调用" 注释 = "\"应用请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_QueueEnableHook ((LPVOID)@<目标函数地址>)
    }

    方法 请求停用钩子 <公开 类型 = MH状态码 注释 = "  请求停用一个或全部已安装的钩子,后续需要调用" 注释 = "\"应用请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_QueueDisableHook ((LPVOID)@<目标函数地址>)
    }

    方法 应用请求 <公开 类型 = MH状态码 注释 = "一次性应用所有请求的更改." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    {
        @ MH_ApplyQueued ()
    }

    # @begin
    # <> <include>
    # static void @an<_sOnBeforeAppInit> () { MH_Initialize (); }
    # static void @an<_sOnAfterAppExit> () { MH_Uninitialize (); }
    # <> </include>
    # @end
}

类 多重HOOK类 <公开 注释 = "  MultiHook 这个分支在原版的基础上增加了给同一个函数" 注释 = "安装多个钩子的功能,这些多重钩子可以同时启用和生效." 折叠
        @文档 = "category = \"HOOK\"" @强制依赖 = "简易HOOK类">
{
    方法 置线程释放方法 <公开 类型 = MH状态码 注释 = "设置\"启用钩子\"和\"停用钩子\"时,挂起和恢复线程的方法." 返回值注释 = "返回0表示成功,其他值为失败." 折叠
            @嵌入式方法 = "">
    参数 释放方法 <类型 = MH线程释放方法 注释 = "所欲设置的方法." @默认值 = MH线程释放方法.快速释放>
    {
        @ MH_SetThreadFreezeMethod ((MH_THREAD_FREEZE_METHOD)@<释放方法>)
    }

    方法 取状态码描述 <公开 类型 = 文本型 注释 = "将状态码翻译为文本,比如\"MH_OK\"." 折叠 @嵌入式方法 = "">
    参数 状态码 <类型 = MH状态码 注释 = "所欲翻译的状态码.">
    {
        @ @an<CVolString> (GetWideText (MH_StatusToString ((MH_STATUS)@<状态码>), @an<CVolMem> (), NULL))
    }

    # MultiHook ---

    方法 安装钩子 <公开 类型 = MH状态码 注释 = "  创建一个自定义ID的钩子来拦截目标函数,默认处于" 注释 = "停用状态,需要\"启用钩子\"才会开始拦截."
            注释 = "  安装到同一个函数的多个钩子可以同时生效,在钩子" 注释 = "函数中只能调用同一个方法返回的跳板函数." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "  提供自定义的钩子标识符(从1开始),用于在同一个" 注释 = "目标函数上安装多个不同的钩子函数." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "提供所欲HOOK的目标函数地址,它将被钩子函数控制.">
    参数 钩子函数地址 <类型 = 变整数 注释 = "  提供钩子函数的地址,钩子函数的参数和返回值类型" 注释 = "必须跟目标函数相同.">
    参数 跳板函数地址 <类型 = 变整数 注释 = "  返回目标函数被挂钩后的跳板函数地址,在钩子函数" 注释 = "中调用跳板函数可以执行原始的目标函数." @需求类型 = 可写入变量>
    {
        @ MH_CreateHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>,
        @                  (LPVOID)@<钩子函数地址>, (LPVOID*)&@<跳板函数地址>)
    }

    方法 卸载钩子 <公开 类型 = MH状态码 注释 = "卸载指定钩子ID的一个或全部已经安装的钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "  所欲卸载的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲卸载钩子的目标函数地址,若提供的" 注释 = "参数为0,将一次性卸载所有已安装的钩子.">
    {
        @ MH_RemoveHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 卸载空闲钩子 <公开 类型 = MH状态码 注释 = "卸载指定钩子ID的所有处于停用状态的钩子." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "所欲卸载的自定义钩子标识符(从1开始)." @默认值 = 1>
    {
        @ MH_RemoveDisabledHooksEx ((ULONG_PTR)@<钩子ID>)
    }

    方法 启用钩子 <公开 类型 = MH状态码 注释 = "  启用指定钩子ID的一个或全部已安装的钩子,钩子" 注释 = "函数在启用后才会开始拦截." 返回值注释 = "返回0表示成功,其他值为失败."
            折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲启用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_EnableHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 停用钩子 <公开 类型 = MH状态码 注释 = "  停用指定钩子ID的一个或全部已安装的钩子,钩子" 注释 = "函数在停用后会暂停拦截." 返回值注释 = "返回0表示成功,其他值为失败."
            折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲停用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_DisableHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 请求启用钩子 <公开 类型 = MH状态码 注释 = "  请求启用指定钩子ID的一个或全部已安装的钩子," 注释 = "后续需要调用\"应用请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲启用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲启用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性启用所有已安装的钩子.">
    {
        @ MH_QueueEnableHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 请求停用钩子 <公开 类型 = MH状态码 注释 = "  请求停用指定钩子ID的一个或全部已安装的钩子," 注释 = "后续需要调用\"应用多重请求\"才会实际执行."
            返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲停用的自定义钩子标识符(从1开始)." @默认值 = 1>
    参数 目标函数地址 <类型 = 变整数 注释 = "  提供所欲停用钩子的目标函数地址,若提供的参数" 注释 = "为0,将一次性停用所有已安装的钩子.">
    {
        @ MH_QueueDisableHookEx ((ULONG_PTR)@<钩子ID>, (LPVOID)@<目标函数地址>)
    }

    方法 应用请求 <公开 类型 = MH状态码 注释 = "一次性应用指定钩子ID所有请求的更改." 返回值注释 = "返回0表示成功,其他值为失败." 折叠 @嵌入式方法 = "">
    参数 钩子ID <类型 = 变整数 注释 = "提供所欲应用请求的自定义钩子标识符(从1开始)." @默认值 = 1>
    {
        @ MH_ApplyQueuedEx ((ULONG_PTR)@<钩子ID>)
    }

    # @begin
    # <> <include>
    # static void @an<_sOnBeforeAppInit> () { MH_Initialize (); }
    # static void @an<_sOnAfterAppExit> () { MH_Uninitialize (); }
    # <> </include>
    # @end
}

类 MH状态码 <公开 注释 = "执行函数返回的状态码(MH_STATUS),0表示成功,其他表示失败." 折叠 @文档 = "category = \"HOOK.辅助类\"" @常量类 = 整数
        @强制依赖 = "简易HOOK类">
{
    常量 未知错误 <公开 值 = @MH_UNKNOWN 注释 = "-1 未知错误">
    常量 成功 <公开 值 = @MH_OK 注释 = "0  成功无错误">
    常量 已初始化 <公开 值 = @MH_ERROR_ALREADY_INITIALIZED 注释 = "1  MinHook已经初始化">
    常量 未初始化 <公开 值 = @MH_ERROR_NOT_INITIALIZED 注释 = "2  MinHook尚未初始化,或已经被卸载.">
    常量 已创建 <公开 值 = @MH_ERROR_ALREADY_CREATED 注释 = "3  目标函数已经安装了钩子">
    常量 未创建 <公开 值 = @MH_ERROR_NOT_CREATED 注释 = "4  目标函数尚未安装钩子">
    常量 已启用 <公开 值 = @MH_ERROR_ENABLED 注释 = "5  目标函数的钩子已被启用">
    常量 已停用 <公开 值 = @MH_ERROR_DISABLED 注释 = "6  目标函数的钩子已被停用">
    常量 不可执行 <公开 值 = @MH_ERROR_NOT_EXECUTABLE 注释 = "7  函数指针无效,指向的地址不是可执行区域.">
    常量 不支持的函数 <公开 值 = @MH_ERROR_UNSUPPORTED_FUNCTION 注释 = "8  目标函数不能安装钩子">
    常量 内存分配失败 <公开 值 = @MH_ERROR_MEMORY_ALLOC 注释 = "9  内存分配失败">
    常量 内存受保护 <公开 值 = @MH_ERROR_MEMORY_PROTECT 注释 = "10 更改内存的保护属性失败">
    常量 找不到模块 <公开 值 = @MH_ERROR_MODULE_NOT_FOUND 注释 = "11 指定的模块可能未加载">
    常量 找不到函数 <公开 值 = @MH_ERROR_FUNCTION_NOT_FOUND 注释 = "12 模块中找不到指定的函数">
    常量 互斥锁错误 <公开 值 = @MH_ERROR_MUTEX_FAILURE 注释 = "13 创建或等待主互斥锁时失败">
}

类 MH线程释放方法 <公开 注释 = "\"置线程释放方法\"的参数(MH_THREAD_FREEZE_METHOD)" 折叠 @文档 = "category = \"HOOK.辅助类\""
        @常量类 = 整数 @强制依赖 = "简易HOOK类">
{
    常量 原始方法 <公开 值 = @MH_FREEZE_METHOD_ORIGINAL 注释 = "  MinHook原来提供的方法,使用CreateToolhelp32Snapshot,"
            注释 = "有文档和支持所有的Windows版本,但速度很慢和可靠性较低.">
    常量 快速释放 <公开 值 = @MH_FREEZE_METHOD_FAST_UNDOCUMENTED 注释 = "  使用NtGetNextThread,速度更快且可靠性更高,但没有文档."
            注释 = "支持Windows Vista之后的系统,旧系统会自动回退到原始方法.">
    常量 不作释放 <公开 值 = @MH_FREEZE_METHOD_NONE_UNSAFE 注释 = "  不挂起线程也不调整指令指针寄存器.除非你了解它的含义并"
            注释 = "确定它是安全的,否则不要使用本方法.">
}

类 HOOK信息类 <公开 注释 = "为了方便用户使用而定义的一个类型." 注释 = "用来记录HOOK的相关信息,比如函数地址和多重钩子ID." 折叠
        @文档 = "category = \"HOOK.辅助类\"">
{
    变量 ID <公开 类型 = 变整数 注释 = "多重钩子ID">
    变量 钩子 <公开 类型 = 变整数 注释 = "钩子函数地址">
    变量 跳板 <公开 类型 = 变整数 注释 = "跳板函数地址">
    变量 目标 <公开 类型 = 变整数 注释 = "目标函数地址">
}

类 HOOK信息数组类 <公开 基础类 = 对象数组模板类 注释 = "\"HOOK信息类\"的数组" @文档 = "category = \"HOOK.辅助类\"" @模板实现类 = "HOOK信息类">

# ===

类 窗口操作类 <公开 注释 = "通过窗口句柄操作Win32窗口" 折叠 @文档 = "category = \"系统操作\"">
{
    方法 取窗口类名 <公开 静态 类型 = 文本型 注释 = "获取指定窗口句柄的窗口类名" 折叠 @禁止流程检查 = 真>
    参数 窗口句柄 <类型 = 变整数>
    {
        @ wchar_t ClassName[257] = {0};
        @ int len = ::GetClassNameW((HWND)@<窗口句柄>, &ClassName, 257);
        @ if (len)
        @     return CVolString(ClassName, len);
        @ else
        @     return _CT("");
    }

    方法 寻找窗口句柄 <公开 静态 类型 = 变整数 注释 = "寻找与指定窗口类名和窗口标题匹配的顶级窗口的句柄" 折叠 @嵌入式方法 = "">
    参数 窗口类名 <类型 = 文本型 注释 = "提供所欲寻找的窗口类名,不区分大小写,空文本表示匹配所有类名." @默认值 = 空对象>
    参数 窗口标题 <类型 = 文本型 注释 = "提供所欲寻找的窗口标题,不区分大小写,空文本表示匹配所有标题." @默认值 = 空对象>
    {
        @ (INT_P)::FindWindowW (PIV_GET_TEXT(@<窗口类名>), PIV_GET_TEXT(@<窗口标题>))
    }

    方法 调用窗口过程 <公开 静态 类型 = 变整数 注释 = "将消息信息传递到指定的窗口过程" 返回值注释 = "返回消息的处理结果" 折叠 @嵌入式方法 = "">
    参数 上个窗口过程 <类型 = 变整数 注释 = "上一个窗口过程的指针">
    参数 窗口句柄 <类型 = 变整数 注释 = "接收消息的窗口句柄">
    参数 信息值 <类型 = 整数>
    参数 参数1 <类型 = 变整数>
    参数 参数2 <类型 = 变整数>
    {
        @ (INT_P)::CallWindowProcW ((WNDPROC)@<上个窗口过程>, (HWND)@<窗口句柄>, (UINT)@<信息值>, (WPARAM)@<参数1>, (LPARAM)@<参数2>)
    }

    方法 置窗口属性值 <公开 静态 类型 = 变整数 注释 = "修改指定窗口的属性值,并返回之前的属性值." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 属性索引 <类型 = 整数>
    参数 新属性值 <类型 = 变整数>
    {
        @ (INT_P)::SetWindowLongPtrW ((HWND)@<窗口句柄>, @<属性索引>, (LONG_PTR)@<新属性值>)
    }

    方法 取窗口属性值 <公开 静态 类型 = 变整数 注释 = "获取指定窗口的属性值" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 属性索引 <类型 = 整数>
    {
        @ (INT_P)::GetWindowLongPtrW ((HWND)@<窗口句柄>, @<属性索引>)
    }

    方法 发送信息 <公开 静态 类型 = 变整数 注释 = "将指定信息发送到指定的窗口中,并等待且取回信息反馈值." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 信息值 <类型 = 整数>
    参数 参数1 <类型 = 变整数>
    参数 参数2 <类型 = 变整数>
    {
        @ (INT_P)::SendMessage((HWND)@<窗口句柄>, (UINT)@<信息值>, (WPARAM)@<参数1>, (LPARAM)@<参数2>)
    }

    方法 投递信息 <公开 静态 类型 = 逻辑型 注释 = "将指定信息发送到指定的窗口中,不等待直接返回." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 信息值 <类型 = 整数>
    参数 参数1 <类型 = 变整数>
    参数 参数2 <类型 = 变整数>
    {
        @ ::PostMessage((HWND)@<窗口句柄>, (UINT)@<信息值>, (WPARAM)@<参数1>, (LPARAM)@<参数2>)
    }

    方法 加载图标文件 <公开 静态 类型 = 逻辑型 注释 = "从文件加载图标并设置到窗口标题" 折叠 @禁止流程检查 = 真>
    参数 主窗口句柄 <类型 = 变整数>
    参数 图标文件 <类型 = 文本型>
    {
        @ HANDLE hIcon = ::LoadImageW(NULL, @<图标文件>.GetText(), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);
        @ if (hIcon) {
        @     ::SendMessage((HWND)@<主窗口句柄>, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        @     ::SendMessage((HWND)@<主窗口句柄>, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        @     return TRUE;
        @ }
        @ return FALSE;

    }

    方法 加载图标对象 <公开 静态 类型 = 逻辑型 注释 = "从图标对象类加载图标到窗口中" 折叠 @禁止流程检查 = 真>
    参数 主窗口句柄 <类型 = 变整数>
    参数 所欲设置的图标 <类型 = 图标对象类>
    {
        @ HICON hIcon = (HICON)@<所欲设置的图标>.GetGDIHandle();
        @ if (hIcon) {
        @     ::SendMessage((HWND)@<主窗口句柄>, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        @     ::SendMessage((HWND)@<主窗口句柄>, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        @     return TRUE;
        @ }
        @ return FALSE;

    }
}

类 菜单操作类 <公开 注释 = "通过菜单句柄操作Win32菜单" 折叠 @文档 = "category = \"系统操作\"">
{
    方法 创建菜单 <公开 静态 类型 = 变整数 注释 = "创建一个顶级菜单栏" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)::CreateMenu ()
    }

    方法 创建弹出菜单 <公开 静态 类型 = 变整数 注释 = "创建一个弹出式菜单" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)::CreatePopupMenu()
    }

    方法 置窗口菜单 <公开 静态 类型 = 逻辑型 注释 = "分配一个新菜单到指定的窗口中,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 菜单句柄 <类型 = 变整数 注释 = "提供0表示删除当前的菜单">
    {
        @ ::SetMenu ((HWND)@<窗口句柄>, @<菜单句柄>)
    }

    方法 取窗口菜单 <公开 静态 类型 = 变整数 注释 = "返回指定窗口已分配的菜单栏句柄" 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    {
        @ (INT_P)::GetMenu ((HWND)@<窗口句柄>)
    }

    方法 取菜单项数量 <公开 静态 类型 = 整数 注释 = "返回指定菜单的菜单项数量,失败返回-1." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数>
    {
        @ ::GetMenuItemCount ((HMENU)@<菜单句柄>)
    }

    方法 取菜单项ID <公开 静态 类型 = 整数 注释 = "返回指定菜单项的ID,失败返回-1." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数>
    参数 索引位置 <类型 = 整数 注释 = "菜单项的从零开始的相对位置">
    {
        @ (INT)::GetMenuItemID ((HMENU)@<菜单句柄>, @<索引位置>)
    }

    方法 取子菜单句柄 <公开 静态 类型 = 变整数 注释 = "返回由指定菜单项激活的下拉菜单或子菜单的句柄." 注释 = "返回0表示指定的菜单项不会激活下拉菜单或子菜单." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数>
    参数 索引位置 <类型 = 整数 注释 = "菜单项的从零开始的相对位置">
    {
        @ (INT_P)::GetSubMenu ((HMENU)@<菜单句柄>, @<索引位置>)
    }

    方法 销毁菜单 <公开 静态 类型 = 逻辑型 注释 = "销毁指定的菜单,返回是否成功." 注释 = "关闭程序之前必须销毁未分配给窗口的菜单(已分配的不用手动销毁)."
            注释 = "该命令会递归删除菜单及其所有子菜单." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数>
    {
        @ ::DestroyMenu ((HMENU)@<菜单句柄>)
    }

    方法 重画菜单 <公开 静态 类型 = 逻辑型 注释 = "重绘指定窗口的菜单栏,返回是否成功." 注释 = "如果在系统创建窗口后菜单栏发生更改,则必须调用此函数来绘制更改的菜单栏." 折叠
            @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    {
        @ ::DrawMenuBar ((HWND)@<窗口句柄>)
    }

    方法 插入菜单项 <公开 类型 = 逻辑型 注释 = "插入一个新的菜单项目,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 插入位置 <类型 = 整数 注释 = "新菜单项会插入到该位置后面,根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    参数 菜单项信息 <类型 = 菜单项信息类 注释 = "所欲插入菜单项的信息属性">
    {
        @ ::InsertMenuItemW ((HMENU)@<菜单句柄>, (UINT)@<插入位置>, @<是否为位置>, @<菜单项信息>.pdata())
    }

    方法 加入菜单项 <公开 静态 类型 = 逻辑型 注释 = "在菜单尾部加入一个菜单项,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 标志 <类型 = 整数 注释 = "请参考\"菜单项标志\"中的常量">
    参数 菜单项ID <类型 = 变整数>
    参数 菜单项标题 <类型 = 文本型 @默认值 = 空对象>
    {
        @ ::AppendMenuW((HMENU)@<菜单句柄>, (UINT)@<标志>, (UINT_PTR)@<菜单项ID>, @<菜单项标题>.GetText())
    }

    方法 删除菜单项 <公开 静态 类型 = 逻辑型 注释 = "删除所指定的菜单项,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::DeleteMenu ((HMENU)@<菜单句柄>, (UINT)@<菜单项>, @<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND)
    }

    方法 移除菜单项 <公开 静态 类型 = 逻辑型 注释 = "删除所指定的菜单项,返回是否成功."
            注释 = "跟\"删除菜单项\"不同,如果菜单项可以打开下拉菜单或子菜单,则本命令不会销毁菜单,从而允许重复使用菜单." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::RemoveMenu ((HMENU)@<菜单句柄>, (UINT)@<菜单项>, @<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND)
    }

    方法 选中菜单项 <公开 静态 类型 = 整数 注释 = "设置或取消所指定ID菜单项目的选中状态,返回先前的选中状态."
            返回值注释 = "返回值大于0表示之前为选中状态,0表示之前未选中,指定的菜单项不存在返回-1." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否选中 <类型 = 逻辑型 注释 = "是否选中指定的菜单项">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::CheckMenuItem ((HMENU)@<菜单句柄>, (UINT)@<菜单项>, (@<是否选中> ? MF_CHECKED : MF_UNCHECKED) | (@<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND))
    }

    方法 选中单选菜单项 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 首菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 尾菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 选中菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::CheckMenuRadioItem ((HMENU)@<菜单句柄>, (UINT)@<首菜单项>, (UINT)@<尾菜单项>, (UINT)@<选中菜单项>, @<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND)
    }

    方法 高亮菜单项 <公开 静态 类型 = 逻辑型 注释 = "设置或取消所指定ID菜单项目的突出显示状态." 折叠 @嵌入式方法 = "">
    参数 窗口句柄 <类型 = 变整数>
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否高亮 <类型 = 逻辑型 注释 = "是否突出显示指定的菜单项">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::HiliteMenuItem ((HWND)@<窗口句柄>, (HMENU)@<菜单句柄>, (UINT)@<菜单项>, (@<是否高亮> ? MF_HILITE : MF_UNHILITE) | (@<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND))
    }

    方法 置默认菜单项 <公开 静态 类型 = 逻辑型 注释 = "设置指定菜单的默认菜单项" 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::SetMenuDefaultItem ((HMENU)@<菜单句柄>, (UINT)@<菜单项>, (UINT)@<是否为位置>)
    }

    方法 取默认菜单项 <公开 静态 类型 = 整数 注释 = "获取指定菜单上的默认菜单项" 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    参数 递归子菜单 <类型 = 逻辑型 注释 = "如果默认菜单项是子菜单,是否递归搜索所有的子菜单." @默认值 = 假>
    {
        @ (INT)::GetMenuDefaultItem ((HMENU)@<菜单句柄>, (UINT)@<是否为位置>, @<递归子菜单> ? GMDI_GOINTOPOPUPS : 0)
    }

    方法 允许菜单项 <公开 静态 类型 = 整数 注释 = "设置或取消所指定ID菜单项的操作允许状态,返回是否成功." 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 允许状态 <类型 = 整数 注释 = "0=启用; 1=禁用并灰显; 2=禁用">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ ::EnableMenuItem ((HMENU)@<菜单句柄>, (UINT)@<菜单项>, (UINT)(@<允许状态> | (@<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND)))
    }

    方法 是否被选中 <公开 类型 = 逻辑型 注释 = "返回所指定的菜单项是否处于被选中状态,如果所指定菜单项不存在,将始终返回假." 折叠>
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        返回 (位与 (取菜单项状态 (菜单句柄, 菜单项, 是否为位置), 菜单项标志.选中) == 菜单项标志.选中)
    }

    方法 是否被允许 <公开 类型 = 逻辑型 注释 = "返回所指定ID菜单项是否处于被允许操作状态,如果所指定菜单项不存在,将始终返回假." 折叠 @禁止流程检查 = 真>
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        返回 (位与 (取菜单项状态 (菜单句柄, 菜单项, 是否为位置), 位或 (菜单项标志.禁用, 菜单项标志.灰色)) != 0)
    }

    方法 取菜单项状态 <公开 静态 类型 = 整数 注释 = "返回值为\"菜单项标志\"的一或多个常量的位或值" 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    {
        @ (INT)::GetMenuState ((HMENU)@<菜单句柄>, (UINT)@<菜单项>, @<是否为位置> ? MF_BYPOSITION : MF_BYCOMMAND)
    }

    方法 取菜单项信息 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    参数 菜单项信息 <类型 = 菜单项信息类 注释 = "返回菜单项信息">
    {
        @ ::GetMenuItemInfoW ((HMENU)@<菜单句柄>, (UINT)@<菜单项>, @<是否为位置>, @<菜单项信息>.pdata())
    }

    方法 置菜单项信息 <公开 静态 类型 = 逻辑型 注释 = "If the specified item does not exist, the return value is -1."
            注释 = "If the menu item opens a submenu, the low-order byte of the return value contains the menu flags associated with the item, and the high-order byte contains the number of items in the submenu opened by the it"
            折叠 @嵌入式方法 = "">
    参数 菜单句柄 <类型 = 变整数 注释 = "所欲操作的菜单">
    参数 菜单项 <类型 = 整数 注释 = "根据\"是否为位置\"决定指定菜单项ID,还是相对位置.">
    参数 是否为位置 <类型 = 逻辑型 注释 = "为真时,参数\"菜单项\"为从0开始的菜单项相对位置,否则为菜单项ID." @默认值 = 假>
    参数 菜单项信息 <类型 = 菜单项信息类 注释 = "所欲设置的菜单项信息">
    {
        @ ::SetMenuItemInfoW ((HMENU)@<菜单句柄>, (UINT)@<菜单项>, @<是否为位置>, @<菜单项信息>.pdata())
    }
}

类 菜单项标志 <公开 折叠 @文档 = "category = \"系统操作.辅助类\"">
{
    常量 选中 <公开 类型 = 整数 值 = @MF_CHECKED 注释 = "选中复选框(仅适用于下拉菜单、子菜单和快捷菜单)">
    常量 禁用 <公开 类型 = 整数 值 = @MF_DISABLED 注释 = "菜单项已被禁用">
    常量 灰色 <公开 类型 = 整数 值 = @MF_GRAYED 注释 = "菜单项被禁用且显示成灰色">
    常量 高亮 <公开 类型 = 整数 值 = @MF_HILITE 注释 = "菜单项被突出显示">
    常量 "" <公开 类型 = 整数 值 = @MF_MENUBARBREAK>
    常量 "" <公开 类型 = 整数 值 = @MF_MENUBREAK>
    常量 所有者绘制 <公开 类型 = 整数 值 = @MF_OWNERDRAW>
    常量 子菜单 <公开 类型 = 整数 值 = @MF_POPUP 注释 = "菜单项是一个子菜单">
    常量 分隔线 <公开 类型 = 整数 值 = @MF_SEPARATOR 注释 = "有一条水平分界线(仅适用于下拉菜单、子菜单和快捷菜单)">
    常量 启用 <公开 类型 = 整数 值 = @MF_ENABLED 注释 = "菜单项可用,由于值为0,需要使用表达式测试: !(Flag&(MF_DISABLED | MF_GRAYED))">
    常量 文本菜单项 <公开 类型 = 整数 值 = @MF_STRING 注释 = "菜单项标题文本. 由于值为0,需要使用表达式测试: !(Flag&(MF_BITMAP | MF_OWNERDRAW))">
    常量 未选中 <公开 类型 = 整数 值 = @MF_UNCHECKED 注释 = "未选中复选框. 由于值为0,需要使用表达式测试: !(Flag&MF_CHECKED)">
    常量 未高亮 <公开 类型 = 整数 值 = @MF_UNHILITE 注释 = "菜单项未突出显示. 由于值为0,需要使用表达式测试: !(Flag&HILITE)">
}

类 菜单项状态 <公开 折叠 @文档 = "category = \"系统操作.辅助类\"">
{
    常量 选中菜单项 <公开 类型 = 整数 值 = @MFS_CHECKED 注释 = "选中复选框(仅适用于下拉菜单、子菜单和快捷菜单)">
    常量 默认菜单项 <公开 类型 = 整数 值 = @MFS_DEFAULT 注释 = "该菜单项为默认值,一个菜单只能有一个默认菜单项,以粗体突出显示.">
    常量 禁用菜单项 <公开 类型 = 整数 值 = @MFS_DISABLED 注释 = "菜单项已被禁用,并显示成灰色.">
    常量 启用菜单项 <公开 类型 = 整数 值 = @MFS_ENABLED 注释 = "启用菜单项,以便可以选择它,这是默认状态.">
    常量 灰色菜单项 <公开 类型 = 整数 值 = @MFS_GRAYED 注释 = "菜单项已被禁用,并显示成灰色.">
    常量 高亮菜单项 <公开 类型 = 整数 值 = @MFS_HILITE 注释 = "突出显示菜单项">
    常量 取消选中菜单项 <公开 类型 = 整数 值 = @MFS_UNCHECKED 注释 = "取消选中复选框">
    常量 未高亮菜单项 <公开 类型 = 整数 值 = @MFS_UNHILITE 注释 = "菜单项未突出显示,这是默认状态.">
}

类 菜单项信息类 <公开 基础类 = 结构基础类 注释 = "MENUITEMINFOW结构体" 折叠 @文档 = "category = \"系统操作.辅助类\"">
{

    # @ @m<DECLARE_STRUCT_CLASS> (MENUITEMINFOW)

    方法 类_初始化 <折叠>
    {
        结构尺寸 = 取结构尺寸 ()
    }

    方法 结构尺寸 <公开 属性读 类型 = 整数 注释 = "cbSize 返回结构尺寸" 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.pdata()->cbSize
    }

    方法 结构尺寸 <公开 属性写 注释 = "cbSize 设置结构尺寸(类初始化时已自动设置)" 折叠>
    参数 值 <类型 = 整数>
    {
        @ pdata()->cbSize = (UINT)@<值>;
    }

    方法 掩码 <公开 属性读 类型 = 整数 注释 = "fMask 指定获取或设置的成员,请参考常量\"\"" 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.pdata()->fMask
    }

    方法 掩码 <公开 属性写 注释 = "fMask 指定获取或设置的成员,请参考常量\"\"" 折叠>
    参数 值 <类型 = 整数>
    {
        @ pdata()->fMask = (UINT)@<值>;
    }

    方法 菜单项类型 <公开 属性读 类型 = 整数 注释 = "fType" 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.pdata()->fType
    }

    方法 菜单项类型 <公开 属性写 注释 = "fType" 折叠>
    参数 值 <类型 = 整数>
    {
        @ pdata()->fType = (UINT)@<值>;
    }

    方法 菜单项状态 <公开 属性读 类型 = 整数 注释 = "fState 请参考常量\"菜单项状态\"" 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.pdata()->fState
    }

    方法 菜单项状态 <公开 属性写 注释 = "fState 请参考常量\"菜单项状态\"" 折叠>
    参数 值 <类型 = 整数>
    {
        @ pdata()->fState = (UINT)@<值>;
    }

    方法 子菜单句柄 <公开 属性读 类型 = 变整数 注释 = "hSubMenu" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.pdata()->hSubMenu
    }

    方法 子菜单句柄 <公开 属性写 注释 = "hSubMenu" 折叠>
    参数 值 <类型 = 变整数>
    {
        @ pdata()->hSubMenu = (HMENU)@<值>;
    }

    方法 选中复选框位图 <公开 属性读 类型 = 变整数 注释 = "hbmpChecked" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.pdata()->hbmpChecked
    }

    方法 选中复选框位图 <公开 属性写 注释 = "hbmpChecked" 折叠>
    参数 值 <类型 = 变整数>
    {
        @ pdata()->hbmpChecked = (HBITMAP)@<值>;
    }

    方法 取消复选框位图 <公开 属性读 类型 = 变整数 注释 = "hbmpUnchecked" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.pdata()->hbmpUnchecked
    }

    方法 取消复选框位图 <公开 属性写 注释 = "hbmpUnchecked" 折叠>
    参数 值 <类型 = 变整数>
    {
        @ pdata()->hbmpUnchecked = (HBITMAP)@<值>;
    }

    方法 菜单项数据 <公开 属性读 类型 = 变整数 注释 = "dwItemData" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.pdata()->dwItemData
    }

    方法 菜单项数据 <公开 属性写 注释 = "dwItemData" 折叠>
    参数 值 <类型 = 变整数>
    {
        @ pdata()->dwItemData = (ULONG_PTR)@<值>;
    }

    方法 菜单项内容 <公开 属性读 类型 = 变整数 注释 = "dwTypeData 内容取决于\"菜单项类型\"的值" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.pdata()->dwTypeData
    }

    方法 菜单项内容 <公开 属性写 注释 = "dwTypeData 内容取决于\"菜单项类型\"的值" 折叠>
    参数 值 <类型 = 变整数>
    {
        @ pdata()->dwTypeData = (LPWSTR)@<值>;
    }

    方法 菜单项文本长度 <公开 属性读 类型 = 整数 注释 = "cch" 折叠 @嵌入式方法 = "">
    {
        @ (INT)@sn<this>.pdata()->cch
    }

    方法 菜单项文本长度 <公开 属性写 注释 = "cch" 折叠>
    参数 值 <类型 = 整数>
    {
        @ pdata()->cch = (UINT)@<值>;
    }

    方法 菜单项位图 <公开 属性读 类型 = 变整数 注释 = "hbmpItem" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.pdata()->hbmpItem
    }

    方法 菜单项位图 <公开 属性写 注释 = "hbmpItem" 折叠>
    参数 值 <类型 = 变整数>
    {
        @ pdata()->hbmpItem = (HBITMAP)@<值>;
    }
}

# 键鼠标模拟 API版 ===

类 发送输入类 <公开 折叠 @文档 = "category = \"系统操作.发送输入\"" @全局类 = 真>
{
    方法 发送鼠标输入 <公开 静态 类型 = 整数 返回值注释 = "成功返回插入的输入事件数,0为表示输入被另一个线程阻止了." @禁止流程检查 = 真>
    参数 输入数组 <类型 = 鼠标输入数组类>
    {
        @ return (INT)::SendInput ((UINT)@<输入数组.取成员数>(), (LPINPUT)@<输入数组.取数组指针>(), sizeof(INPUT));
    }

    方法 发送键盘输入 <公开 静态 类型 = 整数 返回值注释 = "成功返回插入的输入事件数,0为表示输入被另一个线程阻止了." @禁止流程检查 = 真>
    参数 输入数组 <类型 = 键盘输入数组类>
    {
        @ return (INT)::SendInput ((UINT)@<输入数组.取成员数>(), (LPINPUT)@<输入数组.取数组指针>(), sizeof(INPUT));
    }

    方法 发送硬件输入 <公开 静态 类型 = 整数 返回值注释 = "成功返回插入的输入事件数,0为表示输入被另一个线程阻止了." @禁止流程检查 = 真>
    参数 输入数组 <类型 = 硬件输入数组类>
    {
        @ return (INT)::SendInput ((UINT)@<输入数组.取成员数>(), (LPINPUT)@<输入数组.取数组指针>(), sizeof(INPUT));
    }
}

类 鼠标输入类 <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 type <公开 类型 = 整数 值 = 0 注释 = "固定为0=INPUT_MOUSE">
    变量 mi <公开 类型 = MOUSEINPUT>
}

类 MOUSEINPUT <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 dx <公开 类型 = 整数 注释 = "鼠标x坐标">
    变量 dy <公开 类型 = 整数 注释 = "鼠标y坐标">
    变量 mouseData <公开 类型 = 整数 注释 = "按dwFlags的备注填写">
    变量 dwFlags <公开 类型 = 整数 注释 = "可使用\"鼠标事件常量类\"的位或组合值.">
    变量 time <公开 类型 = 整数 注释 = "事件的时间戳,以毫秒为单位.如果此参数为0,系统将提供自己的时间戳.">
    变量 dwExtraInfo <公开 类型 = 变整数 注释 = "与鼠标事件关联的附加值.应用程序调用GetMessageExtraInfo可获取此额外信息.">
}

类 鼠标输入数组类 <公开 基础类 = 结构数组模板类 @文档 = "category = \"系统操作.发送输入.辅助类\"" @模板实现类 = "鼠标输入类">

类 鼠标事件常量类 <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"">
{
    常量 鼠标移动 <公开 类型 = 整数 值 = @MOUSEEVENTF_MOVE>
    常量 按下左键 <公开 类型 = 整数 值 = @MOUSEEVENTF_LEFTDOWN>
    常量 释放左键 <公开 类型 = 整数 值 = @MOUSEEVENTF_LEFTUP>
    常量 按下右键 <公开 类型 = 整数 值 = @MOUSEEVENTF_RIGHTDOWN>
    常量 释放右键 <公开 类型 = 整数 值 = @MOUSEEVENTF_RIGHTUP>
    常量 按下中键 <公开 类型 = 整数 值 = @MOUSEEVENTF_MIDDLEDOWN>
    常量 释放中键 <公开 类型 = 整数 值 = @MOUSEEVENTF_MIDDLEUP>
    常量 按下X键 <公开 类型 = 整数 值 = @MOUSEEVENTF_XDOWN 注释 = "mouseData的值1为按下第一个X键,2为按下第二个X键">
    常量 释放X键 <公开 类型 = 整数 值 = @MOUSEEVENTF_XUP 注释 = "mouseData的值1为释放第一个X键,2为释放第二个X键">
    常量 鼠标滚轮 <公开 类型 = 整数 值 = @MOUSEEVENTF_WHEEL 注释 = "mouseData的值为滚轮的垂直移动量">
    常量 水平滚轮 <公开 类型 = 整数 值 = 0x1000 注释 = "mouseData的值为滚轮的水平移动量">
    常量 不合并消息 <公开 类型 = 整数 值 = 0x2000 注释 = "WM_MOUSEMOVE消息将不会合并,默认是合并WM_MOUSEMOVE消息.">
    常量 虚拟桌面 <公开 类型 = 整数 值 = @MOUSEEVENTF_VIRTUALDESK 注释 = "将坐标映射到整个桌面,必须与\"绝对坐标\"配合使用。">
    常量 绝对坐标 <公开 类型 = 整数 值 = @MOUSEEVENTF_ABSOLUTE 注释 = "dx和dy使用绝对坐标值,否则为相对坐标.">
}

类 键盘输入类 <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 type <公开 类型 = 整数 值 = 1 注释 = "固定为1=INPUT_KEYBOARD">
    变量 ki <公开 类型 = KEYBDINPUT>
}

类 KEYBDINPUT <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 wVk <公开 类型 = 短整数 注释 = "虚拟按键代码,范围为1-254." 注释 = "如果dwFlags为KEYEVENTF_UNICODE,本成员必须为0.">
    变量 wScan <公开 类型 = 短整数 注释 = "按键的硬件扫描代码." 注释 = "如果dwFlags为KEYEVENTF_UNICODE,则本在成员指定发送到前台应用的UNICODE字符.">
    变量 dwFlags <公开 类型 = 整数 注释 = "为以下整数的位或组合值." 注释 = "1=KEYEVENTF_EXTENDEDKEY,扫描代码前面会有一个值为0xE0(224)的前缀字节."
            注释 = "2=KEYEVENTF_KEYUP,指定本值为释放按键,未指定本值为按下按键." 注释 = "8=KEYEVENTF_SCANCODE,指定本值后将忽略wVk,使用wScan识别按键."
            注释 = "4=KEYEVENTF_UNICODE,系统将合成VK_PACKET按键,wVk的值必须为0,本值只能与KEYEVENTF_KEYUP组合使用.">
    变量 time <公开 类型 = 整数 注释 = "事件的时间戳,以毫秒为单位.如果此参数为0,系统将提供自己的时间戳.">
    变量 dwExtraInfo <公开 类型 = 变整数 注释 = "与鼠标事件关联的附加值.应用程序调用GetMessageExtraInfo可获取此额外信息.">
}

类 键盘输入数组类 <公开 基础类 = 结构数组模板类 @文档 = "category = \"系统操作.发送输入.辅助类\"" @模板实现类 = "键盘输入类">

类 硬件输入类 <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 type <公开 类型 = 整数 值 = 2 注释 = "固定为2=INPUT_HARDWARE">
    变量 hi <公开 类型 = HARDWAREINPUT>
}

类 HARDWAREINPUT <公开 折叠 @文档 = "category = \"系统操作.发送输入.辅助类\"" @视窗.结构类 = 0>
{
    变量 uMsg <公开 类型 = 整数 注释 = "此消息由输入硬件生成.">
    变量 wParamL <公开 类型 = 短整数 注释 = "uMsg的LPRAM参数的低位值.">
    变量 wParamH <公开 类型 = 短整数 注释 = "uMsg的LPRAM参数的高位值.">
}

类 硬件输入数组类 <公开 基础类 = 结构数组模板类 @文档 = "category = \"系统操作.发送输入.辅助类\"" @模板实现类 = "硬件输入类">

#
