<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" "@视窗.外部头文件.全局-100" = "<chrono>">

# 推荐 ===

类 线程池对象类 <公开 注释 = "现代C++的线程池." 注释 = "  1. 使用高效的ICOP异步模型,队列式执行线程任务;"
        注释 = "  2. 使用C++11的std::thread线程库,功能更强大;" 注释 = "  3. 支持投递任意参数格式的线程函数;"
        注释 = "  4. 支持投递类的动态方法,无需通过\"接收事件\"调用类的动态成员;" 注释 = "  5. 退出程序时线程对象会被强制结束,不会窗口关掉了还在跑;" 折叠
        @文档 = "category = \"多线程\"" @视窗.外部头文件 = "src\\piv_threadpool.hpp" @视窗.后缀文本 = "public PivThreadPoolPro">
{
    方法 创建 <公开 类型 = 逻辑型 注释 = "创建线程池,必须成功创建后才能使用其他方法." 返回值注释 = "返回是否创建成功,重复创建亦返回真." 折叠 @嵌入式方法 = "">
    参数 线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU逻辑核心数 + 1)."
            注释 = "  - I/O密集型建议: CPU核数 * (1 + (I/O耗时 / CPU耗时))" 注释 = "  - 计算密集型建议: CPU核数 + 1" @默认值 = 0>
    {
        @ @sn<this>.CreateThreadPool (@<线程数量>)
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "  销毁线程池,释放线程池占用的所有资源." 注释 = "  注意: 销毁线程池不会强制结束仍在运行的线程,请在线程的耗时或"
            注释 = "死循环中调用本对象的方法\"是否需要退出\",一旦发现该方法返回真," 注释 = "必须尽快结束\"任务回调\"/\"对象任务回调\"事件的执行."
            注释 = "  类清理时会自动销毁,如果线程池实例定义在窗口的成员变量中,必须" 注释 = "在窗口即将销毁时执行销毁线程池." 返回值注释 = "成功或已经销毁返回真,失败返回假."
            返回值注释 = "失败原因包括: 线程池正在创建或正在销毁." 折叠 @嵌入式方法 = "">
    参数 是否强制销毁 <类型 = 逻辑型 注释 = "假=正常销毁,等待任务执行完毕后返回;" 注释 = "真=强制销毁,不等待执行中的任务,清空后续的队列任务后立即返回." @默认值 = 假>
    参数 最长等待时间 <类型 = 整数 注释 = "此参数只对非强制销毁有效,单位为毫秒;" 注释 = "-1为一直等待所有任务完成,否则到了超时时间会清空任务并返回." @默认值 = -1>
    {
        @ @sn<this>.DestroyThreadPool (@<是否强制销毁>, @<最长等待时间>)
    }

    方法 暂停 <公开 类型 = 逻辑型 注释 = "停止执行新的任务,当前正在执行的任务不会被暂停." 返回值注释 = "返回是否暂停成功,线程池的不在工作状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SuspendThreadPool ()
    }

    方法 继续 <公开 类型 = 逻辑型 注释 = "继续执行线程池任务" 返回值注释 = "返回是否继续成功,线程池的不在暂停状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ResumeThreadPool ()
    }

    方法 投递静态方法 <公开 类型 = 逻辑型 注释 = "将静态方法投递到线程池中,线程池将按投递顺序执行任务."
            注释 = "  1. 可以投递任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;"
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制,如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @sn<this>.PostTask (&@<静态方法>, @<参数列表>)
    }

    方法 投递动态方法 <公开 类型 = 逻辑型 注释 = "将类实例的动态方法投递到线程池中,线程池将按投递顺序执行任务."
            注释 = "  1. 可以投递任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;"
            注释 = "  5. 如果关联的对象实例被销毁,线程将异常结束(不影响线程池的运作);" 注释 = "  6. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;"
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供动态方法所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数表的格式务必和类成员方法的参数表一致;" 注释 = "默认将提交的参数按值复制,如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @sn<this>.PostTask (&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>)
    }

    方法 投递无参数静态方法 <公开 类型 = 逻辑型 注释 = "将无参数的静态方法投递到线程池中,线程池将按投递顺序执行任务." 注释 = "  1. 只能投递关联无参数的静态方法;"
            注释 = "  2. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠
            @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    {
        @ @sn<this>.PostTask (&@<静态方法>)
    }

    方法 投递无参数动态方法 <公开 类型 = 逻辑型 注释 = "将无参数的类动态方法投递到线程池中,线程池将按投递顺序执行任务." 注释 = "  1. 只能投递关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 如果关联的对象实例被销毁,线程将异常结束(不影响线程池的运作);"
            注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠
            @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供动态方法所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ @sn<this>.PostTask (&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>)
    }

    方法 投递任务 <公开 类型 = 逻辑型 注释 = "将函数对象投递到线程池中,线程池将按投递顺序执行任务." 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠
            @嵌入式方法 = "">
    参数 函数对象 <类型 = 函数对象类 注释 = "所欲投递到线程池执行的函数对象,可以调用下列方法创建:" 注释 = "- 绑定静态方法   绑定无参数静态方法"
            注释 = "- 绑定动态方法   绑定无参数动态方法" 注释 = "- 绑定函数指针   绑定无参数函数指针" 注释 = "- 绑定函数指针2  绑定无参数函数指针2">
    {
        @ @sn<this>.PostTask2 (@<函数对象>)
    }

    方法 清空任务 <公开 类型 = 逻辑型 注释 = "清空已投递的队列任务,将队列任务占用的内存释放." 返回值注释 = "返回是否开始清空任务,线程池不在正常工作和暂停状态时始终返回假." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ClearTask ()
    }

    方法 是否需要退出 <公开 类型 = 逻辑型 注释 = "检查线程任务是否需要尽快退出." 注释 = "  1. 本方法返回真则表示正在销毁线程池,必须尽快结束线程任务;"
            注释 = "  2. 如果未退出死循环中的线程,则线程池资源不会得到释放,线程" 注释 = "也会一直运行下去,直到进程结束;" 折叠 @嵌入式方法 = "">
    参数 最大检查等待时间 <类型 = 整数 注释 = "指定检查线程池销毁通知(由\"销毁\"方法发出)的最大等待时间," 注释 = "单位为毫秒,为0表示不等待,为-1表示一直等待." @默认值 = 0>
    {
        @ @sn<this>.IsNeedExit (@<最大检查等待时间>)
    }

    方法 调整线程池 <公开 类型 = 逻辑型 注释 = "调整线程池的容量(同时工作线程数量)." 注释 = "若新线程数量比原来大,会立即改变工作线程数量;"
            注释 = "若新线程数量比原来小,则需要等之前投递的任务全部完成,才会改变工作线程数量;" 返回值注释 = "返回是否成功调整线程池容量,线程池未创建、正在销毁或正在调整线程池时返回假." 折叠
            @嵌入式方法 = "">
    参数 新线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU核心数 + 1)." @默认值 = 0>
    {
        @ @sn<this>.SetThreadPoolCapacity (@<新线程数量>)
    }

    方法 CPU核心数 <公开 属性读 类型 = 整数 注释 = "获取CPU的逻辑核心数量(如支持超线程的16核CPU,返回32)." 返回值注释 = "成功返回CPU逻辑核心数,失败时始终返回1." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetProcessorsCount ()
    }

    方法 现行线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池当前的工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCount ()
    }

    方法 线程池容量 <公开 属性读 类型 = 整数 注释 = "获取线程池的最大工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCapacity ()
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取正在执行的任务数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWorkerTaskCount ()
    }

    方法 队列任务数 <公开 属性读 类型 = 长整数 注释 = "获取等待处理的任务数量,超过长整数最大值后将从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetQueueTaskCount ()
    }

    方法 已完成任务数 <公开 属性读 类型 = 长整数 注释 = "获取已完成的任务数量,超过长整数最大值后将从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetComplateTaskCount ()
    }

    方法 空闲线程数 <公开 属性读 类型 = 整数 注释 = "获取空闲的线程数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetFreeThreadsCount ()
    }

    方法 工作状态 <公开 属性读 类型 = 整数 注释 = "获取线程池的工作状态" 返回值注释 = "0=未启动;1=正在销毁;2=正在创建;3=正在工作;4=调整线程池;5=暂停中;6=正在清空任务"
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadPoolState ()
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "判断线程池是否处于彻底空闲状态,没有任何任务在执行." 返回值注释 = "真为空闲,假为繁忙,线程池未创建也返回真." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadPoolIsFree ()
    }
}

类 线程对象类 <公开 注释 = "线程对象(std::thread)的封装类." 注释 = "  1. 线程对象不可复制赋值;"
        注释 = "  2. 退出程序时线程对象会被强制结束,不会窗口关掉了还在跑;" 折叠 @文档 = "category = \"多线程\"" @视窗.外部头文件 = "<thread>" @全局类 = 真>
{

    # 全局静态方法 (无需创建类变量,直接调用) ------

    方法 启动静态线程 <公开 静态 注释 = "创建一个与静态方法关联的线程对象,然后立即分离并非阻塞执行线程函数."
            注释 = "  1. 可以关联任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 折叠
            @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ std::thread(&@<静态方法>, @<参数列表>).detach()
    }

    方法 启动无参数静态线程 <公开 静态 注释 = "创建一个与静态方法关联的线程对象,然后立即分离并非阻塞执行线程函数." 注释 = "  1. 只能关联无参数的静态方法;"
            注释 = "  2. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    {
        @ std::thread(&@<静态方法>).detach()
    }

    方法 启动动态线程 <公开 静态 注释 = "创建一个与类实例的动态方法关联的线程对象,然后立即分离并非阻塞执行线程函数."
            注释 = "  1. 可以关联任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;"
            注释 = "  5. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  6. 如果关联的对象实例被销毁,线程将异常结束(不影响整个进程的运作);" 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数列表的格式务必和所提供动态方法的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ std::thread(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>).detach()
    }

    方法 启动无参数动态线程 <公开 静态 注释 = "创建一个与类实例的动态方法关联的线程对象,然后立即分离并非阻塞执行线程函数." 注释 = "  1. 只能关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 如果关联的对象实例被销毁,线程将异常结束(不影响整个进程的运作);"
            注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ std::thread(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>).detach()
    }

    方法 引用 <公开 静态 注释 = "包装线程对象的参数,将它变成\"引用传递\"(std::ref)." 注释 = "  1. 线程对象默认按值复制参数,包装后线程参数和外部变量"
            注释 = "指向同一个数据,修改后结果互相同步;" 注释 = "  2. 请确保所包装变量的生命周期,不能在线程结束前被释放;" 折叠 @嵌入式方法 = "">
    参数 所欲包装参数 <@匹配类型 = 所有类型 @返回值类型 = 0>
    {
        @ std::ref(@<所欲包装参数>)
    }

    方法 常引用 <公开 静态 注释 = "包装线程对象的参数,将它变成\"常引用传递\"(std::cref)." 注释 = "  1. 线程对象默认按值复制参数,包装后线程参数和外部变量"
            注释 = "指向同一个数据,但线程内不能修改参数值;" 注释 = "  2. 请确保所包装变量的生命周期,不能在线程结束前被释放;"
            注释 = "  3. 火山的方法默认为引用传递,除非你知道如何修改参数的传递" 注释 = "方式,否则不应使用本方法;" 折叠 @嵌入式方法 = "">
    参数 所欲包装参数 <@匹配类型 = 所有类型 @返回值类型 = 0>
    {
        @ std::cref(@<所欲包装参数>)
    }

    方法 让出调度 <公开 静态 注释 = "使当前线程让渡出自己的CPU时间片,由运行态变为就绪态." 注释 = "当前线程什么时候再被调度运行,完全取决于系统的调度."
            注释 = "在低效的死循环中重复调用本方法,可以减少线程占用CPU资源." 折叠 @嵌入式方法 = "">
    {
        @ std::this_thread::yield()
    }

    # 类成员方法(需要创建类变量调用) ------
    # @begin
    # <> <include>
    # std::thread m_thread;
    # inline @sn<current_class> (std::thread& rhs) { m_thread.swap(rhs); }
    # inline @sn<current_class> (std::thread&& rhs) { if (m_thread.joinable()) { m_thread.detach(); } m_thread = std::move(rhs); }
    # inline @sn<current_class>& operator= (@sn<current_class>&& objCopyFrom) { m_thread = std::move(objCopyFrom.m_thread); return *this; }
    # inline void @an<_OnCleanupExtra> () { if (m_thread.joinable()) { m_thread.detach(); } }
    # inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return m_thread.get_id() == objCompare.m_thread.get_id(); }
    # <> </include>
    # @end

    方法 关联函数对象 <公开 注释 = "将本线程对象与函数对象关联,关联后会立即执行线程(有系统调度的延迟)." 注释 = "关联后需要调用\"分离/加入\",以释放线程资源;" 折叠
            @嵌入式方法 = "">
    参数 函数对象 <类型 = 函数对象类 注释 = "所欲关联的函数对象,可以调用下列方法创建:" 注释 = "- 绑定静态方法   绑定无参数静态方法"
            注释 = "- 绑定动态方法   绑定无参数动态方法" 注释 = "- 绑定函数指针   绑定无参数函数指针" 注释 = "- 绑定函数指针2  绑定无参数函数指针2">
    {
        @ [&](std::thread &td)->BOOL {
        @     if (td.joinable()) return FALSE;
        @     td = std::move(std::thread(@<函数对象>));
        @     return TRUE;
        @ } (@sn<this>.m_thread)
    }

    方法 关联静态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与静态方法关联,关联后会立即执行线程(有系统调度的延迟)."
            注释 = "  1. 可以关联任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 关联后需要调用\"分离/加入\",以释放线程资源;"
            返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ [&](std::thread &td)->BOOL {
        @     if (td.joinable()) return FALSE;
        @     td = std::move(std::thread(&@<静态方法>, @<参数列表>));
        @     return TRUE;
        @ } (@sn<this>.m_thread)
    }

    方法 关联动态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与类动态方法关联,关联后会立即执行线程(有系统调度的延迟)."
            注释 = "  1. 可以关联任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;"
            注释 = "  5. 关联后需要调用\"分离/加入\",以释放线程资源;" 返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数列表的格式务必和所提供动态方法的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ [&](std::thread &td)->BOOL {
        @     if (td.joinable()) return FALSE;
        @     td = std::move(std::thread(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>));
        @     return TRUE;
        @ } (@sn<this>.m_thread)
    }

    方法 关联无参数静态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与无参数的静态方法关联,关联后会立即执行线程(有系统调度的延迟)." 注释 = "  1. 只能关联无参数的静态方法;"
            注释 = "  2. 关联后需要调用\"分离/加入\",以释放线程资源;" 返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    {
        @ [&](std::thread &td)->BOOL {
        @     if (td.joinable()) return FALSE;
        @     td = std::move(std::thread(&@<静态方法>));
        @     return TRUE;
        @ } (@sn<this>.m_thread)
    }

    方法 关联无参数动态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与无参数的类动态方法关联,关联后会立即执行线程(有系统调度的延迟)." 注释 = "  1. 只能关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 关联后需要调用\"分离/加入\",以释放线程资源;"
            返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ [&](std::thread &td)->BOOL {
        @     if (td.joinable()) return FALSE;
        @     td = std::move(std::thread(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>));
        @     return TRUE;
        @ } (@sn<this>.m_thread)
    }

    方法 取线程句柄 <公开 类型 = 变整数 注释 = "返回线程对象内部的底层线程句柄,该句柄可以给\"等待多个事件\"或\"WaitForSingleObject\"使用." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.m_thread.native_handle()
    }

    方法 是否可加入 <公开 类型 = 逻辑型 注释 = "返回当前的线程对象是否可以加入到当前线程(有可执行的线程函数)." 返回值注释 = "返回假表示线程对象是空的" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.m_thread.joinable()
    }

    方法 加入 <公开 类型 = 逻辑型 注释 = "将线程对象加入到当前线程,会阻塞当前线程直到线程执行完毕." 注释 = "  1. 即使线程函数已实际执行完毕,仍需调用本方法;"
            注释 = "  2. 调用后线程对象将释放线程资源,变为空对象;" 返回值注释 = "线程对象为空时将直接返回假" 折叠 @禁止流程检查 = 真>
    {
        @ if (!m_thread.joinable()) return FALSE;
        @ m_thread.join();
        @ return TRUE;
    }

    方法 分离 <公开 类型 = 逻辑型 注释 = "将执行线程从线程对象中分离,成功后会立即返回真." 注释 = "  1. 分离后线程将独立执行,不再受线程对象管理;"
            注释 = "  2. 即使线程函数已实际执行完毕,仍需调用本方法;" 注释 = "  3. 调用后,线程对象将移交资源的所有权,变为空对象;" 返回值注释 = "线程对象为空时将直接返回假" 折叠
            @禁止流程检查 = 真>
    {
        @ if (!m_thread.joinable()) return FALSE;
        @ m_thread.detach();
        @ return TRUE;
    }

    方法 交换 <公开 注释 = "交换两个线程对象的执行线程" 折叠 @嵌入式方法 = "">
    参数 所欲交换的线程对象 <类型 = 线程对象类>
    {
        @ @sn<this>.m_thread.swap(@<所欲交换的线程对象>.m_thread)
    }

    方法 硬件并发数 <公开 属性读 类型 = 整数 注释 = "返回硬件和平台支持的最大并发线程数" 折叠 @嵌入式方法 = "">
    {
        @ (INT)std::thread::hardware_concurrency()
    }
}

类 互斥对象类 <公开 注释 = "互斥锁对象(std::mutex)的封装类." 注释 = "  1. 互斥对象不可复制赋值;" 注释 = "  2. 提供全局方法\"互斥自动锁\",可自动加锁/解锁;"
        折叠 @文档 = "category = \"多线程\"" @视窗.外部头文件 = "<mutex>" @全局类 = 真>
{
    方法 互斥自动锁 <公开 静态 注释 = "创建一个互斥自动锁对象(std::lock_guard),它将接收指定互斥锁的所有权."
            注释 = "创建后会立即在当前线程加锁,直到离开作用域后自动销毁对象并解锁." 注释 = "注: 本方法可以避免死锁,推荐用来替代互斥锁对象的\"加锁/解锁\"操作." 折叠 @嵌入式方法 = "">
    参数 所欲操作互斥锁 <类型 = 互斥对象类 注释 = "提供要在当前线程上锁的互斥锁对象(std::mutex)">
    {
        @ std::lock_guard<std::mutex> @sn<rand_name0>(@<所欲操作互斥锁>)
    }

    # @begin
    # <> <include>
    # std::mutex m_mutex;
    # inline operator std::mutex& () { return m_mutex; }
    # inline std::mutex& data() { return m_mutex; }
    # <> </include>
    # @end

    方法 加锁 <公开 注释 = "将本互斥锁加锁,如果本锁当前已经被另一线程锁住,则进入等待状态." 注释 = "注: 建议使用\"互斥自动锁\"以避免死锁." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().lock ()
    }

    方法 尝试加锁 <公开 类型 = 逻辑型 注释 = "尝试将本互斥锁加锁,如果能够成功加锁,则加锁后返回真." 注释 = "如果不能(譬如已经被其它线程锁住)则立即返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().try_lock()
    }

    方法 "// 限时尝试加锁" <公开 类型 = 逻辑型 注释 = "尝试将本互斥锁加锁,若能在指定时间内成功加锁返回真,否则返回假." 折叠 @嵌入式方法 = "">
    参数 延迟时间 <类型 = 长整数 注释 = "单位为毫秒">
    {
        @ @sn<this>.data().try_lock_for(std::chrono::milliseconds(@<延迟时间>))
    }

    方法 解锁 <公开 注释 = "如果先前加锁成功,解开此锁,以允许其它线程加锁成功." 注释 = "注: 建议使用\"互斥自动锁\"以避免死锁." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().unlock ()
    }

    方法 取互斥锁句柄 <公开 类型 = 变整数 注释 = "返回互斥锁的底层句柄" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.data().native_handle()
    }
}

类 唯一互斥锁类 <公开 注释 = "std::unique_lock<std::mutex>的封装类" 注释 = "跟\"互斥自动锁\"一样,本类比直接使用互斥对象类更安全,"
        注释 = "关联互斥对象后立即加速,并在析构时自动解锁;" 注释 = "跟\"互斥自动锁\"相比,本类还可以手动加锁和解锁;" 折叠 @文档 = "category = \"多线程\""
        @视窗.外部头文件 = "<mutex>">
{
    方法 关联互斥 <公开 注释 = "关联互斥对象,并锁定关联的互斥对象,如果关联互斥已经被另一线程锁住,则进入等待状态." 折叠 @嵌入式方法 = "">
    参数 所欲关联的锁 <类型 = 互斥对象类>
    {
        @ @sn<this>.data() = std::unique_lock<std::mutex>(@<所欲关联的锁>)
    }

    方法 加锁 <公开 注释 = "锁定关联的互斥对象,如果关联互斥已经被另一线程锁住,则进入等待状态." 折叠>
    {
        @ if (data()) data().lock()
    }

    方法 尝试加锁 <公开 类型 = 逻辑型 注释 = "尝试锁定关联的互斥对象,如果能够成功加锁,则加锁后返回真." 注释 = "如果不能(譬如已经被其它线程锁住)则立即返回假." 折叠
            @禁止流程检查 = 真>
    {
        @ return (data().owns_lock()) ? data().try_lock() : FALSE;
    }

    方法 "// 限时尝试加锁" <公开 类型 = 逻辑型 注释 = "尝试锁定关联的互斥对象,若能在指定时间内成功加锁返回真,否则返回假." 折叠 @禁止流程检查 = 真>
    参数 延迟时间 <类型 = 长整数 注释 = "单位为毫秒">
    {
        @ return (data().owns_lock()) ? data().try_lock_for(std::chrono::milliseconds(@<延迟时间>)) : FALSE;
    }

    方法 解锁 <公开 注释 = "解锁关联互斥对象并释放所有权,以允许其它线程加锁成功." 折叠>
    {
        @ if (data()) data().unlock()
    }

    方法 是否有效 <公开 类型 = 逻辑型 注释 = "检查本类是否占有锁定的互斥对象(即是否调用了\"关联互斥\")" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().owns_lock()
    }

    方法 释放 <公开 注释 = "解除与互斥对象的关联,本操作不会将互斥对象加锁或解锁." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().release()
    }

    # @begin
    # <> <include>
    # std::unique_lock<std::mutex> m_lk;
    # inline std::unique_lock<std::mutex>& data() { return m_lk; }
    # inline operator std::unique_lock<std::mutex>& () { return m_lk; }
    # <> </include>
    # @end
}

类 条件变量类 <公开 注释 = "能用于阻塞一个或多个线程,直至另一线程修改共享条件变量并通知." 折叠 @文档 = "category = \"多线程.辅助类\""
        @视窗.外部头文件 = "<condition_variable>">
{
    方法 通知一个 <公开 注释 = "通知一个等待中的线程解除阻塞,本方法不需要在互斥锁中使用." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().notify_one()
    }

    方法 通知所有 <公开 注释 = "通知所有等待中的线程解除阻塞,本方法不需要在互斥锁中使用." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().notify_all()
    }

    方法 等待 <公开 注释 = "阻塞当前线程,直到条件变量被唤醒;" 注释 = "注意: 本方法必须在\"唯一互斥锁类\"已加锁状态下使用;" 折叠 @嵌入式方法 = "">
    参数 互斥锁 <类型 = 唯一互斥锁类 注释 = "提供的\"唯一互斥锁类\"必须已\"关联互斥\"并处于加锁状态">
    {
        @ @sn<this>.data().wait(@<互斥锁>)
    }

    方法 限时等待 <公开 类型 = 逻辑型 注释 = "阻塞当前线程,直到条件变量被唤醒,或到达指定时长后解除阻塞." 注释 = "如果在延迟时间内条件变量被唤醒将返回真,否则返回假."
            注释 = "注意: 本方法必须在\"唯一互斥锁类\"已加锁状态下使用;" 折叠 @嵌入式方法 = "">
    参数 互斥锁 <类型 = 唯一互斥锁类 注释 = "提供的\"唯一互斥锁类\"必须已\"关联互斥\"并处于加锁状态">
    参数 延迟时间 <类型 = 长整数 注释 = "单位为毫秒">
    {
        @ (@sn<this>.data().wait_for(@<互斥锁>, std::chrono::milliseconds(@<延迟时间>)) == std::cv_status::no_timeout)
    }

    # @begin
    # <> <include>
    # std::condition_variable m_cv;
    # inline std::condition_variable& data() { return m_cv; }
    # <> </include>
    # @end
}

类 异步线程类 <公开 注释 = "异步对象(std::async)的封装类;" 注释 = "跟线程对象相比,可以延迟线程执行,以及通过\"未来对象\"获取异步线程的返回值." 折叠
        @文档 = "category = \"多线程\"" @视窗.外部头文件 = "<future>" @全局类 = 真>
{
    方法 启动异步对象 <公开 静态 注释 = "创建一个与函数对象关联的异步对象,然后立即分离并非阻塞执行线程函数." 折叠 @嵌入式方法 = "">
    参数 是否立即执行 <类型 = 逻辑型 注释 = "是否立即执行异步线程,为假将延迟执行,直到未来对象执行\"等待/取值\"才开始执行." @默认值 = 真>
    参数 未来值对象 <注释 = "必须为\"未来对象模板类\"的模板实现类,比如\"未来整数类\";" 注释 = "其中\"模板类型1\"必须跟\"静态方法\"的返回值类型一致;"
            注释 = "如果方法没有返回值,请使用\"未来空值类\";" @匹配类型 = 通用类>
    参数 函数对象 <类型 = 函数对象类 注释 = "所欲异步执行的函数对象,可以调用下列方法创建:" 注释 = "- 绑定静态方法   绑定无参数静态方法"
            注释 = "- 绑定动态方法   绑定无参数动态方法" 注释 = "- 绑定函数指针   绑定无参数函数指针" 注释 = "- 绑定函数指针2  绑定无参数函数指针2">
    {
        @ @<未来值对象> = std::async(@<是否立即执行> ? std::launch::async : (std::launch::async | std::launch::deferred), @<函数对象>)
    }

    方法 启动静态异步 <公开 静态 注释 = "创建一个与静态方法关联的异步对象,然后立即分离并非阻塞执行线程函数."
            注释 = "  1. 可以关联任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 折叠 @嵌入式方法 = "">
    参数 是否立即执行 <类型 = 逻辑型 注释 = "是否立即执行异步线程,为假将延迟执行,直到未来对象执行\"等待/取值\"才开始执行." @默认值 = 真>
    参数 未来值对象 <注释 = "必须为\"未来对象模板类\"的模板实现类,比如\"未来整数类\";" 注释 = "其中\"模板类型1\"必须跟\"静态方法\"的返回值类型一致;"
            注释 = "如果方法没有返回值,请使用\"未来空值类\";" @匹配类型 = 通用类>
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法,提供的方法必须具有返回值." @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @<未来值对象> = std::async(@<是否立即执行> ? std::launch::async : (std::launch::async | std::launch::deferred), &@<静态方法>, @<参数列表>)
    }

    方法 启动动态异步 <公开 静态 注释 = "创建一个与类动态方法关联的异步对象,然后立即分离并非阻塞执行线程函数."
            注释 = "  1. 可以关联任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;"
            注释 = "  5. 如果关联的对象实例被销毁,线程将异常结束(不影响整个进程的运作);" 折叠 @嵌入式方法 = "">
    参数 是否立即执行 <类型 = 逻辑型 注释 = "是否立即执行异步线程,为假将延迟执行,直到未来对象执行\"等待/取值\"才开始执行." @默认值 = 真>
    参数 未来值对象 <注释 = "必须为\"未来对象模板类\"的模板实现类,比如\"未来整数类\";" 注释 = "其中\"模板类型1\"必须跟\"静态方法\"的返回值类型一致;"
            注释 = "如果方法没有返回值,请使用\"未来空值类\";" @匹配类型 = 通用类>
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @<未来值对象> = std::async(@<是否立即执行> ? std::launch::async : (std::launch::async | std::launch::deferred), &@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>)
    }

    方法 启动无参数静态异步 <公开 静态 注释 = "创建一个与静态方法关联的异步对象,然后立即分离并非阻塞执行线程函数." 注释 = "  1. 只能关联无参数的静态方法;" 折叠 @嵌入式方法 = "">
    参数 是否立即执行 <类型 = 逻辑型 注释 = "是否立即执行异步线程,为假将延迟执行,直到未来对象执行\"等待/取值\"才开始执行." @默认值 = 真>
    参数 未来值对象 <注释 = "必须为\"未来对象模板类\"的模板实现类,比如\"未来整数类\";" 注释 = "其中\"模板类型1\"必须跟\"静态方法\"的返回值类型一致;"
            注释 = "如果方法没有返回值,请使用\"未来空值类\";" @匹配类型 = 通用类>
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法,提供的方法必须具有返回值." @匹配方法 = "">
    {
        @ @<未来值对象> = std::async(@<是否立即执行> ? std::launch::async : (std::launch::async | std::launch::deferred), &@<静态方法>)
    }

    方法 启动无参数动态异步 <公开 静态 注释 = "创建一个与类动态方法关联的异步对象,然后立即分离并非阻塞执行线程函数." 注释 = "  1. 只能关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 如果关联的对象实例被销毁,线程将异常结束(不影响整个进程的运作);" 折叠 @嵌入式方法 = "">
    参数 是否立即执行 <类型 = 逻辑型 注释 = "是否立即执行异步线程,为假将延迟执行,直到未来对象执行\"等待/取值\"才开始执行." @默认值 = 真>
    参数 未来值对象 <注释 = "必须为\"未来对象模板类\"的模板实现类,比如\"未来整数类\";" 注释 = "其中\"模板类型1\"必须跟\"静态方法\"的返回值类型一致;"
            注释 = "如果方法没有返回值,请使用\"未来空值类\";" @匹配类型 = 通用类>
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ @<未来值对象> = std::async(@<是否立即执行> ? std::launch::async : (std::launch::async | std::launch::deferred), &@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>)
    }
}

类 未来对象模板类 <公开 注释 = "共享未来对象(std::shared_future)可以获取异步对象和承诺对象的值." 注释 = "  1. 共享未来对象可复制多个副本指向同一个共享状态;"
        注释 = "  2. \"模板类型1\"为所欲封装的数据类型;" 折叠 @文档 = "category = \"多线程.辅助类\"" @视窗.外部头文件 = "<future>" @模板基础类 = 真>
{
    方法 取值 <公开 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则一直等待直到未来对象拥有合法的结果,然后获取结果并返回真;"
            注释 = "执行后将释放任何的共享状态,\"是否有效\"将返回假." 折叠 @嵌入式方法 = "">
    参数 未来值 <类型 = 模板类型1 @需求类型 = 可写入变量>
    {
        @ [&](auto& future) {
        @     if (!future.valid()) return FALSE;
        @     @<未来值> = future.get();
        @     return TRUE;
        @ }(@sn<this>.data())
    }

    方法 等待 <公开 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则一直等待,直到未来对象拥有合法的结果,返回然后真;" 折叠 @禁止流程检查 = 真>
    {
        @ if (!data().valid()) return FALSE;
        @ data().wait();
        @ return TRUE;
    }

    方法 限时等待 <公开 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则等待指定的时间,如果在限时内未来对象拥有合法的结果,则返回真,否则返回假;" 折叠
            @禁止流程检查 = 真>
    参数 延迟时间 <类型 = 长整数 注释 = "单位为毫秒">
    {
        @ if (!data().valid()) return FALSE;
        @ return data().wait_for(std::chrono::milliseconds(@<延迟时间>)) == std::future_status::ready;
    }

    方法 是否有效 <公开 类型 = 逻辑型 注释 = "检查未来对象是否有效(拥有共享状态)." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().valid()
    }

    # @begin
    # <> <include>
    # using ValueType = std::remove_pointer<@dt<模板类型1> *>::type;
    # std::shared_future<ValueType> m_future;
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_future = objCopyFrom.m_future; }
    # inline @sn<current_class>(std::future<ValueType>&& rhs) { m_future = rhs.share(); }
    # inline @sn<current_class>& operator= (std::future<ValueType>&& rhs) { m_future = rhs.share(); return *this; }
    # inline std::shared_future<ValueType>& data() { return m_future; }
    # inline std::shared_future<ValueType>* pdata() { return &m_future; }
    # inline operator std::shared_future<ValueType>& () { return m_future; }
    # <> </include>
    # @end
}

类 承诺对象模板类 <公开 注释 = "提供一个承诺(std::promise),表示在某个时间点一定会有一个值或一个异常被设置."
        注释 = "  1. 本模板使用共享智能指针封装,可复制多个副本指向同一个承诺对象;" 注释 = "  2. \"模板类型1\"为所欲封装的数据类型;" 折叠
        @文档 = "category = \"多线程.辅助类\"" @视窗.外部头文件 = "<future>" @模板基础类 = 真>
{
    方法 取未来对象 <公开 类型 = 逻辑型 注释 = "获取与承诺的结果关联的未来对象;" 注释 = "成功返回真,如果承诺对象没有共享状态或已经获取未来对象则返回假;" 折叠 @嵌入式方法 = "">
    参数 未来对象 <注释 = "提供用来获取结果的未来对象;" 注释 = "提供的变量必须为\"未来对象模板类\"的模板实现类;" 注释 = "而且它的\"模板类型1\"必须跟承诺对象的模板实现类一致;"
            @匹配类型 = 通用类>
    {
        @ [&] {
        @     try {
        @         @<未来对象> = @sn<this>.data().get_future();
        @         return TRUE;
        @     } catch (const std::future_error& e) {
        @         PIVDEBUG("S", CVolString(e.what()).GetText());
        @         return FALSE;
        @     }
        @ }()
    }

    方法 置值 <公开 类型 = 逻辑型 注释 = "原子存储值到共享状态,然后立即令共享状态就绪,使未来对象可以取值;" 注释 = "成功返回真,如果承诺对象没有共享状态或已经存储值则返回假;" 折叠
            @禁止流程检查 = 真>
    参数 值 <类型 = 模板类型1 注释 = "提供所欲设置的值">
    {
        @ try {
        @     data().set_value(@<值>);
        @     return TRUE;
        @ } catch (const std::future_error& e) {
        @     PIVDEBUG("S", CVolString(e.what()).GetText());
        @     return FALSE;
        @ }
    }

    方法 线程退出时置值 <公开 类型 = 逻辑型 注释 = "原子存储值到共享状态,但不立即令共享状态就绪,而是等当前线程退出后再令状态就绪."
            注释 = "成功返回真,如果承诺对象没有共享状态或已经存储值则返回假;" 折叠 @禁止流程检查 = 真>
    参数 值 <类型 = 模板类型1 注释 = "提供所欲设置的值">
    {
        @ try {
        @     data().set_value_at_thread_exit(@<值>);
        @     return TRUE;
        @ } catch (const std::future_error& e) {
        @     PIVDEBUG("S", CVolString(e.what()).GetText());
        @     return FALSE;
        @ }
    }

    方法 交换 <公开 注释 = "交换两个承诺对象" 折叠 @嵌入式方法 = "">
    参数 所欲交换的对象 <类型 = 承诺对象模板类>
    {
        @ @sn<this>.data().std::swap(@<所欲交换的对象>)
    }

    # @begin
    # <> <include>
    # using ValueType = std::remove_pointer<@dt<模板类型1> *>::type;
    # std::shared_ptr<std::promise<ValueType>> m_promise{new std::promise<ValueType>};
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_promise = objCopyFrom.m_promise; }
    # inline std::promise<ValueType>& data() { return *m_promise; }
    # inline std::promise<ValueType>* pdata() { return m_promise.get(); }
    # inline operator std::promise<ValueType>& () { return *m_promise; }
    # <> </include>
    # @end
}

类 函数对象类 <公开 注释 = "函数对象(std::function)的封装类:" 注释 = "  1. 本类大部分为全局方法,直接调用即可;"
        注释 = "  2. 内部类型固定为std::function<void()>,因此它只能接受无参数的函数对象;"
        注释 = "  3. 如果绑定函数时使用了\"占位符_n\",请勿赋值到函数对象变量;" 折叠 @文档 = "category = \"多线程.辅助类\""
        @视窗.外部头文件 = "<functional>" @全局类 = 真>
{

    # 全局方法 ---

    方法 绑定静态方法 <公开 静态 类型 = 函数对象类 注释 = "将任意格式的静态方法绑定到函数对象中并返回."
            注释 = "  1. 可以绑定任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到函数对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲绑定的类静态方法名称" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" @可扩展 = "" @匹配类型 = 通用型>
    {
        @ std::bind(&@<静态方法>, @<参数列表>)
    }

    方法 绑定动态方法 <公开 静态 类型 = 函数对象类 注释 = "将任意格式的类动态方法绑定到函数对象中并返回."
            注释 = "  1. 可以绑定任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到函数对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数列表的格式务必和所提供动态方法的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ std::bind(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>)
    }

    方法 绑定无参数静态方法 <公开 静态 类型 = 函数对象类 注释 = "将无参数的静态方法绑定到函数对象中并返回." 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲绑定的类静态方法名称" @匹配方法 = "">
    {
        @ std::bind(&@<静态方法>)
    }

    方法 绑定无参数动态方法 <公开 静态 类型 = 函数对象类 注释 = "将无参数的类动态方法绑定到函数对象中并返回." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ std::bind(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>)
    }

    方法 绑定函数指针 <公开 静态 类型 = 函数对象类 注释 = "将任意格式的函数指针绑定到函数对象中并返回." 注释 = "注: 调用约定为stdcall" 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲绑定的函数指针">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" @可扩展 = "" @匹配类型 = 通用型>
    {
        @ std::bind(((void (CALLBACK *) (@pdt_list<参数列表>))@<函数指针>), @<参数列表>)
    }

    方法 绑定无参数函数指针 <公开 静态 类型 = 函数对象类 注释 = "将无参数的函数指针绑定到函数对象中并返回." 注释 = "注: 调用约定为stdcall" 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲绑定的函数指针">
    {
        @ std::bind(((void (CALLBACK *) ())@<函数指针>))
    }

    方法 绑定函数指针2 <公开 静态 类型 = 函数对象类 注释 = "将任意格式的函数指针绑定到函数对象中并返回." 注释 = "注: 调用约定为cdecl" 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲绑定的函数指针">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" @可扩展 = "" @匹配类型 = 通用型>
    {
        @ std::bind(((void (CDECL *) (@pdt_list<参数列表>))@<函数指针>), @<参数列表>)
    }

    方法 绑定无参数函数指针2 <公开 静态 类型 = 函数对象类 注释 = "将无参数的函数指针绑定到函数对象中并返回." 注释 = "注: 调用约定为cdecl" 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 注释 = "提供所欲绑定的函数指针">
    {
        @ std::bind(((void (CDECL *) ())@<函数指针>))
    }

    # 成员方法 ---

    方法 是否有效 <公开 类型 = 逻辑型 注释 = "返回本对象是否存储了可调用的函数对象" 折叠 @嵌入式方法 = "">
    {
        @ !!@sn<this>.data()
    }

    方法 调用函数 <公开 注释 = "调用本对象的可调用函数对象,std::function<void()>类型专用;" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.Run()
    }

    # @begin
    # <> <include>
    # std::function<void()> m_func;
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_func = objCopyFrom.m_func; }
    # inline @sn<current_class>& operator= (const std::function<void()>& rhs) { m_func = rhs; return *this; }
    # inline @sn<current_class>& operator= (std::function<void()>&& rhs) { m_func = std::move(rhs); return *this; }
    # inline operator std::function<void()>& () { return m_func; }
    # inline std::function<void()>& data() { return m_func; }
    # inline void Run() { if (m_func) m_func(); }
    # <> </include>
    # @end
    # 占位符 ---

    方法 占位符_1 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_1
    }

    方法 占位符_2 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_2
    }

    方法 占位符_3 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_3
    }

    方法 占位符_4 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_4
    }

    方法 占位符_5 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_5
    }

    方法 占位符_6 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_6
    }

    方法 占位符_7 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_7
    }

    方法 占位符_8 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_8
    }

    方法 占位符_9 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_9
    }

    方法 占位符_10 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_10
    }

    方法 占位符_11 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_11
    }

    方法 占位符_12 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_12
    }

    方法 占位符_13 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_13
    }

    方法 占位符_14 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_14
    }

    方法 占位符_15 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_15
    }

    方法 占位符_16 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_16
    }

    方法 占位符_17 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_17
    }

    方法 占位符_18 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_18
    }

    方法 占位符_19 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_19
    }

    方法 占位符_20 <公开 静态 注释 = "在绑定方法(std::bind)时用作参数的占位符,表示不在绑定时提供参数值,"
            注释 = "而是在后续调用时提供.必须从\"占位符_1\"开始,然后按占位的数量递增." 折叠 @嵌入式方法 = "">
    参数 参数类型 <注释 = "提供所占位参数的数据类型" 编辑时信息 = "16DB5, 0, 0, 0" @返回值类型 = 0 @需求类型 = 数据类型 @匹配类型 = 通用型>
    {
        @ std::placeholders::_20
    }
}

# 常用未来对象类 ---

类 未来空值类 <公开 注释 = "void类型的特化" 折叠 @文档 = "category = \"多线程.辅助类\"" @视窗.外部头文件 = "<future>">
{
    方法 取值 <公开 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则一直等待直到未来对象拥有合法的结果,然后返回真;"
            注释 = "执行后将释放任何的共享状态,\"是否有效\"将返回假." 折叠 @禁止流程检查 = 真>
    {
        @ if (!data().valid()) return FALSE;
        @ data().get();
        @ return TRUE;
    }

    方法 等待 <公开 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则一直等待,直到未来对象拥有合法的结果,返回然后真;" 折叠 @禁止流程检查 = 真>
    {
        @ if (!data().valid()) return FALSE;
        @ data().wait();
        @ return TRUE;
    }

    方法 限时等待 <公开 类型 = 逻辑型 注释 = "首先检查是否有共享状态,无共享状态时直接返回假;" 注释 = "有效则等待指定的时间,如果在限时内未来对象拥有合法的结果,则返回真,否则返回假;" 折叠
            @禁止流程检查 = 真>
    参数 延迟时间 <类型 = 长整数 注释 = "单位为毫秒">
    {
        @ if (!data().valid()) return FALSE;
        @ return data().wait_for(std::chrono::milliseconds(@<延迟时间>)) == std::future_status::ready;
    }

    方法 是否有效 <公开 类型 = 逻辑型 注释 = "检查未来对象是否有效(拥有共享状态)." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().valid()
    }

    # @begin
    # <> <include>
    # using ValueType = void;
    # std::shared_future<void> m_future;
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_future = objCopyFrom.m_future; }
    # inline @sn<current_class>(std::future<void>&& rhs) { m_future = rhs.share(); }
    # inline @sn<current_class>& operator= (std::future<void>&& rhs) { m_future = rhs.share(); return *this; }
    # inline std::shared_future<void>& data() { return m_future; }
    # inline std::shared_future<void>* pdata() { return &m_future; }
    # inline operator std::shared_future<void>& () { return m_future; }
    # <> </include>
    # @end
}

类 未来整数类 <公开 基础类 = 未来对象模板类 @文档 = "category = \"多线程.辅助类.未来对象\"" @模板实现类 = "整数">

类 未来长整数类 <公开 基础类 = 未来对象模板类 @文档 = "category = \"多线程.辅助类.未来对象\"" @模板实现类 = "长整数">

类 未来小数类 <公开 基础类 = 未来对象模板类 @文档 = "category = \"多线程.辅助类.未来对象\"" @模板实现类 = "小数">

类 未来逻辑类 <公开 基础类 = 未来对象模板类 @文档 = "category = \"多线程.辅助类.未来对象\"" @模板实现类 = "逻辑型">

类 未来文本类 <公开 基础类 = 未来对象模板类 @文档 = "category = \"多线程.辅助类.未来对象\"" @模板实现类 = "文本型">

类 未来字节集类 <公开 基础类 = 未来对象模板类 @文档 = "category = \"多线程.辅助类.未来对象\"" @模板实现类 = "字节集类">

# 常用承诺对象类 ---

类 承诺空值类 <公开 注释 = "void类型的特化,用于发出共享信号" 注释 = "配合\"未来空值类\"使用" 折叠 @文档 = "category = \"多线程.辅助类.承诺对象\""
        @视窗.外部头文件 = "<future>">
{
    方法 取未来对象 <公开 类型 = 逻辑型 注释 = "获取与承诺的结果关联的未来对象;" 注释 = "成功返回真,如果承诺对象没有共享状态或已经获取未来对象则返回假;" 折叠 @嵌入式方法 = "">
    参数 未来对象 <类型 = 未来空值类 注释 = "提供用来获取结果的未来对象;" 注释 = "提供的变量必须为\"未来对象模板类\"的模板实现类;"
            注释 = "而且它的\"模板类型1\"必须跟承诺对象的模板实现类一致;">
    {
        @ [&] {
        @     try {
        @         @<未来对象> = @sn<this>.data().get_future();
        @         return TRUE;
        @     } catch (const std::future_error& e) {
        @         PIVDEBUG("S", CVolString(e.what()).GetText());
        @         return FALSE;
        @     }
        @ }()
    }

    方法 置值 <公开 类型 = 逻辑型 注释 = "令共享状态就绪,使未来对象可以取值;" 注释 = "成功返回真,如果承诺对象没有共享状态或共享状态已就绪则返回假;" 折叠 @禁止流程检查 = 真>
    {
        @ try {
        @     data().set_value();
        @     return TRUE;
        @ } catch (const std::future_error& e) {
        @     PIVDEBUG("S", CVolString(e.what()).GetText());
        @     return FALSE;
        @ }
    }

    方法 线程退出时置值 <公开 类型 = 逻辑型 注释 = "等当前线程退出后令状态就绪." 注释 = "成功返回真,如果承诺对象没有共享状态或共享状态已就绪则返回假;" 折叠 @禁止流程检查 = 真>
    {
        @ try {
        @     data().set_value_at_thread_exit();
        @     return TRUE;
        @ } catch (const std::future_error& e) {
        @     PIVDEBUG("S", CVolString(e.what()).GetText());
        @     return FALSE;
        @ }
    }

    方法 交换 <公开 注释 = "交换两个承诺对象" 折叠 @嵌入式方法 = "">
    参数 所欲交换的对象 <类型 = 承诺空值类>
    {
        @ @sn<this>.data().std::swap(@<所欲交换的对象>)
    }

    # @begin
    # <> <include>
    # std::shared_ptr<std::promise<void>> m_promise{new std::promise<void>};
    # inline void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom) { m_promise = objCopyFrom.m_promise; }
    # inline std::promise<void>& data() { return *m_promise; }
    # inline std::promise<void>* pdata() { return m_promise.get(); }
    # inline operator std::promise<void>& () { return *m_promise; }
    # <> </include>
    # @end
}

类 承诺整数类 <公开 基础类 = 承诺对象模板类 @文档 = "category = \"多线程.辅助类.承诺对象\"" @模板实现类 = "整数">

类 承诺长整数类 <公开 基础类 = 承诺对象模板类 @文档 = "category = \"多线程.辅助类.承诺对象\"" @模板实现类 = "长整数">

类 承诺小数类 <公开 基础类 = 承诺对象模板类 @文档 = "category = \"多线程.辅助类.承诺对象\"" @模板实现类 = "小数">

类 承诺逻辑类 <公开 基础类 = 承诺对象模板类 @文档 = "category = \"多线程.辅助类.承诺对象\"" @模板实现类 = "逻辑型">

类 承诺文本类 <公开 基础类 = 承诺对象模板类 @文档 = "category = \"多线程.辅助类.承诺对象\"" @模板实现类 = "文本型">

类 承诺字节集类 <公开 基础类 = 承诺对象模板类 @文档 = "category = \"多线程.辅助类.承诺对象\"" @模板实现类 = "字节集类">

类 承诺对象包装类 <公开 基础类 = 承诺对象模板类 @文档 = "category = \"多线程.辅助类.承诺对象\"" @模板实现类 = "对象包装类">

#
# 过时 ===

类 线程池类 <公开 注释 = "(过时)功能强、效率快、高稳定、无内存和句柄泄漏的线程池." 注释 = "  1. 使用高效的ICOP异步模型,队列式执行线程任务;"
        注释 = "  2. 使用Windows API的线程函数,兼容性良好;" 注释 = "  3. 线程的回调函数在\"接收事件\"中执行,可以调用类的动态成员;"
        注释 = "  4. 耗时和死循环的线程必须退出,否则窗口关掉了还在跑;" 折叠 @文档 = "category = \"多线程\"" @视窗.外部头文件 = "src\\piv_thread.hpp"
        @视窗.后缀文本 = "public PivThreadPool">
{
    方法 启动线程 <公开 类型 = 逻辑型 注释 = "  启动一个线程,请在接收事件\"对象任务回调\"中编写回调方法." 注释 = "  本方法不归线程池管理,可独立使用,线程句柄在执行完毕后自动关闭,"
            注释 = "因此每次启动都是一个新线程." 返回值注释 = "成功返回真,失败返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    参数 是否等待线程执行完毕 <类型 = 逻辑型 注释 = "指定本方法是否一直等待线程执行完毕后才会返回" @默认值 = 假>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别" @默认值 = 线程优先级.通常>
    {
        @ return @sn<current_class_def>::StartThread (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadObjWorkerProc), @<用户标记>,
        @                                             @<用户对象>, @<用户数据>, @<是否等待线程执行完毕>, @<初始堆栈大小>, (INT)@<优先级>);
    }

    方法 创建 <公开 类型 = 逻辑型 注释 = "创建线程池,必须成功创建后才能使用其他方法." 返回值注释 = "返回是否创建成功,重复创建亦返回真." 折叠 @嵌入式方法 = "">
    参数 线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU逻辑核心数 + 1)."
            注释 = "  - I/O密集型建议: CPU核数 * (1 + (I/O耗时 / CPU耗时))" 注释 = "  - 计算密集型建议: CPU核数 + 1" @默认值 = 0>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别." @默认值 = 线程优先级.通常>
    参数 是否初始化COM <类型 = 逻辑型 注释 = "  是否在线程池内部自动执行COM初始化和清理." 注释 = "  多线程中使用COM对象必须执行COM初始化,由于本线程池是一个线程队列执行"
            注释 = "多个任务,不太适合在\"任务回调/对象任务回调\"事件中进行初始化.如果你需要" 注释 = "使用COM对象,请将本参数设置为\"真\"." @默认值 = 假>
    {
        @ @sn<this>.CreateThreadPool (@<线程数量>, @<初始堆栈大小>, (INT)@<优先级>, @<是否初始化COM>)
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "销毁线程池,释放线程池占用的所有资源." 注释 = "  1. 销毁线程池不会强制结束仍在运行的线程,请在线程的耗时或"
            注释 = "死循环中调用本对象的方法\"是否需要退出\",一旦发现该方法返回真," 注释 = "必须尽快结束\"任务回调\"/\"对象任务回调\"事件的执行."
            注释 = "  2. 类清理时会自动销毁,如果线程池实例定义在窗口的成员变量中," 注释 = "必须在窗口即将销毁时执行销毁线程池." 返回值注释 = "成功或已经销毁返回真,失败返回假."
            返回值注释 = "失败原因包括: 线程池正在创建或正在销毁." 折叠 @嵌入式方法 = "">
    参数 是否强制销毁 <类型 = 逻辑型 注释 = "假=正常销毁,等待任务执行完毕后返回;" 注释 = "真=强制销毁,不等待执行中的任务,清空后续的队列任务后立即返回." @默认值 = 假>
    参数 最长等待时间 <类型 = 整数 注释 = "此参数只对非强制销毁有效,单位为毫秒." 注释 = "-1为一直等待所有任务完成,否则到了超时时间会清空任务并返回." @默认值 = -1>
    {
        @ @sn<this>.DestroyThreadPool (@<是否强制销毁>, @<最长等待时间>)
    }

    方法 暂停 <公开 类型 = 逻辑型 注释 = "停止执行新的任务,当前正在执行的任务不会被暂停." 返回值注释 = "返回是否暂停成功,线程池的不在工作状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SuspendThreadPool ()
    }

    方法 继续 <公开 类型 = 逻辑型 注释 = "继续执行线程池任务" 返回值注释 = "返回是否继续成功,线程池的不在暂停状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ResumeThreadPool ()
    }

    方法 投递任务 <公开 类型 = 逻辑型 注释 = "投递线程任务到线程池中,投递后请在接收事件\"任务回调\"中编写线程方法." 注释 = "本方法只支持基本数值参数."
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户参数 <类型 = 长整数 @默认值 = 0>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostParamTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolWorkerProc),
        @                                               @<用户标记>, @<用户参数>, @<用户数据>);
    }

    方法 投递对象 <公开 类型 = 逻辑型 注释 = "  投递线程任务到线程池中,投递后请在接收事件\"对象任务回调\"中编写线程方法." 注释 = "本方法支持传递自定义对象类型,但请注意以下几点:"
            注释 = "  1. 会将投递的用户对象复制一份副本,副本的生命周期到回调任务结束后为止," 注释 = "因此可以直接投递局部变量."
            注释 = "  2. 用户对象经过复制,已经不等于原来的对象实例(指针值不一样)." 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostObjectTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolObjWorkerProc),
        @                                                @<用户标记>, @<用户对象>, @<用户数据>);
    }

    方法 清空任务 <公开 类型 = 逻辑型 注释 = "清空已投递的队列任务,将队列任务占用的内存释放." 返回值注释 = "返回是否开始清空任务,线程池不在正常工作和暂停状态时始终返回假." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ClearTask ()
    }

    方法 任务回调 <公开 定义事件 类型 = 整数 注释 = "线程池\"投递任务\"的回调函数,请在本事件内写线程方法." 返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户参数 <类型 = 长整数>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 对象任务回调 <公开 定义事件 类型 = 整数 注释 = "  线程池\"投递对象\"的回调函数,请在本事件内写线程方法." 注释 = "传入的用户对象会在本次任务结束后自动释放."
            返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户对象 <类型 = 对象类 注释 = "  用户投递的自定义对象,请自行强制到原来的对象类型再使用,如:" 注释 = "  1. 对象变量 = (自定义对象)用户对象"
            注释 = "  2. ((自定义对象)用户对象).成员" 注释 = "  方法1会将用户对象强制转换类型后复制到新变量,这会略增加内存的占用;"
            注释 = "  方法2不会创建新的对象实例,但写起来比较麻烦.">
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 是否需要退出 <公开 类型 = 逻辑型 注释 = "检查线程任务是否需要尽快退出." 注释 = "  1. 本方法只能在本对象\"任务回调\"/\"对象任务回调\"事件中执行"
            注释 = "  2. 本方法返回真则表示正在销毁线程池,必须尽快结束线程任务;" 注释 = "  3. 如果线程未及时结束,则线程池乃至程序可能要等线程执行完毕"
            注释 = "才会彻底结束,如果线程内有死循环,可能将永远不会自己结束;" 返回值注释 = "返回线程是否需要尽快退出." 折叠 @嵌入式方法 = "">
    参数 最大检查等待时间 <类型 = 整数 注释 = "指定检查线程池销毁通知(由\"销毁\"方法发出)的最大等待时间," 注释 = "单位为毫秒,为0表示不等待,为-1表示一直等待." @默认值 = 0>
    {
        @ @sn<this>.IsNeedExit (@<最大检查等待时间>)
    }

    方法 调整线程池 <公开 类型 = 逻辑型 注释 = "动态调整线程池的容量(同时工作线程数量)." 注释 = "若新线程数量比原来大,会立即改变工作线程数量;"
            注释 = "若新线程数量比原来小,则需要等之前投递的任务全部完成,才会改变工作线程数量;" 返回值注释 = "返回是否成功调整线程池容量,线程池未创建、正在销毁或正在调整线程池时返回假." 折叠
            @嵌入式方法 = "">
    参数 新线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU核心数 + 1)." @默认值 = 0>
    {
        @ @sn<this>.SetThreadPoolCapacity (@<新线程数量>)
    }

    方法 CPU核心数 <公开 属性读 类型 = 整数 注释 = "获取CPU的逻辑核心数量(如支持超线程的16核CPU,返回32)." 返回值注释 = "成功返回CPU逻辑核心数,失败时始终返回1." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetProcessorsCount ()
    }

    方法 现行线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池当前的工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCount ()
    }

    方法 线程池容量 <公开 属性读 类型 = 整数 注释 = "获取线程池的最大工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCapacity ()
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取正在执行的任务数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWorkerTaskCount ()
    }

    方法 队列任务数 <公开 属性读 类型 = 长整数 注释 = "获取等待处理的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetQueueTaskCount ()
    }

    方法 已完成任务数 <公开 属性读 类型 = 长整数 注释 = "获取已完成的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetComplateTaskCount ()
    }

    方法 空闲线程数 <公开 属性读 类型 = 整数 注释 = "获取空闲的线程数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetFreeThreadsCount ()
    }

    方法 工作状态 <公开 属性读 类型 = 整数 注释 = "获取线程池的工作状态" 返回值注释 = "0=未启动;1=正在销毁;2=正在创建;3=正在工作;4=调整线程池;5=暂停中;6=正在清空任务"
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadPoolState ()
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "判断线程池是否处于彻底空闲状态,没有任何任务在执行." 返回值注释 = "真为空闲,假为繁忙,线程池未创建也返回真." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadPoolIsFree ()
    }

    # ---
    # @begin
    # <> <include>
    # static INT CALLBACK ThreadPoolWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<任务回调> (lpThreadParam->nUserMark, lpThreadParam->lUserParam, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadPoolObjWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadObjWorkerProc (@sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     ((@sn<current_class>*)lpThreadParam->lpThis)->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    #     lpThreadParam->lpUserObj->Destroy();
    #     delete lpThreadParam;
    #     return 0;
    # }
    # <> </include>
    # @end
    # ---
}

类 线程池类EX <公开 注释 = "(过时)带动态调整线程池容量,功能强、效率快、高稳定、无内存和句柄泄漏的线程池." 注释 = "  1. 使用高效的ICOP异步模型,队列式执行线程任务;"
        注释 = "  2. 使用Windows API的线程函数,兼容性良好;" 注释 = "  3. 线程的回调函数在\"接收事件\"中执行,可以调用类的动态成员;"
        注释 = "  4. 耗时和死循环的线程必须退出,否则窗口关掉了还在跑;" 注释 = "  5. 支持按需调节线程池的执行线程数;" @文档 = "category = \"多线程\""
        @视窗.外部头文件 = "src\\piv_thread.hpp" @视窗.后缀文本 = "public PivThreadPoolEx">
{
    方法 启动线程 <公开 类型 = 逻辑型 注释 = "  启动一个线程,请在接收事件\"对象任务回调\"中编写回调方法." 注释 = "  本方法不归线程池管理,可独立使用,线程句柄在执行完毕后自动关闭,"
            注释 = "因此每次启动都是一个新线程." 返回值注释 = "成功返回真,失败返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    参数 是否等待线程执行完毕 <类型 = 逻辑型 注释 = "指定本方法是否一直等待线程执行完毕后才会返回" @默认值 = 假>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别" @默认值 = 线程优先级.通常>
    {
        @ return @sn<current_class_def>::StartThread (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadObjWorkerProc), @<用户标记>,
        @                                             @<用户对象>, @<用户数据>, @<是否等待线程执行完毕>, @<初始堆栈大小>, (INT)@<优先级>);
    }

    方法 创建 <公开 类型 = 逻辑型 注释 = "创建线程池,必须成功创建后才能使用其他方法." 返回值注释 = "返回是否创建成功,重复创建亦返回真." 折叠 @嵌入式方法 = "">
    参数 最小线程数 <类型 = 整数 注释 = "最小同时工作的线程数,默认为5,不得小于1." @默认值 = 5>
    参数 最大线程数 <类型 = 整数 注释 = "最大同时工作的线程数量,默认为20.小于等于0为(CPU逻辑核心数 + 1)." 注释 = "无论如何,最终值会自动调整为大于等于(最小线程数+2)."
            @默认值 = 20>
    参数 动态线程周期 <类型 = 整数 注释 = "动态线程的检测周期时间,单位毫秒.默认为5000ms(5秒),最低100ms."
            注释 = "一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数." 注释 = "如果任务过少则自动回收动态线程." @默认值 = 5000>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别." @默认值 = 线程优先级.通常>
    参数 是否初始化COM <类型 = 逻辑型 注释 = "  是否在线程池内部自动执行COM初始化和清理." 注释 = "  多线程中使用COM对象必须执行COM初始化,由于本线程池是一个线程队列执行"
            注释 = "多个任务,不太适合在\"任务回调/对象任务回调\"事件中进行初始化.如果你需要" 注释 = "使用COM对象,请将本参数设置为\"真\"." @默认值 = 假>
    {
        @ @sn<this>.CreateThreadPool (@<最小线程数>, @<最大线程数>, @<动态线程周期>, @<初始堆栈大小>, (INT)@<优先级>, @<是否初始化COM>)
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "销毁线程池,释放线程池占用的所有资源." 注释 = "  1. 销毁线程池不会强制结束仍在运行的线程,请在线程的耗时或"
            注释 = "死循环中调用本对象的方法\"是否需要退出\",一旦发现该方法返回真," 注释 = "必须尽快结束\"任务回调\"/\"对象任务回调\"事件的执行."
            注释 = "  2. 类清理时会自动销毁,如果线程池实例定义在窗口的成员变量中," 注释 = "必须在窗口即将销毁时执行销毁线程池." 返回值注释 = "成功或已经销毁返回真,失败返回假."
            返回值注释 = "失败原因包括: 线程池正在创建或正在销毁." 折叠 @嵌入式方法 = "">
    参数 是否强制销毁 <类型 = 逻辑型 注释 = "假=正常销毁,等待任务执行完毕后返回;" 注释 = "真=强制销毁,不等待执行中的任务,清空后续的队列任务后立即返回." @默认值 = 假>
    参数 最长等待时间 <类型 = 整数 注释 = "此参数只对非强制销毁有效,单位为毫秒." 注释 = "-1为一直等待所有任务完成,否则到了超时时间会清空任务并返回." @默认值 = -1>
    {
        @ @sn<this>.DestroyThreadPool (@<是否强制销毁>, @<最长等待时间>)
    }

    方法 暂停 <公开 类型 = 逻辑型 注释 = "停止执行新的任务,当前正在执行的任务不会被暂停." 返回值注释 = "返回是否暂停成功,线程池的不在工作状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SuspendThreadPool ()
    }

    方法 继续 <公开 类型 = 逻辑型 注释 = "继续执行线程池任务" 返回值注释 = "返回是否继续成功,线程池的不在暂停状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ResumeThreadPool ()
    }

    方法 投递任务 <公开 类型 = 逻辑型 注释 = "投递线程任务到线程池中,投递后请在接收事件\"任务回调\"中编写线程方法." 注释 = "本方法只支持基本数值参数."
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户参数 <类型 = 长整数 @默认值 = 0>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostParamTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolWorkerProc),
        @                                               @<用户标记>, @<用户参数>, @<用户数据>);
    }

    方法 投递对象 <公开 类型 = 逻辑型 注释 = "  投递线程任务到线程池中,投递后请在接收事件\"对象任务回调\"中编写线程方法." 注释 = "本方法支持传递自定义对象类型,但请注意以下几点:"
            注释 = "  1. 会将投递的用户对象复制一份副本,副本的生命周期到回调任务结束后为止," 注释 = "因此可以直接投递局部变量."
            注释 = "  2. 用户对象经过复制,已经不等于原来的对象实例(指针值不一样)." 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostObjectTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolObjWorkerProc),
        @                                                @<用户标记>, @<用户对象>, @<用户数据>);
    }

    方法 清空任务 <公开 类型 = 逻辑型 注释 = "清空已投递的队列任务,将队列任务占用的内存释放." 返回值注释 = "返回是否开始清空任务,线程池不在正常工作和暂停状态时始终返回假." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ClearTask ()
    }

    方法 任务回调 <公开 定义事件 类型 = 整数 注释 = "线程池\"投递任务\"的回调函数,请在本事件内写线程方法." 返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户参数 <类型 = 长整数>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 对象任务回调 <公开 定义事件 类型 = 整数 注释 = "  线程池\"投递对象\"的回调函数,请在本事件内写线程方法." 注释 = "传入的用户对象会在本次任务结束后自动释放."
            返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户对象 <类型 = 对象类 注释 = "  用户投递的自定义对象,请自行强制到原来的对象类型再使用,如:" 注释 = "  1. 对象变量 = (自定义对象)用户对象"
            注释 = "  2. ((自定义对象)用户对象).成员" 注释 = "  方法1会将用户对象强制转换类型后复制到新变量,这会略增加内存的占用;"
            注释 = "  方法2不会创建新的对象实例,但写起来比较麻烦.">
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 是否需要退出 <公开 类型 = 逻辑型 注释 = "检查线程任务是否需要尽快退出." 注释 = "  1. 本方法只能在本对象\"任务回调\"/\"对象任务回调\"事件中执行"
            注释 = "  2. 本方法返回真则表示正在销毁线程池,必须尽快结束线程任务;" 注释 = "  3. 如果线程未及时结束,则线程池乃至程序可能要等线程执行完毕"
            注释 = "才会彻底结束,如果线程内有死循环,可能将永远不会自己结束;" 返回值注释 = "返回线程是否需要尽快退出." 折叠 @嵌入式方法 = "">
    参数 最大检查等待时间 <类型 = 整数 注释 = "指定检查线程池销毁通知(由\"销毁\"方法发出)的最大等待时间," 注释 = "单位为毫秒,为0表示不等待,为-1表示一直等待." @默认值 = 0>
    {
        @ @sn<this>.IsNeedExit (@<最大检查等待时间>)
    }

    方法 调整线程池 <公开 类型 = 逻辑型 注释 = "动态调整线程池的容量(同时工作线程数量)." 注释 = "若新线程数量比原来大,会立即改变工作线程数量;"
            注释 = "若新线程数量比原来小,则需要等之前投递的任务全部完成,才会改变工作线程数量;" 返回值注释 = "返回是否成功调整线程池容量,线程池未创建、正在销毁或正在调整线程池时返回假." 折叠
            @嵌入式方法 = "">
    参数 新线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU核心数 + 1)." @默认值 = 0>
    {
        @ @sn<this>.SetThreadPoolCapacity (@<新线程数量>)
    }

    方法 CPU核心数 <公开 属性读 类型 = 整数 注释 = "获取CPU的逻辑核心数量(如支持超线程的16核CPU,返回32)." 返回值注释 = "成功返回CPU逻辑核心数,失败时始终返回1." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetProcessorsCount ()
    }

    方法 现行线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池当前的工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCount ()
    }

    方法 线程池容量 <公开 属性读 类型 = 整数 注释 = "获取线程池的最大工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCapacity ()
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取正在执行的任务数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWorkerTaskCount ()
    }

    方法 队列任务数 <公开 属性读 类型 = 长整数 注释 = "获取等待处理的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetQueueTaskCount ()
    }

    方法 已完成任务数 <公开 属性读 类型 = 长整数 注释 = "获取已完成的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetComplateTaskCount ()
    }

    方法 空闲线程数 <公开 属性读 类型 = 整数 注释 = "获取空闲的线程数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetFreeThreadsCount ()
    }

    方法 工作状态 <公开 属性读 类型 = 整数 注释 = "获取线程池的工作状态" 返回值注释 = "0=未启动;1=正在销毁;2=正在创建;3=正在工作;4=调整线程池;5=暂停中;6=正在清空任务"
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadPoolState ()
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "判断线程池是否处于彻底空闲状态,没有任何任务在执行." 返回值注释 = "真为空闲,假为繁忙,线程池未创建也返回真." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadPoolIsFree ()
    }

    方法 动态线程周期 <公开 属性读 类型 = 整数 注释 = "获取动态调整线程的检测周期(单位毫秒)." 注释 = "一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数."
            注释 = "如果任务过少则自动回收动态线程." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetCycleMs ()
    }

    方法 动态线程周期 <公开 属性写 注释 = "设置动态调整线程的检测周期." 注释 = "一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数."
            注释 = "如果任务过少则自动回收动态线程." 折叠>
    参数 新的周期 <类型 = 整数 注释 = "动态线程的检测周期时间,单位毫秒,最低100ms.">
    {
        @ @sn<current_class_def>::SetCycleMs (@<新的周期>);
    }

    # ---
    # @begin
    # <> <include>
    # static INT CALLBACK ThreadPoolWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<任务回调> (lpThreadParam->nUserMark, lpThreadParam->lUserParam, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadPoolObjWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadObjWorkerProc (@sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     ((@sn<current_class>*)lpThreadParam->lpThis)->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    #     lpThreadParam->lpUserObj->Destroy();
    #     delete lpThreadParam;
    #     return 0;
    # }
    # <> </include>
    # @end
    # ---
}

#
