<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" "">

类 线程池类 <公开 注释 = "功能强、效率快、高稳定、无内存和句柄泄漏的线程池." 注释 = "线程的回调函数在接收事件中编写,不需要使用静态方法,传参和操作UI更简单."
        注释 = "可在UI线程中执行耗时操作不卡界面." 折叠 @文档 = "category = \"多线程\"" @视窗.外部头文件 = "src//piv_thread.hpp"
        @视窗.后缀文本 = "public PivThreadPool">
{
    方法 启动线程 <公开 类型 = 逻辑型 注释 = "  启动一个线程,请在接收事件\"对象任务回调\"中编写回调方法."
            注释 = "  本方法不归线程池管理,可独立使用,线程句柄在执行完毕后自动关闭," 注释 = "因此每次启动都是一个新线程." 返回值注释 = "成功返回真,失败返回假." 折叠
            @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "  使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "  将创建用户对象的副本,因此可以直接使用局部变量."
            @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    参数 是否等待线程执行完毕 <类型 = 逻辑型 注释 = "指定本方法是否一直等待线程执行完毕后才会返回" @默认值 = 假>
    参数 初始堆栈大小 <类型 = 整数 注释 = "  线程的堆栈初始大小,单位字节." 注释 = "  应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "  为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别." @默认值 = 线程优先级.通常>
    {
        @ return @sn<current_class_def>::StartThread (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadObjWorkerProc), @<用户标记>,
        @                                             @<用户对象>, @<用户数据>, @<是否等待线程执行完毕>, @<初始堆栈大小>, (INT)@<优先级>);
    }

    方法 创建 <公开 类型 = 逻辑型 注释 = "创建线程池,必须成功创建后才能使用其他方法." 返回值注释 = "返回是否创建成功,重复创建亦返回真." 折叠 @嵌入式方法 = "">
    参数 线程数量 <类型 = 整数 注释 = "  最大同时工作的线程数量. 小于等于0为(CPU逻辑核心数 + 1)."
            注释 = "  I/O密集型建议: CPU核数 * (1 + (I/O耗时 / CPU耗时))" 注释 = "  计算密集型建议: CPU核数 + 1" @默认值 = 0>
    参数 初始堆栈大小 <类型 = 整数 注释 = "  线程的堆栈初始大小,单位字节." 注释 = "  应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "  为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别." @默认值 = 线程优先级.通常>
    {
        @ @sn<this>.CreateThreadPool (@<线程数量>, @<初始堆栈大小>, (INT)@<优先级>)
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "  销毁线程池,释放线程池占用的所有资源." 注释 = "  注意: 销毁线程池不会强制结束仍在运行的线程,请在线程的耗时或"
            注释 = "死循环中调用本对象的方法\"是否需要退出\",一旦发现该方法返回真," 注释 = "必须尽快结束\"任务回调\"/\"对象任务回调\"事件的执行."
            注释 = "  类清理时会自动销毁,如果线程池实例定义在窗口的成员变量中,必须" 注释 = "在窗口即将销毁时执行销毁线程池." 返回值注释 = "成功或已经销毁返回真,失败返回假."
            返回值注释 = "失败原因包括: 线程池正在创建或正在销毁." 折叠 @嵌入式方法 = "">
    参数 是否强制销毁 <类型 = 逻辑型 注释 = "  假=正常销毁,等待任务执行完毕后返回." 注释 = "  真=强制销毁,不等待执行中的任务,清空后续的队列任务后立即返回." @默认值 = 假>
    参数 最长等待时间 <类型 = 整数 注释 = "  此参数只对非强制销毁有效,单位为毫秒." 注释 = "  -1为一直等待所有任务完成,否则到了超时时间会清空任务并返回." @默认值 = -1>
    {
        @ @sn<this>.DestroyThreadPool (@<是否强制销毁>, @<最长等待时间>)
    }

    方法 暂停 <公开 类型 = 逻辑型 注释 = "暂时停止线程池.当前正在执行的任务不会被停止,但会暂停执行新的任务." 返回值注释 = "返回是否暂停成功,线程池的不在工作状态返回假." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.SuspendThreadPool ()
    }

    方法 继续 <公开 类型 = 逻辑型 注释 = "继续执行线程池任务." 返回值注释 = "返回是否继续成功,线程池的不在暂停状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ResumeThreadPool ()
    }

    方法 投递任务 <公开 类型 = 逻辑型 注释 = "  投递线程任务到线程池中,投递后请在接收事件\"任务回调\"中编写线程方法." 注释 = "本方法只支持基本数值参数."
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户参数 <类型 = 长整数 @默认值 = 0>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostParamTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolWorkerProc),
        @                                               @<用户标记>, @<用户参数>, @<用户数据>);
    }

    方法 投递对象 <公开 类型 = 逻辑型 注释 = "  投递线程任务到线程池中,投递后请在接收事件\"对象任务回调\"中编写线程方法."
            注释 = "本方法支持传递自定义对象类型,但请注意以下几点:" 注释 = "  1. 会将投递的用户对象复制一份副本,副本的生命周期到回调任务结束后为止,"
            注释 = "因此可以直接投递局部变量." 注释 = "  2. 用户对象经过复制,已经不等于原来的对象实例(指针值不一样)."
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "  使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "  将创建用户对象的副本,因此可以直接使用局部变量."
            @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostObjectTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolObjWorkerProc),
        @                                                @<用户标记>, @<用户对象>, @<用户数据>);
    }

    方法 清空任务 <公开 类型 = 逻辑型 注释 = "清空已投递的队列任务." 注释 = "将队列任务占用的内存释放."
            返回值注释 = "返回是否开始清空任务,线程池不在正常工作和暂停状态时始终返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ClearTask ()
    }

    方法 任务回调 <公开 定义事件 类型 = 整数 注释 = "线程池\"投递任务\"的回调函数,请在本事件内写线程方法." 返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户参数 <类型 = 长整数>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 对象任务回调 <公开 定义事件 类型 = 整数 注释 = "  线程池\"投递对象\"的回调函数,请在本事件内写线程方法." 注释 = "传入的用户对象会在本次任务结束后自动释放."
            返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户对象 <类型 = 对象类 注释 = "  用户投递的自定义对象,请自行强制到原来的对象类型再使用,如:" 注释 = "  1. 对象变量 = (自定义对象)用户对象"
            注释 = "  2. ((自定义对象)用户对象).成员" 注释 = "  方法1会将用户对象强制转换类型后复制到新变量,这会略增加内存的占用;"
            注释 = "  方法2不会创建新的对象实例,但写起来比较麻烦.">
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 是否需要退出 <公开 类型 = 逻辑型 注释 = "  本方法只能在本对象\"任务回调\"/\"对象任务回调\"事件中执行,一旦"
            注释 = "发现本方法返回真,则表示正在销毁线程池,必须尽快结束处理方法的" 注释 = "执行并返回,否则关闭程序后,仍会等线程执行完才会彻底结束,特别线"
            注释 = "程内有死循环的话,就永远不会自己结束." 返回值注释 = "返回线程是否需要尽快退出." 折叠 @嵌入式方法 = "">
    参数 最大检查等待时间 <类型 = 整数 注释 = "  指定检查线程池销毁通知(由\"销毁\"方法发出)的最大等待时间," 注释 = "单位为毫秒,为0表示不等待,为-1表示一直等待."
            @默认值 = 0>
    {
        @ @sn<this>.IsNeedExit (@<最大检查等待时间>)
    }

    方法 调整线程池 <公开 类型 = 逻辑型 注释 = "  动态调整线程池的容量(同时工作线程数量)." 注释 = "  若新线程数量比原来大,会立即改变工作线程数量. "
            注释 = "  若新线程数量比原来小,则需要等之前投递的任务全部完成,才会改变工作线程数量." 返回值注释 = "返回是否成功调整线程池容量,线程池未创建、正在销毁或正在调整线程池时返回假." 折叠
            @嵌入式方法 = "">
    参数 新线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量. 小于等于0为(CPU核心数 + 1)." @默认值 = 0>
    {
        @ @sn<this>.SetThreadPoolCapacity (@<新线程数量>)
    }

    方法 CPU核心数 <公开 属性读 类型 = 整数 注释 = "获取CPU的逻辑核心数量(如支持超线程的16核CPU,返回32)." 返回值注释 = "成功返回CPU逻辑核心数,失败时始终返回1." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetProcessorsCount ()
    }

    方法 现行线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池当前的工作线程数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCount ()
    }

    方法 线程池容量 <公开 属性读 类型 = 整数 注释 = "获取线程池的最大工作线程数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCapacity ()
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取正在执行的任务数量." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWorkerTaskCount ()
    }

    方法 队列任务数 <公开 属性读 类型 = 长整数 注释 = "获取等待处理的任务数量." 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetQueueTaskCount ()
    }

    方法 已完成任务数 <公开 属性读 类型 = 长整数 注释 = "获取已完成的任务数量." 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetComplateTaskCount ()
    }

    方法 空闲线程数 <公开 属性读 类型 = 整数 注释 = "获取空闲的线程数量." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetFreeThreadsCount ()
    }

    方法 工作状态 <公开 属性读 类型 = 整数 注释 = "获取线程池的工作状态." 返回值注释 = "0=未启动,1=正在销毁,2=正在创建,3=正在工作,4=调整线程池,5=暂停中,正在清空任务" 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadPoolState ()
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "判断线程池是否处于彻底空闲状态,没有任何任务在执行." 返回值注释 = "真为空闲,假为繁忙. 线程池未创建返回真." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadPoolIsFree ()
    }

    # ---
    # @begin
    # <> <include>
    #     static INT CALLBACK ThreadPoolWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #         return pThis->@<任务回调> (lpThreadParam->nUserMark, lpThreadParam->lUserParam, lpThreadParam->lpUserData);
    #     }
    #     static INT CALLBACK ThreadPoolObjWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #         return pThis->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    #     }
    #     static INT CALLBACK ThreadObjWorkerProc (@sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #         ((@sn<current_class>*)lpThreadParam->lpThis)->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    #         lpThreadParam->lpUserObj->Destroy();
    #         delete lpThreadParam;
    #         return 0;
    #     }
    # <> </include>
    # @end
    # ---
}

类 线程池类EX <公开 注释 = "带动态调整线程池容量,功能强、效率快、高稳定、无内存和句柄泄漏的线程池."
        注释 = "线程的回调函数在接收事件中编写,不需要使用静态方法,传参和操作UI更简单." 注释 = "可在UI线程中执行耗时操作不卡界面." 折叠
        @文档 = "category = \"多线程\"" @视窗.外部头文件 = "src//piv_thread.hpp" @视窗.后缀文本 = "public PivThreadPoolEx">
{
    方法 启动线程 <公开 类型 = 逻辑型 注释 = "  启动一个线程,请在接收事件\"对象任务回调\"中编写回调方法."
            注释 = "  本方法不归线程池管理,可独立使用,线程句柄在执行完毕后自动关闭," 注释 = "因此每次启动都是一个新线程." 返回值注释 = "成功返回真,失败返回假." 折叠
            @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "  使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "  将创建用户对象的副本,因此可以直接使用局部变量."
            @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    参数 是否等待线程执行完毕 <类型 = 逻辑型 注释 = "指定本方法是否一直等待线程执行完毕后才会返回" @默认值 = 假>
    参数 初始堆栈大小 <类型 = 整数 注释 = "  线程的堆栈初始大小,单位字节." 注释 = "  应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "  为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别." @默认值 = 线程优先级.通常>
    {
        @ return @sn<current_class_def>::StartThread (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadObjWorkerProc), @<用户标记>,
        @                                             @<用户对象>, @<用户数据>, @<是否等待线程执行完毕>, @<初始堆栈大小>, (INT)@<优先级>);
    }

    方法 创建 <公开 类型 = 逻辑型 注释 = "创建线程池,必须成功创建后才能使用其他方法." 返回值注释 = "返回是否创建成功,重复创建亦返回真." 折叠 @嵌入式方法 = "">
    参数 最小线程数 <类型 = 整数 注释 = "最小同时工作的线程数,默认为5,不得小于1." @默认值 = 5>
    参数 最大线程数 <类型 = 整数 注释 = "  最大同时工作的线程数量,默认为20.小于等于0为(CPU逻辑核心数 + 1)."
            注释 = "  无论如何,最终值会自动调整为大于等于(最小线程数+2)." @默认值 = 20>
    参数 动态线程周期 <类型 = 整数 注释 = "  动态线程的检测周期时间,单位毫秒.默认为5000ms(5秒),最低100ms."
            注释 = "  一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数." 注释 = "  如果任务过少则自动回收动态线程." @默认值 = 5000>
    参数 初始堆栈大小 <类型 = 整数 注释 = "  线程的堆栈初始大小,单位字节." 注释 = "  应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "  为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别." @默认值 = 线程优先级.通常>
    {
        @ @sn<this>.CreateThreadPool (@<最小线程数>, @<最大线程数>, @<动态线程周期>, @<初始堆栈大小>, (INT)@<优先级>)
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "手动销毁线程池,释放线程池占用的所有资源." 注释 = "  注意: 销毁线程池不会强制结束仍在运行的线程,请在线程的耗时或"
            注释 = "死循环中调用本对象的方法\"是否需要退出\",一旦发现该方法返回真," 注释 = "必须尽快结束\"任务回调\"/\"对象任务回调\"事件的执行."
            注释 = "  类清理时会自动销毁,如果线程池实例定义在窗口的成员变量中,必须" 注释 = "在窗口即将销毁时执行销毁线程池." 返回值注释 = "成功或已经销毁返回真,失败返回假."
            返回值注释 = "失败原因包括: 线程池正在创建或正在销毁." 折叠 @嵌入式方法 = "">
    参数 是否强制销毁 <类型 = 逻辑型 注释 = "  假=正常销毁,等待任务执行完毕后返回." 注释 = "  真=强制销毁,不等待执行中的任务,清空后续的队列任务后立即返回." @默认值 = 假>
    参数 最长等待时间 <类型 = 整数 注释 = "  此参数只对非强制销毁有效,单位为毫秒." 注释 = "  -1为一直等待所有任务完成,否则到了超时时间会清空任务并返回." @默认值 = -1>
    {
        @ @sn<this>.DestroyThreadPool (@<是否强制销毁>, @<最长等待时间>)
    }

    方法 暂停 <公开 类型 = 逻辑型 注释 = "暂时停止线程池.当前正在执行的任务不会被停止,但会暂停执行新的任务." 返回值注释 = "返回是否暂停成功,线程池的不在工作状态返回假." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.SuspendThreadPool ()
    }

    方法 继续 <公开 类型 = 逻辑型 注释 = "继续执行线程池任务." 返回值注释 = "返回是否继续成功,线程池的不在暂停状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ResumeThreadPool ()
    }

    方法 投递任务 <公开 类型 = 逻辑型 注释 = "  投递线程任务到线程池中,投递后请在接收事件\"任务回调\"中编写线程方法." 注释 = "本方法只支持基本数值参数."
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户参数 <类型 = 长整数 @默认值 = 0>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostParamTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolWorkerProc),
        @                                               @<用户标记>, @<用户参数>, @<用户数据>);
    }

    方法 投递对象 <公开 类型 = 逻辑型 注释 = "  投递线程任务到线程池中,投递后请在接收事件\"对象任务回调\"中编写线程方法."
            注释 = "本方法支持传递自定义对象类型,但请注意以下几点:" 注释 = "  1. 会将投递的用户对象复制一份副本,副本的生命周期到回调任务结束后为止,"
            注释 = "因此可以直接投递局部变量." 注释 = "  2. 用户对象经过复制,已经不等于原来的对象实例(指针值不一样)."
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "  使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "  将创建用户对象的副本,因此可以直接使用局部变量."
            @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostObjectTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolObjWorkerProc),
        @                                                @<用户标记>, @<用户对象>, @<用户数据>);
    }

    方法 清空任务 <公开 类型 = 逻辑型 注释 = "清空已投递的队列任务." 注释 = "将队列任务占用的内存释放."
            返回值注释 = "返回是否开始清空任务,线程池不在正常工作和暂停状态时始终返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ClearTask ()
    }

    方法 任务回调 <公开 定义事件 类型 = 整数 注释 = "线程池\"投递任务\"的回调函数,请在本事件内写线程方法." 返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户参数 <类型 = 长整数>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 对象任务回调 <公开 定义事件 类型 = 整数 注释 = "  线程池\"投递对象\"的回调函数,请在本事件内写线程方法." 注释 = "传入的用户对象会在本次任务结束后自动释放."
            返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户对象 <类型 = 对象类 注释 = "  用户投递的自定义对象,请自行强制到原来的对象类型再使用,如:" 注释 = "  1. 对象变量 = (自定义对象)用户对象"
            注释 = "  2. ((自定义对象)用户对象).成员" 注释 = "  方法1会将用户对象强制转换类型后复制到新变量,这会略增加内存的占用;"
            注释 = "  方法2不会创建新的对象实例,但写起来比较麻烦.">
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 是否需要退出 <公开 类型 = 逻辑型 注释 = "  本方法只能在本对象\"任务回调\"/\"对象任务回调\"事件中执行,一旦"
            注释 = "发现本方法返回真,则表示正在销毁线程池,必须尽快结束处理方法的" 注释 = "执行并返回,否则关闭程序后,仍会等线程执行完才会彻底结束,特别线"
            注释 = "程内有死循环的话,就永远不会自己结束." 返回值注释 = "返回线程是否需要尽快退出." 折叠 @嵌入式方法 = "">
    参数 最大检查等待时间 <类型 = 整数 注释 = "  指定检查线程池销毁通知(由\"销毁\"方法发出)的最大等待时间," 注释 = "单位为毫秒,为0表示不等待,为-1表示一直等待."
            @默认值 = 0>
    {
        @ @sn<this>.IsNeedExit (@<最大检查等待时间>)
    }

    方法 CPU核心数 <公开 属性读 类型 = 整数 注释 = "获取CPU的逻辑核心数量(如支持超线程的16核CPU,返回32)." 返回值注释 = "成功返回CPU逻辑核心数,失败时始终返回1." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetProcessorsCount ()
    }

    方法 现行线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池当前的工作线程数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCount ()
    }

    方法 最大线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池的最大工作线程数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCapacity ()
    }

    方法 最小线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池的最小工作线程数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsMin ()
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取正在执行的任务数量." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWorkerTaskCount ()
    }

    方法 队列任务数 <公开 属性读 类型 = 长整数 注释 = "获取等待处理的任务数量." 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetQueueTaskCount ()
    }

    方法 已完成任务数 <公开 属性读 类型 = 长整数 注释 = "获取已完成的任务数量." 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetComplateTaskCount ()
    }

    方法 空闲线程数 <公开 属性读 类型 = 整数 注释 = "获取空闲的线程数量." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetFreeThreadsCount ()
    }

    方法 工作状态 <公开 属性读 类型 = 整数 注释 = "获取线程池的工作状态." 返回值注释 = "0=未启动,1=正在销毁,2=正在创建,3=正在工作,4=调整线程池,5=暂停中,正在清空任务" 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadPoolState ()
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "判断线程池是否处于彻底空闲状态,没有任何任务在执行." 返回值注释 = "真为空闲,假为繁忙. 线程池未创建返回真." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadPoolIsFree ()
    }

    方法 动态线程周期 <公开 属性读 类型 = 整数 注释 = "获取动态调整线程的检测周期(单位毫秒)." 注释 = "一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数."
            注释 = "如果任务过少则自动回收动态线程." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetCycleMs ()
    }

    方法 动态线程周期 <公开 属性写 注释 = "设置动态调整线程的检测周期." 注释 = "一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数."
            注释 = "如果任务过少则自动回收动态线程." 折叠>
    参数 新的周期 <类型 = 整数 注释 = "动态线程的检测周期时间,单位毫秒,最低100ms.">
    {
        @ @sn<current_class_def>::SetCycleMs (@<新的周期>);
    }

    # ---
    # @begin
    # <> <include>
    #     static INT CALLBACK ThreadPoolWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #         return pThis->@<任务回调> (lpThreadParam->nUserMark, lpThreadParam->lUserParam, lpThreadParam->lpUserData);
    #     }
    #     static INT CALLBACK ThreadPoolObjWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #         return pThis->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    #     }
    #     static INT CALLBACK ThreadObjWorkerProc (@sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #         ((@sn<current_class>*)lpThreadParam->lpThis)->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    #         lpThreadParam->lpUserObj->Destroy();
    #         delete lpThreadParam;
    #         return 0;
    #     }
    # <> </include>
    # @end
    # ---
}

#
