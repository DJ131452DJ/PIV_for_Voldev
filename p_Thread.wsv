<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" "@视窗.外部头文件.全局-100" = "<chrono>">

# 推荐 ===

类 线程池对象类 <公开 注释 = "现代C++的线程池." 注释 = "  1. 使用高效的ICOP异步模型,队列式执行线程任务;"
        注释 = "  2. 使用C++11的std::thread线程库,功能更强大;" 注释 = "  3. 支持投递任意参数格式的线程函数;"
        注释 = "  4. 支持投递类的动态方法,无需通过\"接收事件\"调用类的动态成员;" 注释 = "  5. 退出程序时线程对象会被强制结束,不会窗口关掉了还在跑;" 折叠
        @文档 = "category = \"多线程\"" @视窗.外部头文件 = "src\\piv_threadpool.hpp" @视窗.后缀文本 = "public PivThreadPoolPro">
{
    方法 创建 <公开 类型 = 逻辑型 注释 = "创建线程池,必须成功创建后才能使用其他方法." 返回值注释 = "返回是否创建成功,重复创建亦返回真." 折叠 @嵌入式方法 = "">
    参数 线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU逻辑核心数 + 1)."
            注释 = "  - I/O密集型建议: CPU核数 * (1 + (I/O耗时 / CPU耗时))" 注释 = "  - 计算密集型建议: CPU核数 + 1" @默认值 = 0>
    {
        @ @sn<this>.CreateThreadPool (@<线程数量>)
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "  销毁线程池,释放线程池占用的所有资源." 注释 = "  注意: 销毁线程池不会强制结束仍在运行的线程,请在线程的耗时或"
            注释 = "死循环中调用本对象的方法\"是否需要退出\",一旦发现该方法返回真," 注释 = "必须尽快结束\"任务回调\"/\"对象任务回调\"事件的执行."
            注释 = "  类清理时会自动销毁,如果线程池实例定义在窗口的成员变量中,必须" 注释 = "在窗口即将销毁时执行销毁线程池." 返回值注释 = "成功或已经销毁返回真,失败返回假."
            返回值注释 = "失败原因包括: 线程池正在创建或正在销毁." 折叠 @嵌入式方法 = "">
    参数 是否强制销毁 <类型 = 逻辑型 注释 = "  假=正常销毁,等待任务执行完毕后返回." 注释 = "  真=强制销毁,不等待执行中的任务,清空后续的队列任务后立即返回." @默认值 = 假>
    参数 最长等待时间 <类型 = 整数 注释 = "  此参数只对非强制销毁有效,单位为毫秒." 注释 = "  -1为一直等待所有任务完成,否则到了超时时间会清空任务并返回." @默认值 = -1>
    {
        @ @sn<this>.DestroyThreadPool (@<是否强制销毁>, @<最长等待时间>)
    }

    方法 暂停 <公开 类型 = 逻辑型 注释 = "停止执行新的任务,当前正在执行的任务不会被暂停." 返回值注释 = "返回是否暂停成功,线程池的不在工作状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SuspendThreadPool ()
    }

    方法 继续 <公开 类型 = 逻辑型 注释 = "继续执行线程池任务" 返回值注释 = "返回是否继续成功,线程池的不在暂停状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ResumeThreadPool ()
    }

    方法 投递静态方法 <公开 类型 = 逻辑型 注释 = "将静态方法投递到线程池中,线程池将按投递顺序执行任务."
            注释 = "  1. 可以投递任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;"
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制,如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @sn<this>.PostTask (&@<静态方法>, @<参数列表>)
    }

    方法 投递动态方法 <公开 类型 = 逻辑型 注释 = "将类实例的动态方法投递到线程池中,线程池将按投递顺序执行任务."
            注释 = "  1. 可以投递任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;"
            注释 = "  5. 如果关联的对象实例被销毁,线程将异常结束(不影响线程池的运作);" 注释 = "  6. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;"
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供动态方法所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数表的格式务必和类成员方法的参数表一致;" 注释 = "默认将提交的参数按值复制,如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ @sn<this>.PostTask (&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>)
    }

    方法 投递无参数静态方法 <公开 类型 = 逻辑型 注释 = "将无参数的静态方法投递到线程池中,线程池将按投递顺序执行任务." 注释 = "  1. 只能投递关联无参数的静态方法;"
            注释 = "  2. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠
            @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    {
        @ @sn<this>.PostTask (&@<静态方法>)
    }

    方法 投递无参数动态方法 <公开 类型 = 逻辑型 注释 = "将无参数的类动态方法投递到线程池中,线程池将按投递顺序执行任务." 注释 = "  1. 只能投递关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 如果关联的对象实例被销毁,线程将异常结束(不影响线程池的运作);"
            注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠
            @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供动态方法所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ @sn<this>.PostTask (&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>)
    }

    方法 清空任务 <公开 类型 = 逻辑型 注释 = "清空已投递的队列任务,将队列任务占用的内存释放." 返回值注释 = "返回是否开始清空任务,线程池不在正常工作和暂停状态时始终返回假." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ClearTask ()
    }

    方法 是否需要退出 <公开 类型 = 逻辑型 注释 = "检查线程任务是否需要尽快退出." 注释 = "  1. 本方法返回真则表示正在销毁线程池,必须尽快结束线程任务;"
            注释 = "  2. 如果未退出死循环中的线程,则线程池资源不会得到释放,线程" 注释 = "也会一直运行下去,直到进程结束;" 折叠 @嵌入式方法 = "">
    参数 最大检查等待时间 <类型 = 整数 注释 = "指定检查线程池销毁通知(由\"销毁\"方法发出)的最大等待时间," 注释 = "单位为毫秒,为0表示不等待,为-1表示一直等待." @默认值 = 0>
    {
        @ @sn<this>.IsNeedExit (@<最大检查等待时间>)
    }

    方法 调整线程池 <公开 类型 = 逻辑型 注释 = "调整线程池的容量(同时工作线程数量)." 注释 = "若新线程数量比原来大,会立即改变工作线程数量;"
            注释 = "若新线程数量比原来小,则需要等之前投递的任务全部完成,才会改变工作线程数量;" 返回值注释 = "返回是否成功调整线程池容量,线程池未创建、正在销毁或正在调整线程池时返回假." 折叠
            @嵌入式方法 = "">
    参数 新线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU核心数 + 1)." @默认值 = 0>
    {
        @ @sn<this>.SetThreadPoolCapacity (@<新线程数量>)
    }

    方法 CPU核心数 <公开 属性读 类型 = 整数 注释 = "获取CPU的逻辑核心数量(如支持超线程的16核CPU,返回32)." 返回值注释 = "成功返回CPU逻辑核心数,失败时始终返回1." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetProcessorsCount ()
    }

    方法 现行线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池当前的工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCount ()
    }

    方法 线程池容量 <公开 属性读 类型 = 整数 注释 = "获取线程池的最大工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCapacity ()
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取正在执行的任务数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWorkerTaskCount ()
    }

    方法 队列任务数 <公开 属性读 类型 = 长整数 注释 = "获取等待处理的任务数量,超过长整数最大值后将从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetQueueTaskCount ()
    }

    方法 已完成任务数 <公开 属性读 类型 = 长整数 注释 = "获取已完成的任务数量,超过长整数最大值后将从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetComplateTaskCount ()
    }

    方法 空闲线程数 <公开 属性读 类型 = 整数 注释 = "获取空闲的线程数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetFreeThreadsCount ()
    }

    方法 工作状态 <公开 属性读 类型 = 整数 注释 = "获取线程池的工作状态" 返回值注释 = "0=未启动;1=正在销毁;2=正在创建;3=正在工作;4=调整线程池;5=暂停中;6=正在清空任务"
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadPoolState ()
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "判断线程池是否处于彻底空闲状态,没有任何任务在执行." 返回值注释 = "真为空闲,假为繁忙,线程池未创建也返回真." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadPoolIsFree ()
    }
}

类 线程对象类 <公开 注释 = "线程对象(std::thread)的封装类" 注释 = "  1. 线程对象不可复制赋值;"
        注释 = "  2. 退出程序时线程对象会被强制结束,不会窗口关掉了还在跑;" 折叠 @文档 = "category = \"多线程\"" @视窗.外部头文件 = "<thread>" @全局类 = 真>
{

    # 全局静态方法 (无需创建类变量,直接调用) ------

    方法 启动静态线程 <公开 静态 注释 = "创建一个与静态方法关联的线程对象,然后立即分离并非阻塞执行线程函数."
            注释 = "  1. 可以关联任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 折叠
            @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ std::thread(&@<静态方法>, @<参数列表>).detach()
    }

    方法 启动无参数静态线程 <公开 静态 注释 = "创建一个与静态方法关联的线程对象,然后立即分离并非阻塞执行线程函数." 注释 = "  1. 只能关联无参数的静态方法;"
            注释 = "  2. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    {
        @ std::thread(&@<静态方法>).detach()
    }

    方法 启动动态线程 <公开 静态 注释 = "创建一个与类实例的动态方法关联的线程对象,然后立即分离并非阻塞执行线程函数."
            注释 = "  1. 可以关联任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;"
            注释 = "  5. 如果关联的对象实例被销毁,线程将异常结束(不影响整个进程的运作);" 注释 = "  6. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;"
            折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数列表的格式务必和所提供动态方法的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ std::thread(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>).detach()
    }

    方法 启动无参数动态线程 <公开 静态 注释 = "创建一个与类实例的动态方法关联的线程对象,然后立即分离并非阻塞执行线程函数." 注释 = "  1. 只能关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 如果关联的对象实例被销毁,线程将异常结束(不影响整个进程的运作);"
            注释 = "  4. 如果需要加锁,应使用\"互斥自动锁\"(std::lock_guard)以避免死锁;" 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ std::thread(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>).detach()
    }

    方法 引用 <公开 静态 注释 = "包装线程对象的参数,将它变成\"引用传递\"(std::ref)." 注释 = "  1. 线程对象默认按值复制参数,包装后线程参数和外部变量"
            注释 = "指向同一个数据,修改后结果互相同步;" 注释 = "  2. 请确保所包装变量的生命周期,不能在线程结束前被释放;" 折叠 @嵌入式方法 = "">
    参数 所欲包装参数 <@匹配类型 = 所有类型 @返回值类型 = 0>
    {
        @ std::ref(@<所欲包装参数>)
    }

    方法 常引用 <公开 静态 注释 = "包装线程对象的参数,将它变成\"常引用传递\"(std::cref)." 注释 = "  1. 线程对象默认按值复制参数,包装后线程参数和外部变量"
            注释 = "指向同一个数据,但线程内不能修改参数值;" 注释 = "  2. 请确保所包装变量的生命周期,不能在线程结束前被释放;"
            注释 = "  3. 火山的方法默认为引用传递,除非你知道如何修改参数的传递" 注释 = "方式,否则不应使用本方法;" 折叠 @嵌入式方法 = "">
    参数 所欲包装参数 <@匹配类型 = 所有类型 @返回值类型 = 0>
    {
        @ std::cref(@<所欲包装参数>)
    }

    方法 让出调度 <公开 静态 注释 = "使当前线程让渡出自己的CPU时间片,由运行态变为就绪态." 注释 = "当前线程什么时候再被调度运行,完全取决于系统的调度."
            注释 = "在低效的死循环中重复调用本方法,可以减少线程占用CPU资源." 折叠 @嵌入式方法 = "">
    {
        @ std::this_thread::yield()
    }

    # 类成员方法(需要创建类变量调用) ------
    # @begin
    # <> <include>
    # std::thread m_thread;
    # inline @sn<current_class> (std::thread& rhs) { m_thread.swap(rhs); }
    # inline @sn<current_class> (std::thread&& rhs) { if (m_thread.joinable()) { m_thread.detach(); } m_thread = std::move(rhs); }
    # inline @sn<current_class>& operator= (@sn<current_class>&& objCopyFrom) { m_thread = std::move(objCopyFrom.m_thread); return *this; }
    # inline void @an<_OnCleanupExtra> () { if (m_thread.joinable()) { m_thread.detach(); } }
    # inline BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return m_thread.get_id() == objCompare.m_thread.get_id(); }
    # <> </include>
    # @end

    方法 关联静态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与静态方法关联,关联后会立即执行线程(有系统调度的延迟)."
            注释 = "  1. 可以关联任意参数和返回值格式的静态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 关联后需要调用\"分离/加入\",以释放线程资源;"
            返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    参数 参数列表 <注释 = "参数表的格式务必和\"静态方法\"的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ [&](std::thread &td)->BOOL {
        @     if (td.joinable()) return FALSE;
        @     td = std::move(std::thread(&@<静态方法>, @<参数列表>));
        @     return TRUE;
        @ } (@sn<this>.m_thread)
    }

    方法 关联动态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与类动态方法关联,关联后会立即执行线程(有系统调度的延迟)."
            注释 = "  1. 可以关联任意参数和返回值格式的类动态方法,同时应提供格式一致的参数列表;" 注释 = "  2. 默认将提交的参数按值复制到线程对象,不需要考虑变量的生命周期;"
            注释 = "  3. 如果需要引用传递参数,请用\"引用\"将参数值包装;" 注释 = "  4. 动态方法可以直接调用类实例的其他动态成员变量和方法;"
            注释 = "  5. 关联后需要调用\"分离/加入\",以释放线程资源;" 返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    参数 参数列表 <注释 = "参数列表的格式务必和所提供动态方法的参数表一致;" 注释 = "默认将提交的参数按值复制.如果想引用传递,请用\"引用\"方法将参数包装." @可扩展 = ""
            @匹配类型 = 通用型>
    {
        @ [&](std::thread &td)->BOOL {
        @     if (td.joinable()) return FALSE;
        @     td = std::move(std::thread(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>, @<参数列表>));
        @     return TRUE;
        @ } (@sn<this>.m_thread)
    }

    方法 关联无参数静态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与无参数的静态方法关联,关联后会立即执行线程(有系统调度的延迟)." 注释 = "  1. 只能关联无参数的静态方法;"
            注释 = "  2. 关联后需要调用\"分离/加入\",以释放线程资源;" 返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 静态方法 <注释 = "提供所欲线程执行的静态方法" @匹配方法 = "">
    {
        @ [&](std::thread &td)->BOOL {
        @     if (td.joinable()) return FALSE;
        @     td = std::move(std::thread(&@<静态方法>));
        @     return TRUE;
        @ } (@sn<this>.m_thread)
    }

    方法 关联无参数动态方法 <公开 类型 = 逻辑型 注释 = "将本线程对象与无参数的类动态方法关联,关联后会立即执行线程(有系统调度的延迟)." 注释 = "  1. 只能关联无参数的类动态方法;"
            注释 = "  2. 动态方法可以直接调用类实例的其他动态成员变量和方法;" 注释 = "  3. 关联后需要调用\"分离/加入\",以释放线程资源;"
            返回值注释 = "返回是否关联成功,如果线程对象不为空将返回假." 折叠 @嵌入式方法 = "">
    参数 对象实例 <类型 = 对象类 注释 = "提供线程函数所属的对象实例(即类变量),也可以填\"本对象\"、\"读指针处对象()\"." "">
    参数 方法输出名 <类型 = 文本型 注释 = "提供所欲线程执行的动态方法输出名." 注释 = "注意: 方法必须设置属性\"@输出名\",并设置\"@强制输出\"以确保被编译."
            @需求类型 = 立即数或常量>
    {
        @ [&](std::thread &td)->BOOL {
        @     if (td.joinable()) return FALSE;
        @     td = std::move(std::thread(&@pdt<对象实例>::@pvpt<方法输出名>, &@<对象实例>));
        @     return TRUE;
        @ } (@sn<this>.m_thread)
    }

    方法 取线程句柄 <公开 类型 = 变整数 注释 = "返回线程对象内部的底层线程句柄,该句柄可以给\"等待多个事件\"或\"WaitForSingleObject\"使用." 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.m_thread.native_handle()
    }

    方法 是否可加入 <公开 类型 = 逻辑型 注释 = "返回当前的线程对象是否可以加入到当前线程(有可执行的线程函数)." 返回值注释 = "返回假表示线程对象是空的" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.m_thread.joinable()
    }

    方法 加入 <公开 类型 = 逻辑型 注释 = "将线程对象加入到当前线程,会阻塞当前线程直到线程执行完毕." 注释 = "  1. 即使线程函数已实际执行完毕,仍需调用本方法;"
            注释 = "  2. 调用后线程对象将释放线程资源,变为空对象;" 返回值注释 = "线程对象为空时将直接返回假" 折叠 @禁止流程检查 = 真>
    {
        @ if (!m_thread.joinable()) return FALSE;
        @ m_thread.join();
        @ return TRUE;
    }

    方法 分离 <公开 类型 = 逻辑型 注释 = "将执行线程从线程对象中分离,成功后会立即返回真." 注释 = "  1. 分离后线程将独立执行,不再受线程对象管理;"
            注释 = "  2. 即使线程函数已实际执行完毕,仍需调用本方法;" 注释 = "  3. 调用后,线程对象将移交资源的所有权,变为空对象;" 返回值注释 = "线程对象为空时将直接返回假" 折叠
            @禁止流程检查 = 真>
    {
        @ if (!m_thread.joinable()) return FALSE;
        @ m_thread.detach();
        @ return TRUE;
    }

    方法 交换 <公开 注释 = "交换两个线程对象的执行线程" 折叠 @嵌入式方法 = "">
    参数 所欲交换的线程对象 <类型 = 线程对象类>
    {
        @ @sn<this>.m_thread.swap(@<所欲交换的线程对象>.m_thread)
    }

    方法 硬件并发数 <公开 属性读 类型 = 整数 注释 = "返回硬件和平台支持的最大并发线程数" 折叠 @嵌入式方法 = "">
    {
        @ (INT)std::thread::hardware_concurrency()
    }
}

类 互斥对象类 <公开 注释 = "互斥锁对象(std::mutex)的封装类" 注释 = "  1. 互斥锁不可复制赋值;" 注释 = "  2. 提供全局方法\"互斥自动锁\",可自动加锁/解锁;"
        折叠 @文档 = "category = \"多线程\"" @视窗.外部头文件 = "<mutex>" @全局类 = 真>
{
    方法 互斥自动锁 <公开 静态 注释 = "创建一个互斥自动锁对象(std::lock_guard),它将接收指定互斥锁的所有权."
            注释 = "创建后会立即在当前线程加锁,直到离开作用域后自动销毁对象并解锁." 注释 = "注: 本方法可以避免死锁,推荐用来替代互斥锁对象的\"加锁/解锁\"操作." 折叠 @嵌入式方法 = "">
    参数 所欲操作互斥锁 <类型 = 互斥对象类 注释 = "提供要在当前线程上锁的互斥锁对象(std::mutex),本方法">
    {
        @ std::lock_guard<std::mutex> @sn<rand_name0>(@<所欲操作互斥锁>)
    }

    # @begin
    # <> <include>
    # std::mutex m_mutex;
    # inline operator std::mutex& () { return m_mutex; }
    # <> </include>
    # @end

    方法 加锁 <公开 注释 = "将本互斥锁加锁,如果本锁当前已经被另一线程锁住,则进入等待状态." 注释 = "注: 建议使用\"互斥自动锁\"以避免死锁." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.m_mutex.lock ()
    }

    方法 尝试加锁 <公开 类型 = 逻辑型 注释 = "尝试将本互斥锁加锁,如果能够成功加锁,则加锁后返回真." 注释 = "如果不能(譬如已经被其它线程锁住)则立即返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.m_mutex.try_lock()
    }

    方法 解锁 <公开 注释 = "如果先前加锁成功,解开此锁,以允许其它线程加锁成功." 注释 = "注: 建议使用\"互斥自动锁\"以避免死锁." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.m_mutex.unlock ()
    }

    方法 取互斥锁句柄 <公开 类型 = 变整数 注释 = "返回互斥锁的底层句柄" 折叠 @嵌入式方法 = "">
    {
        @ (INT_P)@sn<this>.m_mutex.native_handle()
    }
}

# 过时 ===

类 线程池类 <公开 注释 = "(过时)功能强、效率快、高稳定、无内存和句柄泄漏的线程池." 注释 = "  1. 使用高效的ICOP异步模型,队列式执行线程任务;"
        注释 = "  2. 使用Windows API的线程函数,兼容性良好;" 注释 = "  3. 线程的回调函数在\"接收事件\"中执行,可以调用类的动态成员;"
        注释 = "  4. 耗时和死循环的线程必须退出,否则窗口关掉了还在跑;" 折叠 @文档 = "category = \"多线程\"" @视窗.外部头文件 = "src\\piv_thread.hpp"
        @视窗.后缀文本 = "public PivThreadPool">
{
    方法 启动线程 <公开 类型 = 逻辑型 注释 = "  启动一个线程,请在接收事件\"对象任务回调\"中编写回调方法." 注释 = "  本方法不归线程池管理,可独立使用,线程句柄在执行完毕后自动关闭,"
            注释 = "因此每次启动都是一个新线程." 返回值注释 = "成功返回真,失败返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    参数 是否等待线程执行完毕 <类型 = 逻辑型 注释 = "指定本方法是否一直等待线程执行完毕后才会返回" @默认值 = 假>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别" @默认值 = 线程优先级.通常>
    {
        @ return @sn<current_class_def>::StartThread (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadObjWorkerProc), @<用户标记>,
        @                                             @<用户对象>, @<用户数据>, @<是否等待线程执行完毕>, @<初始堆栈大小>, (INT)@<优先级>);
    }

    方法 创建 <公开 类型 = 逻辑型 注释 = "创建线程池,必须成功创建后才能使用其他方法." 返回值注释 = "返回是否创建成功,重复创建亦返回真." 折叠 @嵌入式方法 = "">
    参数 线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU逻辑核心数 + 1)."
            注释 = "  - I/O密集型建议: CPU核数 * (1 + (I/O耗时 / CPU耗时))" 注释 = "  - 计算密集型建议: CPU核数 + 1" @默认值 = 0>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别." @默认值 = 线程优先级.通常>
    参数 是否初始化COM <类型 = 逻辑型 注释 = "  是否在线程池内部自动执行COM初始化和清理." 注释 = "  多线程中使用COM对象必须执行COM初始化,由于本线程池是一个线程队列执行"
            注释 = "多个任务,不太适合在\"任务回调/对象任务回调\"事件中进行初始化.如果你需要" 注释 = "使用COM对象,请将本参数设置为\"真\"." @默认值 = 假>
    {
        @ @sn<this>.CreateThreadPool (@<线程数量>, @<初始堆栈大小>, (INT)@<优先级>, @<是否初始化COM>)
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "销毁线程池,释放线程池占用的所有资源." 注释 = "  1. 销毁线程池不会强制结束仍在运行的线程,请在线程的耗时或"
            注释 = "死循环中调用本对象的方法\"是否需要退出\",一旦发现该方法返回真," 注释 = "必须尽快结束\"任务回调\"/\"对象任务回调\"事件的执行."
            注释 = "  2. 类清理时会自动销毁,如果线程池实例定义在窗口的成员变量中," 注释 = "必须在窗口即将销毁时执行销毁线程池." 返回值注释 = "成功或已经销毁返回真,失败返回假."
            返回值注释 = "失败原因包括: 线程池正在创建或正在销毁." 折叠 @嵌入式方法 = "">
    参数 是否强制销毁 <类型 = 逻辑型 注释 = "假=正常销毁,等待任务执行完毕后返回;" 注释 = "真=强制销毁,不等待执行中的任务,清空后续的队列任务后立即返回." @默认值 = 假>
    参数 最长等待时间 <类型 = 整数 注释 = "此参数只对非强制销毁有效,单位为毫秒." 注释 = "-1为一直等待所有任务完成,否则到了超时时间会清空任务并返回." @默认值 = -1>
    {
        @ @sn<this>.DestroyThreadPool (@<是否强制销毁>, @<最长等待时间>)
    }

    方法 暂停 <公开 类型 = 逻辑型 注释 = "停止执行新的任务,当前正在执行的任务不会被暂停." 返回值注释 = "返回是否暂停成功,线程池的不在工作状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SuspendThreadPool ()
    }

    方法 继续 <公开 类型 = 逻辑型 注释 = "继续执行线程池任务" 返回值注释 = "返回是否继续成功,线程池的不在暂停状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ResumeThreadPool ()
    }

    方法 投递任务 <公开 类型 = 逻辑型 注释 = "投递线程任务到线程池中,投递后请在接收事件\"任务回调\"中编写线程方法." 注释 = "本方法只支持基本数值参数."
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户参数 <类型 = 长整数 @默认值 = 0>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostParamTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolWorkerProc),
        @                                               @<用户标记>, @<用户参数>, @<用户数据>);
    }

    方法 投递对象 <公开 类型 = 逻辑型 注释 = "  投递线程任务到线程池中,投递后请在接收事件\"对象任务回调\"中编写线程方法." 注释 = "本方法支持传递自定义对象类型,但请注意以下几点:"
            注释 = "  1. 会将投递的用户对象复制一份副本,副本的生命周期到回调任务结束后为止," 注释 = "因此可以直接投递局部变量."
            注释 = "  2. 用户对象经过复制,已经不等于原来的对象实例(指针值不一样)." 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostObjectTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolObjWorkerProc),
        @                                                @<用户标记>, @<用户对象>, @<用户数据>);
    }

    方法 清空任务 <公开 类型 = 逻辑型 注释 = "清空已投递的队列任务,将队列任务占用的内存释放." 返回值注释 = "返回是否开始清空任务,线程池不在正常工作和暂停状态时始终返回假." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ClearTask ()
    }

    方法 任务回调 <公开 定义事件 类型 = 整数 注释 = "线程池\"投递任务\"的回调函数,请在本事件内写线程方法." 返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户参数 <类型 = 长整数>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 对象任务回调 <公开 定义事件 类型 = 整数 注释 = "  线程池\"投递对象\"的回调函数,请在本事件内写线程方法." 注释 = "传入的用户对象会在本次任务结束后自动释放."
            返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户对象 <类型 = 对象类 注释 = "  用户投递的自定义对象,请自行强制到原来的对象类型再使用,如:" 注释 = "  1. 对象变量 = (自定义对象)用户对象"
            注释 = "  2. ((自定义对象)用户对象).成员" 注释 = "  方法1会将用户对象强制转换类型后复制到新变量,这会略增加内存的占用;"
            注释 = "  方法2不会创建新的对象实例,但写起来比较麻烦.">
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 是否需要退出 <公开 类型 = 逻辑型 注释 = "检查线程任务是否需要尽快退出." 注释 = "  1. 本方法只能在本对象\"任务回调\"/\"对象任务回调\"事件中执行"
            注释 = "  2. 本方法返回真则表示正在销毁线程池,必须尽快结束线程任务;" 注释 = "  3. 如果线程未及时结束,则线程池乃至程序可能要等线程执行完毕"
            注释 = "才会彻底结束,如果线程内有死循环,可能将永远不会自己结束;" 返回值注释 = "返回线程是否需要尽快退出." 折叠 @嵌入式方法 = "">
    参数 最大检查等待时间 <类型 = 整数 注释 = "指定检查线程池销毁通知(由\"销毁\"方法发出)的最大等待时间," 注释 = "单位为毫秒,为0表示不等待,为-1表示一直等待." @默认值 = 0>
    {
        @ @sn<this>.IsNeedExit (@<最大检查等待时间>)
    }

    方法 调整线程池 <公开 类型 = 逻辑型 注释 = "动态调整线程池的容量(同时工作线程数量)." 注释 = "若新线程数量比原来大,会立即改变工作线程数量;"
            注释 = "若新线程数量比原来小,则需要等之前投递的任务全部完成,才会改变工作线程数量;" 返回值注释 = "返回是否成功调整线程池容量,线程池未创建、正在销毁或正在调整线程池时返回假." 折叠
            @嵌入式方法 = "">
    参数 新线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU核心数 + 1)." @默认值 = 0>
    {
        @ @sn<this>.SetThreadPoolCapacity (@<新线程数量>)
    }

    方法 CPU核心数 <公开 属性读 类型 = 整数 注释 = "获取CPU的逻辑核心数量(如支持超线程的16核CPU,返回32)." 返回值注释 = "成功返回CPU逻辑核心数,失败时始终返回1." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetProcessorsCount ()
    }

    方法 现行线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池当前的工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCount ()
    }

    方法 线程池容量 <公开 属性读 类型 = 整数 注释 = "获取线程池的最大工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCapacity ()
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取正在执行的任务数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWorkerTaskCount ()
    }

    方法 队列任务数 <公开 属性读 类型 = 长整数 注释 = "获取等待处理的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetQueueTaskCount ()
    }

    方法 已完成任务数 <公开 属性读 类型 = 长整数 注释 = "获取已完成的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetComplateTaskCount ()
    }

    方法 空闲线程数 <公开 属性读 类型 = 整数 注释 = "获取空闲的线程数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetFreeThreadsCount ()
    }

    方法 工作状态 <公开 属性读 类型 = 整数 注释 = "获取线程池的工作状态" 返回值注释 = "0=未启动;1=正在销毁;2=正在创建;3=正在工作;4=调整线程池;5=暂停中;6=正在清空任务"
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadPoolState ()
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "判断线程池是否处于彻底空闲状态,没有任何任务在执行." 返回值注释 = "真为空闲,假为繁忙,线程池未创建也返回真." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadPoolIsFree ()
    }

    # ---
    # @begin
    # <> <include>
    # static INT CALLBACK ThreadPoolWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<任务回调> (lpThreadParam->nUserMark, lpThreadParam->lUserParam, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadPoolObjWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadObjWorkerProc (@sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     ((@sn<current_class>*)lpThreadParam->lpThis)->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    #     lpThreadParam->lpUserObj->Destroy();
    #     delete lpThreadParam;
    #     return 0;
    # }
    # <> </include>
    # @end
    # ---
}

类 线程池类EX <公开 注释 = "(过时)带动态调整线程池容量,功能强、效率快、高稳定、无内存和句柄泄漏的线程池." 注释 = "  1. 使用高效的ICOP异步模型,队列式执行线程任务;"
        注释 = "  2. 使用Windows API的线程函数,兼容性良好;" 注释 = "  3. 线程的回调函数在\"接收事件\"中执行,可以调用类的动态成员;"
        注释 = "  4. 耗时和死循环的线程必须退出,否则窗口关掉了还在跑;" 注释 = "  5. 支持按需调节线程池的执行线程数;" 折叠 @文档 = "category = \"多线程\""
        @视窗.外部头文件 = "src\\piv_thread.hpp" @视窗.后缀文本 = "public PivThreadPoolEx">
{
    方法 启动线程 <公开 类型 = 逻辑型 注释 = "  启动一个线程,请在接收事件\"对象任务回调\"中编写回调方法." 注释 = "  本方法不归线程池管理,可独立使用,线程句柄在执行完毕后自动关闭,"
            注释 = "因此每次启动都是一个新线程." 返回值注释 = "成功返回真,失败返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    参数 是否等待线程执行完毕 <类型 = 逻辑型 注释 = "指定本方法是否一直等待线程执行完毕后才会返回" @默认值 = 假>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别" @默认值 = 线程优先级.通常>
    {
        @ return @sn<current_class_def>::StartThread (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadObjWorkerProc), @<用户标记>,
        @                                             @<用户对象>, @<用户数据>, @<是否等待线程执行完毕>, @<初始堆栈大小>, (INT)@<优先级>);
    }

    方法 创建 <公开 类型 = 逻辑型 注释 = "创建线程池,必须成功创建后才能使用其他方法." 返回值注释 = "返回是否创建成功,重复创建亦返回真." 折叠 @嵌入式方法 = "">
    参数 最小线程数 <类型 = 整数 注释 = "最小同时工作的线程数,默认为5,不得小于1." @默认值 = 5>
    参数 最大线程数 <类型 = 整数 注释 = "最大同时工作的线程数量,默认为20.小于等于0为(CPU逻辑核心数 + 1)." 注释 = "无论如何,最终值会自动调整为大于等于(最小线程数+2)."
            @默认值 = 20>
    参数 动态线程周期 <类型 = 整数 注释 = "动态线程的检测周期时间,单位毫秒.默认为5000ms(5秒),最低100ms."
            注释 = "一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数." 注释 = "如果任务过少则自动回收动态线程." @默认值 = 5000>
    参数 初始堆栈大小 <类型 = 整数 注释 = "线程的堆栈初始大小,单位字节." 注释 = "应为内存页大小(一般为4096)的倍数,最小2页,系统会向上舍入到最近的值."
            注释 = "为0表示使用默认堆栈保留尺寸(1MB)." @默认值 = 0>
    参数 优先级 <类型 = 线程优先级 注释 = "提供线程的优先级别." @默认值 = 线程优先级.通常>
    参数 是否初始化COM <类型 = 逻辑型 注释 = "  是否在线程池内部自动执行COM初始化和清理." 注释 = "  多线程中使用COM对象必须执行COM初始化,由于本线程池是一个线程队列执行"
            注释 = "多个任务,不太适合在\"任务回调/对象任务回调\"事件中进行初始化.如果你需要" 注释 = "使用COM对象,请将本参数设置为\"真\"." @默认值 = 假>
    {
        @ @sn<this>.CreateThreadPool (@<最小线程数>, @<最大线程数>, @<动态线程周期>, @<初始堆栈大小>, (INT)@<优先级>, @<是否初始化COM>)
    }

    方法 销毁 <公开 类型 = 逻辑型 注释 = "销毁线程池,释放线程池占用的所有资源." 注释 = "  1. 销毁线程池不会强制结束仍在运行的线程,请在线程的耗时或"
            注释 = "死循环中调用本对象的方法\"是否需要退出\",一旦发现该方法返回真," 注释 = "必须尽快结束\"任务回调\"/\"对象任务回调\"事件的执行."
            注释 = "  2. 类清理时会自动销毁,如果线程池实例定义在窗口的成员变量中," 注释 = "必须在窗口即将销毁时执行销毁线程池." 返回值注释 = "成功或已经销毁返回真,失败返回假."
            返回值注释 = "失败原因包括: 线程池正在创建或正在销毁." 折叠 @嵌入式方法 = "">
    参数 是否强制销毁 <类型 = 逻辑型 注释 = "假=正常销毁,等待任务执行完毕后返回;" 注释 = "真=强制销毁,不等待执行中的任务,清空后续的队列任务后立即返回." @默认值 = 假>
    参数 最长等待时间 <类型 = 整数 注释 = "此参数只对非强制销毁有效,单位为毫秒." 注释 = "-1为一直等待所有任务完成,否则到了超时时间会清空任务并返回." @默认值 = -1>
    {
        @ @sn<this>.DestroyThreadPool (@<是否强制销毁>, @<最长等待时间>)
    }

    方法 暂停 <公开 类型 = 逻辑型 注释 = "停止执行新的任务,当前正在执行的任务不会被暂停." 返回值注释 = "返回是否暂停成功,线程池的不在工作状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.SuspendThreadPool ()
    }

    方法 继续 <公开 类型 = 逻辑型 注释 = "继续执行线程池任务" 返回值注释 = "返回是否继续成功,线程池的不在暂停状态返回假." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.ResumeThreadPool ()
    }

    方法 投递任务 <公开 类型 = 逻辑型 注释 = "投递线程任务到线程池中,投递后请在接收事件\"任务回调\"中编写线程方法." 注释 = "本方法只支持基本数值参数."
            返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户参数 <类型 = 长整数 @默认值 = 0>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostParamTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolWorkerProc),
        @                                               @<用户标记>, @<用户参数>, @<用户数据>);
    }

    方法 投递对象 <公开 类型 = 逻辑型 注释 = "  投递线程任务到线程池中,投递后请在接收事件\"对象任务回调\"中编写线程方法." 注释 = "本方法支持传递自定义对象类型,但请注意以下几点:"
            注释 = "  1. 会将投递的用户对象复制一份副本,副本的生命周期到回调任务结束后为止," 注释 = "因此可以直接投递局部变量."
            注释 = "  2. 用户对象经过复制,已经不等于原来的对象实例(指针值不一样)." 返回值注释 = "返回是否成功投递任务,线程池未创建或正在销毁返回假." 折叠 @禁止流程检查 = 真>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途." @默认值 = 0>
    参数 用户对象 <类型 = 对象类 注释 = "使用自定义的对象类,可以传递使用任意数量和类型的参数给线程池." 注释 = "将创建用户对象的副本,因此可以直接使用局部变量." @默认值 = 空对象>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针,请注意指针引用的变量会不会提前被释放." @默认值 = 0>
    {
        @ return @sn<current_class_def>::PostObjectTask (this, reinterpret_cast<ULONG_PTR>(&@sn<current_class_def>::ThreadPoolObjWorkerProc),
        @                                                @<用户标记>, @<用户对象>, @<用户数据>);
    }

    方法 清空任务 <公开 类型 = 逻辑型 注释 = "清空已投递的队列任务,将队列任务占用的内存释放." 返回值注释 = "返回是否开始清空任务,线程池不在正常工作和暂停状态时始终返回假." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ClearTask ()
    }

    方法 任务回调 <公开 定义事件 类型 = 整数 注释 = "线程池\"投递任务\"的回调函数,请在本事件内写线程方法." 返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户参数 <类型 = 长整数>
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 对象任务回调 <公开 定义事件 类型 = 整数 注释 = "  线程池\"投递对象\"的回调函数,请在本事件内写线程方法." 注释 = "传入的用户对象会在本次任务结束后自动释放."
            返回值注释 = "返回值无意义" 折叠>
    参数 用户标记 <类型 = 整数 注释 = "用户自定义标记值,建议用来区分线程的用途.">
    参数 用户对象 <类型 = 对象类 注释 = "  用户投递的自定义对象,请自行强制到原来的对象类型再使用,如:" 注释 = "  1. 对象变量 = (自定义对象)用户对象"
            注释 = "  2. ((自定义对象)用户对象).成员" 注释 = "  方法1会将用户对象强制转换类型后复制到新变量,这会略增加内存的占用;"
            注释 = "  方法2不会创建新的对象实例,但写起来比较麻烦.">
    参数 用户数据 <类型 = 变整数 注释 = "如果是指针且以后不再使用的话,建议在本事件结束前释放掉,以避免内存泄漏.">

    方法 是否需要退出 <公开 类型 = 逻辑型 注释 = "检查线程任务是否需要尽快退出." 注释 = "  1. 本方法只能在本对象\"任务回调\"/\"对象任务回调\"事件中执行"
            注释 = "  2. 本方法返回真则表示正在销毁线程池,必须尽快结束线程任务;" 注释 = "  3. 如果线程未及时结束,则线程池乃至程序可能要等线程执行完毕"
            注释 = "才会彻底结束,如果线程内有死循环,可能将永远不会自己结束;" 返回值注释 = "返回线程是否需要尽快退出." 折叠 @嵌入式方法 = "">
    参数 最大检查等待时间 <类型 = 整数 注释 = "指定检查线程池销毁通知(由\"销毁\"方法发出)的最大等待时间," 注释 = "单位为毫秒,为0表示不等待,为-1表示一直等待." @默认值 = 0>
    {
        @ @sn<this>.IsNeedExit (@<最大检查等待时间>)
    }

    方法 调整线程池 <公开 类型 = 逻辑型 注释 = "动态调整线程池的容量(同时工作线程数量)." 注释 = "若新线程数量比原来大,会立即改变工作线程数量;"
            注释 = "若新线程数量比原来小,则需要等之前投递的任务全部完成,才会改变工作线程数量;" 返回值注释 = "返回是否成功调整线程池容量,线程池未创建、正在销毁或正在调整线程池时返回假." 折叠
            @嵌入式方法 = "">
    参数 新线程数量 <类型 = 整数 注释 = "最大同时工作的线程数量,小于等于0为(CPU核心数 + 1)." @默认值 = 0>
    {
        @ @sn<this>.SetThreadPoolCapacity (@<新线程数量>)
    }

    方法 CPU核心数 <公开 属性读 类型 = 整数 注释 = "获取CPU的逻辑核心数量(如支持超线程的16核CPU,返回32)." 返回值注释 = "成功返回CPU逻辑核心数,失败时始终返回1." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.GetProcessorsCount ()
    }

    方法 现行线程数 <公开 属性读 类型 = 整数 注释 = "获取线程池当前的工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCount ()
    }

    方法 线程池容量 <公开 属性读 类型 = 整数 注释 = "获取线程池的最大工作线程数" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadsCapacity ()
    }

    方法 执行任务数 <公开 属性读 类型 = 整数 注释 = "获取正在执行的任务数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetWorkerTaskCount ()
    }

    方法 队列任务数 <公开 属性读 类型 = 长整数 注释 = "获取等待处理的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetQueueTaskCount ()
    }

    方法 已完成任务数 <公开 属性读 类型 = 长整数 注释 = "获取已完成的任务数量" 返回值注释 = "超过无符号整数最大值(4294967295)后从0开始重新计数." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetComplateTaskCount ()
    }

    方法 空闲线程数 <公开 属性读 类型 = 整数 注释 = "获取空闲的线程数量" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetFreeThreadsCount ()
    }

    方法 工作状态 <公开 属性读 类型 = 整数 注释 = "获取线程池的工作状态" 返回值注释 = "0=未启动;1=正在销毁;2=正在创建;3=正在工作;4=调整线程池;5=暂停中;6=正在清空任务"
            折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetThreadPoolState ()
    }

    方法 是否空闲 <公开 属性读 类型 = 逻辑型 注释 = "判断线程池是否处于彻底空闲状态,没有任何任务在执行." 返回值注释 = "真为空闲,假为繁忙,线程池未创建也返回真." 折叠
            @嵌入式方法 = "">
    {
        @ @sn<this>.ThreadPoolIsFree ()
    }

    方法 动态线程周期 <公开 属性读 类型 = 整数 注释 = "获取动态调整线程的检测周期(单位毫秒)." 注释 = "一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数."
            注释 = "如果任务过少则自动回收动态线程." 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.GetCycleMs ()
    }

    方法 动态线程周期 <公开 属性写 注释 = "设置动态调整线程的检测周期." 注释 = "一个周期时间后,如果队列任务过多将动态增加工作线程,直到达到最大线程数."
            注释 = "如果任务过少则自动回收动态线程." 折叠>
    参数 新的周期 <类型 = 整数 注释 = "动态线程的检测周期时间,单位毫秒,最低100ms.">
    {
        @ @sn<current_class_def>::SetCycleMs (@<新的周期>);
    }

    # ---
    # @begin
    # <> <include>
    # static INT CALLBACK ThreadPoolWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<任务回调> (lpThreadParam->nUserMark, lpThreadParam->lUserParam, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadPoolObjWorkerProc (@sn<current_class>* pThis, @sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     return pThis->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    # }
    # static INT CALLBACK ThreadObjWorkerProc (@sn<current_class>::THREADPOOL_PARAM* lpThreadParam) {
    #     ((@sn<current_class>*)lpThreadParam->lpThis)->@<对象任务回调> (lpThreadParam->nUserMark, *lpThreadParam->lpUserObj, lpThreadParam->lpUserData);
    #     lpThreadParam->lpUserObj->Destroy();
    #     delete lpThreadParam;
    #     return 0;
    # }
    # <> </include>
    # @end
    # ---
}

#
