<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://toml.io/cn/v1.0.0" 注释 = "TOML v1.0.0"
        注释 = "全称：Tom的(语义)明显、(配置)最小化的语言(Tom\'s Obvious, Minimal Language)."
        注释 = "TOML 旨在成为一个语义明显且易于阅读的最小化配置文件格式." 注释 = "TOML 被设计成可以无歧义地映射为哈希表."
        注释 = "TOML 应该能很容易地被解析成各种语言中的数据结构." @视窗.外部头文件 = "src\\piv_tomlplusplus.hpp"
        @视窗.附加编译参数 = "cpp: /std:c++17" @视窗.需求VS版本 = "15-">

类 TOML键值表 <公开 注释 = "  源码: https://github.com/marzer/tomlplusplus" 注释 = "本模块未封装完成,请勿使用." 折叠
        @文档 = "category = \"配置文件.TOML\"" @别名 = "PivTomlTable">
{

    # 解析

    方法 解析文件 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 文件路径 <类型 = 文本型>
    {
        @ @<所欲操作本对象>.ParseFile (@<文件路径>)
    }

    方法 解析文本 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 配置内容 <类型 = 文本型>
    参数 来源路径 <类型 = 文本型 @默认值 = "">
    {
        @ @<所欲操作本对象>.Parse (@<配置内容>, @<来源路径>)
    }

    方法 解析字节集 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 配置内容 <类型 = 字节集类>
    参数 来源路径 <类型 = 文本型 @默认值 = "">
    {
        @ @<所欲操作本对象>.Parse (@<配置内容>, @<来源路径>)
    }

    # 成员数

    方法 是否为空 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    {
        @ @<所欲操作本对象>.IsEmpty ()
    }

    方法 取成员数 <公开 静态 类型 = 整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    {
        @ @<所欲操作本对象>.GetSize ()
    }

    # 删除

    方法 清空 <公开 静态 类型 = 整数 注释 = "Removes all key-value pairs from the table." 返回值注释 = "返回删除的键值对数量,0或1." 折叠
            @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    {
        @ @<所欲操作本对象>.Clear ()
    }

    方法 删除键 <公开 静态 类型 = 整数 返回值注释 = "返回删除的键值对数量,0或1." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 键名 <类型 = 文本型>
    {
        @ @<所欲操作本对象>.Erase (@<键名>)
    }

    方法 删除空成员 <公开 静态 注释 = "Removes empty child arrays and tables." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 递归删除 <类型 = 逻辑型 注释 = "是否删除子数组和子键值表的自身">
    {
        @ @<所欲操作本对象>.Prune (@<递归删除>)
    }

    # 类型

    方法 是否为同类元素 <公开 静态 类型 = 逻辑型 注释 = "检查节点是否仅包含一种类型的值或元素." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 节点类型 <类型 = TOML节点类型>
    参数 不匹配的首元素 <类型 = TOML节点类 @默认值 = 空对象>
    {
        @ @<所欲操作本对象>.IsHomogeneous (@<节点类型>, @<不匹配的首元素>.node)
    }

    方法 是否为内联表 <公开 静态 类型 = 逻辑型 注释 = "Returns true if this table is an inline table."
            注释 = "Runtime-constructed tables (i.e. those not created"
            注释 = " during parsing) are not inline by default." 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    {
        @ @<所欲操作本对象>.IsInline ()
    }

    # 置入键值

    方法 ""

    #
    # 取键值

    方法 取节点 <公开 静态 类型 = TOML节点类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ @dt<TOML节点类> (@<所欲操作本对象>.Get (@<键名>))
    }

    方法 取文本 <公开 静态 类型 = 文本型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ *PivU2Ws {@<所欲操作本对象>.GetAs<std::string> (@<键名>)}
    }

    方法 取文本U <公开 静态 类型 = 标准文本类U 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ @dt<标准文本类U> {@<所欲操作本对象>.GetAs<std::string> (@<键名>)}
    }

    方法 取整数 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ static_cast<INT>(@<所欲操作本对象>.GetAs<int64_t> (@<键名>))
    }

    方法 取长整数 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetAs<int64_t> (@<键名>)
    }

    方法 取小数 <公开 静态 类型 = 小数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetAs<double> (@<键名>)
    }

    方法 取逻辑值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetAs<bool> (@<键名>)
    }

    方法 取日期 <公开 静态 类型 = TOML日期类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ @dt<TOML日期类> {@<所欲操作本对象>.GetAs<toml::date> (@<键名>)}
    }

    方法 取时间 <公开 静态 类型 = TOML时间类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ @dt<TOML时间类> {@<所欲操作本对象>.GetAs<toml::time> (@<键名>)}
    }

    方法 取日期时间 <公开 静态 类型 = TOML日期时间类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 键名 <@匹配类型 = 通用型>
    {
        @ @dt<TOML日期时间类> {@<所欲操作本对象>.GetAs<toml::date_time> (@<键名>)}
    }

    # 取路径值

    方法 取路径文本 <公开 静态 类型 = 文本型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ *PivU2Ws {@<所欲操作本对象>.GetPathAs<std::string> (@<路径>)}
    }

    方法 取路径文本U <公开 静态 类型 = 标准文本类U 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @dt<标准文本类U> {@<所欲操作本对象>.GetPathAs<std::string> (@<路径>)}
    }

    方法 取路径整数 <公开 静态 类型 = 整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ static_cast<INT>(@<所欲操作本对象>.GetPathAs<int64_t> (@<路径>))
    }

    方法 取路径长整数 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetPathAs<int64_t> (@<路径>)
    }

    方法 取路径小数 <公开 静态 类型 = 小数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetPathAs<double> (@<路径>)
    }

    方法 取路径逻辑值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetPathAs<bool> (@<路径>)
    }

    方法 取路径日期 <公开 静态 类型 = TOML日期类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @dt<TOML日期类> {@<所欲操作本对象>.GetPathAs<toml::date> (@<路径>)}
    }

    方法 取路径时间 <公开 静态 类型 = TOML时间类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @dt<TOML时间类> {@<所欲操作本对象>.GetPathAs<toml::time> (@<路径>)}
    }

    方法 取路径日期时间 <公开 静态 类型 = TOML日期时间类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML键值表>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @dt<TOML日期时间类> {@<所欲操作本对象>.GetPathAs<toml::date_time> (@<路径>)}
    }

    #
    #
    #
}

类 TOML数组类 <注释 = "本模块未封装完成,请勿使用." 折叠 @文档 = "category = \"配置文件.TOML\"">
{

    #
}

类 TOML节点类 <公开 注释 = "本模块未封装完成,请勿使用." 折叠 @文档 = "category = \"配置文件.TOML\"" @别名 = "PivTomlNode">
{
    方法 是否为空 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.IsNull ()
    }

    # 判断节点类型

    方法 取类型 <公开 静态 类型 = TOML节点类型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.Type ()
    }

    方法 是否为键值表 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.Is<toml::table>()
    }

    方法 是否为数组 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.Is<toml::array>()
    }

    方法 是否为文本 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.Is<std::string>()
    }

    方法 是否为整数 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.Is<int64_t>()
    }

    方法 是否为小数 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.Is<double>()
    }

    方法 是否为逻辑型 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.Is<bool>()
    }

    方法 是否为日期 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.Is<toml::date>()
    }

    方法 是否为时间 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.Is<toml::time>()
    }

    方法 是否为日期时间 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.Is<toml::date_time>()
    }

    # 将节点转换到其他类型

    方法 到键值表 <公开 静态 类型 = TOML键值表 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @dt<TOML键值表> {@<所欲操作本对象>.AsTable ()}
    }

    方法 到数组 <公开 静态 类型 = TOML数组类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @dt<TOML数组类> {@<所欲操作本对象>.AsArray ()}
    }

    方法 到文本 <公开 静态 类型 = 文本型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ *PivU2W {@<所欲操作本对象>.As<std::string> ()}
    }

    方法 到文本U <公开 静态 类型 = 标准文本类U 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @dt<标准文本类U> {@<所欲操作本对象>.As<std::string> ()}
    }

    方法 到整数 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ static_cast<INT>(@<所欲操作本对象>.As<int64_t> ())
    }

    方法 到长整数 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.As<int64_t> ()
    }

    方法 到小数 <公开 静态 类型 = 小数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.GetAs<double> ()
    }

    方法 到逻辑 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @<所欲操作本对象>.GAs<bool> ()
    }

    方法 到日期 <公开 静态 类型 = TOML日期类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @dt<TOML日期类> {@<所欲操作本对象>.As<toml::date> ()}
    }

    方法 到时间 <公开 静态 类型 = TOML时间类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @dt<TOML时间类> {@<所欲操作本对象>.As<toml::time> ()}
    }

    方法 到日期时间 <公开 静态 类型 = TOML日期时间类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    {
        @ @dt<TOML日期时间类> {@<所欲操作本对象>.As<toml::date_time> ()}
    }

    # 取路径值

    方法 取路径文本 <公开 静态 类型 = 文本型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ *PivU2Ws {@<所欲操作本对象>.GetPathAs<std::string> (@<路径>)}
    }

    方法 取路径文本U <公开 静态 类型 = 标准文本类U 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @dt<标准文本类U> {@<所欲操作本对象>.GetPathAs<std::string> (@<路径>)}
    }

    方法 取路径整数 <公开 静态 类型 = 整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ static_cast<INT>(@<所欲操作本对象>.GetPathAs<int64_t> (@<路径>))
    }

    方法 取路径长整数 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetPathAs<int64_t> (@<路径>)
    }

    方法 取路径小数 <公开 静态 类型 = 小数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetPathAs<double> (@<路径>)
    }

    方法 取路径逻辑值 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @<所欲操作本对象>.GetPathAs<bool> (@<路径>)
    }

    方法 取路径日期 <公开 静态 类型 = TOML日期类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @dt<TOML日期类> {@<所欲操作本对象>.GetPathAs<toml::date> (@<路径>)}
    }

    方法 取路径时间 <公开 静态 类型 = TOML时间类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @dt<TOML时间类> {@<所欲操作本对象>.GetPathAs<toml::time> (@<路径>)}
    }

    方法 取路径日期时间 <公开 静态 类型 = TOML日期时间类 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML节点类>
    参数 路径 <@匹配类型 = 通用型>
    {
        @ @dt<TOML日期时间类> {@<所欲操作本对象>.GetPathAs<toml::date_time> (@<路径>)}
    }
}

类 TOML日期类 <公开 注释 = "日期时间中的日期部分,表示一整天,不涉及时区偏移" 折叠 @文档 = "category = \"配置文件.TOML.辅助类\""
        @别名 = "PivTomlDate">
{
    方法 创建日期 <公开 静态 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    参数 年 <类型 = 短整数>
    参数 月 <类型 = 字节>
    参数 日 <类型 = 字节>
    {
        @ @<所欲操作本对象>.CreateDate (@<年>, @<月>, @<日>)
    }

    方法 年 <公开 静态 属性读 类型 = 短整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    {
        @ @<所欲操作本对象>.year ()
    }

    方法 月 <公开 静态 属性读 类型 = 字节 注释 = "1 - 12" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    {
        @ @<所欲操作本对象>.month ()
    }

    方法 日 <公开 静态 属性读 类型 = 字节 注释 = "1 - 31" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    {
        @ @<所欲操作本对象>.day ()
    }

    方法 置时间 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    参数 日期时间值 <类型 = 小数>
    {
        @ @<所欲操作本对象>.SetVariantTime (@<日期时间值>)
    }

    方法 置时间戳 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    参数 秒时间戳 <类型 = 长整数>
    {
        @ @<所欲操作本对象>.SetTimestamp (@<秒时间戳>)
    }

    方法 到时间 <公开 静态 类型 = 小数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    {
        @ @<所欲操作本对象>.ToVariantTime ()
    }

    方法 到文本 <公开 静态 类型 = 文本型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    {
        @ @<所欲操作本对象>.ToVolString ()
    }

    方法 到文本U <公开 静态 类型 = 标准文本类U 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    {
        @ @dt<标准文本类U> {@<所欲操作本对象>.ToString ()}
    }

    方法 到时间戳 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    {
        @ @<所欲操作本对象>.ToTimestamp ()
    }

    # 比较

    方法 是否相等 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    参数 所欲比较对象 <类型 = TOML日期类>
    {
        @ @<所欲操作本对象>.date == @<所欲比较对象>.date
    }

    方法 是否大于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    参数 所欲比较对象 <类型 = TOML日期类>
    {
        @ @<所欲操作本对象>.date > @<所欲比较对象>.date
    }

    方法 是否大于等于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    参数 所欲比较对象 <类型 = TOML日期类>
    {
        @ @<所欲操作本对象>.date >= @<所欲比较对象>.date
    }

    方法 是否小于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    参数 所欲比较对象 <类型 = TOML日期类>
    {
        @ @<所欲操作本对象>.date < @<所欲比较对象>.date
    }

    方法 是否小于等于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期类>
    参数 所欲比较对象 <类型 = TOML日期类>
    {
        @ @<所欲操作本对象>.date <= @<所欲比较对象>.date
    }
}

类 TOML时间类 <公开 注释 = "  日期时间中的时间部分,只表示一天之中的那个时间," 注释 = "与任何特定的日期无关、亦不涉及时区偏移." 折叠
        @文档 = "category = \"配置文件.TOML.辅助类\"" @别名 = "PivTomlTime">
{
    方法 创建时间 <公开 静态 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    参数 时 <类型 = 字节>
    参数 分 <类型 = 字节>
    参数 秒 <类型 = 字节>
    参数 纳秒 <类型 = 整数 @默认值 = 0>
    {
        @ @<所欲操作本对象>.CreateTime (@<时>, @<分>, @<秒>, @<纳秒>)
    }

    方法 时 <公开 静态 属性读 类型 = 字节 注释 = "0-23" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    {
        @ @<所欲操作本对象>.hour ()
    }

    方法 分 <公开 静态 属性读 类型 = 字节 注释 = "0-59" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    {
        @ @<所欲操作本对象>.minute ()
    }

    方法 秒 <公开 静态 属性读 类型 = 字节 注释 = "0-59" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    {
        @ @<所欲操作本对象>.second ()
    }

    方法 纳秒 <公开 静态 属性读 类型 = 整数 返回值注释 = "0-1000000000" 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    {
        @ @<所欲操作本对象>.nanosecond ()
    }

    方法 置时间 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    参数 日期时间值 <类型 = 小数>
    {
        @ @<所欲操作本对象>.SetVariantTime (@<日期时间值>)
    }

    方法 置时间戳 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    参数 秒时间戳 <类型 = 长整数>
    {
        @ @<所欲操作本对象>.SetTimestamp (@<秒时间戳>)
    }

    方法 到时间 <公开 静态 类型 = 小数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    {
        @ @<所欲操作本对象>.ToVariantTime ()
    }

    方法 到文本 <公开 静态 类型 = 文本型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    {
        @ @<所欲操作本对象>.ToVolString ()
    }

    方法 到文本U <公开 静态 类型 = 标准文本类U 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    {
        @ @dt<标准文本类U> {@<所欲操作本对象>.ToString ()}
    }

    # 比较

    方法 是否相等 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    参数 所欲比较对象 <类型 = TOML时间类>
    {
        @ @<所欲操作本对象>.time == @<所欲比较对象>.time
    }

    方法 是否大于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    参数 所欲比较对象 <类型 = TOML时间类>
    {
        @ @<所欲操作本对象>.time > @<所欲比较对象>.time
    }

    方法 是否大于等于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    参数 所欲比较对象 <类型 = TOML时间类>
    {
        @ @<所欲操作本对象>.time >= @<所欲比较对象>.time
    }

    方法 是否小于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    参数 所欲比较对象 <类型 = TOML时间类>
    {
        @ @<所欲操作本对象>.time < @<所欲比较对象>.time
    }

    方法 是否小于等于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML时间类>
    参数 所欲比较对象 <类型 = TOML时间类>
    {
        @ @<所欲操作本对象>.time <= @<所欲比较对象>.time
    }
}

类 TOML日期时间类 <公开 注释 = "完整的日期时间,可以指定或省略时区偏移量" 折叠 @文档 = "category = \"配置文件.TOML.辅助类\""
        @别名 = "PivTomlDateTime">
{
    方法 创建日期时间 <公开 静态 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    参数 年 <类型 = 短整数>
    参数 月 <类型 = 字节>
    参数 日 <类型 = 字节>
    参数 时 <类型 = 字节>
    参数 分 <类型 = 字节>
    参数 秒 <类型 = 字节>
    参数 纳秒 <类型 = 整数 @默认值 = 0>
    参数 时区偏移 <类型 = 短整数 @默认值 = 0>
    {
        @ @<所欲操作本对象>.CreateDateTime (@<年>, @<月>, @<日>, @<时>, @<分>, @<秒>, @<纳秒>, @<时区偏移>)
    }

    方法 取日期部分 <公开 静态 类型 = TOML日期类 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    {
        @ @dt<TOML日期类> {@<所欲操作本对象>.GetDate ()}
    }

    方法 取时间部分 <公开 静态 类型 = TOML时间类 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    {
        @ @dt<TOML时间类> {@<所欲操作本对象>.GetTime ()}
    }

    方法 是否为本地 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    {
        @ @<所欲操作本对象>.IsLocal ()
    }

    方法 置时间 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    参数 日期时间值 <类型 = 小数>
    {
        @ @<所欲操作本对象>.SetVariantTime (@<日期时间值>)
    }

    方法 置时间戳 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    参数 秒时间戳 <类型 = 长整数>
    {
        @ @<所欲操作本对象>.SetTimestamp (@<秒时间戳>)
    }

    方法 置毫秒时间戳 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    参数 毫秒时间戳 <类型 = 长整数>
    {
        @ @<所欲操作本对象>.SetMsTimestamp (@<毫秒时间戳>)
    }

    方法 到时间 <公开 静态 类型 = 小数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    {
        @ @<所欲操作本对象>.ToVariantTime ()
    }

    方法 到文本 <公开 静态 类型 = 文本型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    {
        @ @<所欲操作本对象>.ToVolString ()
    }

    方法 到文本U <公开 静态 类型 = 标准文本类U 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    {
        @ @dt<标准文本类U> {@<所欲操作本对象>.ToString ()}
    }

    方法 到时间戳 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    {
        @ @<所欲操作本对象>.ToTimestamp ()
    }

    方法 到毫秒时间戳 <公开 静态 类型 = 长整数 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    {
        @ @<所欲操作本对象>.ToMsTimestamp ()
    }

    # 比较

    方法 是否相等 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    参数 所欲比较对象 <类型 = TOML日期时间类>
    {
        @ @<所欲操作本对象>.date_time == @<所欲比较对象>.date_time
    }

    方法 是否大于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    参数 所欲比较对象 <类型 = TOML日期时间类>
    {
        @ @<所欲操作本对象>.date_time > @<所欲比较对象>.date_time
    }

    方法 是否大于等于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    参数 所欲比较对象 <类型 = TOML日期时间类>
    {
        @ @<所欲操作本对象>.date_time >= @<所欲比较对象>.date_time
    }

    方法 是否小于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    参数 所欲比较对象 <类型 = TOML日期时间类>
    {
        @ @<所欲操作本对象>.date_time < @<所欲比较对象>.date_time
    }

    方法 是否小于等于 <公开 静态 类型 = 逻辑型 折叠 @嵌入式方法 = "">
    参数 所欲操作本对象 <类型 = TOML日期时间类>
    参数 所欲比较对象 <类型 = TOML日期时间类>
    {
        @ @<所欲操作本对象>.date_time <= @<所欲比较对象>.date_time
    }
}

类 TOML节点类型 <公开 注释 = "本模块未封装完成,请勿使用." 折叠 @文档 = "category = \"配置文件.TOML.辅助类\"" @常量类 = 字节>
{
    常量 未知 <公开 值 = @"@(S_BYTE)toml::node_type::none" 注释 = "不是一个TOML节点">
    常量 键值表 <公开 值 = @"@(S_BYTE)toml::node_type::table" 注释 = "键值表(也被称为哈希表或字典)是键值对的集合">
    常量 数组 <公开 值 = @"@(S_BYTE)toml::node_type::array" 注释 = "toml::array">
    常量 字符串 <公开 值 = @"@(S_BYTE)toml::node_type::string" 注释 = "共有四种方式来表示字符串：基本字符串、多行基本字符串、字面量和多行字面量."
            注释 = "所有字符串都只能包含有效的UTF-8字符.">
    常量 整型 <公开 值 = @"@(S_BYTE)toml::node_type::integer" 注释 = "有符号整型数,最大8字节,负数的前缀是减号.">
    常量 浮点数 <公开 值 = @"@(S_BYTE)toml::node_type::floating_point" 注释 = "双精度浮点数(8字节)">
    常量 布尔值 <公开 值 = @"@(S_BYTE)toml::node_type::boolean" 注释 = "逻辑布尔值(1字节),必须是小写的true或false">
    常量 日期 <公开 值 = @"@(S_BYTE)toml::node_type::date" 注释 = "日期时间中的日期部分,表示一整天,不涉及时区偏移">
    常量 时间 <公开 值 = @"@(S_BYTE)toml::node_type::time" 注释 = "日期时间中的时间部分,只表示一天之中的那个时间,与任何特定的日期无关、亦不涉及时区偏移.">
    常量 日期时间 <公开 值 = @"@(S_BYTE)toml::node_type::date_time" 注释 = "完整的日期时间,可以指定或省略时区偏移量">
}

#
