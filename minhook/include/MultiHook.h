/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

// buffer.h

// Size of each memory slot.
#if defined(_M_X64) || defined(__x86_64__)
    #define MEMORY_SLOT_SIZE 64
#else
    #define MEMORY_SLOT_SIZE 64
#endif

VOID   InitializeBuffer(VOID);
VOID   UninitializeBuffer(VOID);
LPVOID AllocateBuffer(LPVOID pOrigin);
VOID   FreeBuffer(LPVOID pBuffer);
BOOL   IsExecutableAddress(LPVOID pAddress);


#include <stdint.h>
#include <string.h>

#if defined(_M_X64) || defined(__x86_64__)
    // hde/hde64.h
    #define F_MODRM         0x00000001
    #define F_SIB           0x00000002
    #define F_IMM8          0x00000004
    #define F_IMM16         0x00000008
    #define F_IMM32         0x00000010
    #define F_IMM64         0x00000020
    #define F_DISP8         0x00000040
    #define F_DISP16        0x00000080
    #define F_DISP32        0x00000100
    #define F_RELATIVE      0x00000200
    #define F_ERROR         0x00001000
    #define F_ERROR_OPCODE  0x00002000
    #define F_ERROR_LENGTH  0x00004000
    #define F_ERROR_LOCK    0x00008000
    #define F_ERROR_OPERAND 0x00010000
    #define F_PREFIX_REPNZ  0x01000000
    #define F_PREFIX_REPX   0x02000000
    #define F_PREFIX_REP    0x03000000
    #define F_PREFIX_66     0x04000000
    #define F_PREFIX_67     0x08000000
    #define F_PREFIX_LOCK   0x10000000
    #define F_PREFIX_SEG    0x20000000
    #define F_PREFIX_REX    0x40000000
    #define F_PREFIX_ANY    0x7f000000

    #define PREFIX_SEGMENT_CS   0x2e
    #define PREFIX_SEGMENT_SS   0x36
    #define PREFIX_SEGMENT_DS   0x3e
    #define PREFIX_SEGMENT_ES   0x26
    #define PREFIX_SEGMENT_FS   0x64
    #define PREFIX_SEGMENT_GS   0x65
    #define PREFIX_LOCK         0xf0
    #define PREFIX_REPNZ        0xf2
    #define PREFIX_REPX         0xf3
    #define PREFIX_OPERAND_SIZE 0x66
    #define PREFIX_ADDRESS_SIZE 0x67

    #pragma pack(push,1)

    typedef struct {
        uint8_t len;
        uint8_t p_rep;
        uint8_t p_lock;
        uint8_t p_seg;
        uint8_t p_66;
        uint8_t p_67;
        uint8_t rex;
        uint8_t rex_w;
        uint8_t rex_r;
        uint8_t rex_x;
        uint8_t rex_b;
        uint8_t opcode;
        uint8_t opcode2;
        uint8_t modrm;
        uint8_t modrm_mod;
        uint8_t modrm_reg;
        uint8_t modrm_rm;
        uint8_t sib;
        uint8_t sib_scale;
        uint8_t sib_index;
        uint8_t sib_base;
        union {
            uint8_t imm8;
            uint16_t imm16;
            uint32_t imm32;
            uint64_t imm64;
        } imm;
        union {
            uint8_t disp8;
            uint16_t disp16;
            uint32_t disp32;
        } disp;
        uint32_t flags;
    } hde64s;

    #pragma pack(pop)

    #ifdef __cplusplus
    extern "C" {
    #endif

    /* __cdecl */
    unsigned int hde64_disasm(const void *code, hde64s *hs);

    #ifdef __cplusplus
    }
    #endif


    // table64.h
    #define C_NONE    0x00
    #define C_MODRM   0x01
    #define C_IMM8    0x02
    #define C_IMM16   0x04
    #define C_IMM_P66 0x10
    #define C_REL8    0x20
    #define C_REL32   0x40
    #define C_GROUP   0x80
    #define C_ERROR   0xff

    #define PRE_ANY  0x00
    #define PRE_NONE 0x01
    #define PRE_F2   0x02
    #define PRE_F3   0x04
    #define PRE_66   0x08
    #define PRE_67   0x10
    #define PRE_LOCK 0x20
    #define PRE_SEG  0x40
    #define PRE_ALL  0xff

    #define DELTA_OPCODES      0x4a
    #define DELTA_FPU_REG      0xfd
    #define DELTA_FPU_MODRM    0x104
    #define DELTA_PREFIXES     0x13c
    #define DELTA_OP_LOCK_OK   0x1ae
    #define DELTA_OP2_LOCK_OK  0x1c6
    #define DELTA_OP_ONLY_MEM  0x1d8
    #define DELTA_OP2_ONLY_MEM 0x1e7

    unsigned char hde64_table[] = {
    0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
    0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
    0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
    0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
    0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
    0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
    0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
    0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
    0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
    0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
    0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
    0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
    0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
    0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
    0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
    0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
    0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
    0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
    0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
    0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
    0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
    0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
    0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
    0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
    0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
    0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
    0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
    0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
    0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
    0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
    0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
    0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
    0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
    0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
    0x00,0xf0,0x02,0x00
    };

#else
    // hde/hde32.h
    #define F_MODRM         0x00000001
    #define F_SIB           0x00000002
    #define F_IMM8          0x00000004
    #define F_IMM16         0x00000008
    #define F_IMM32         0x00000010
    #define F_DISP8         0x00000020
    #define F_DISP16        0x00000040
    #define F_DISP32        0x00000080
    #define F_RELATIVE      0x00000100
    #define F_2IMM16        0x00000800
    #define F_ERROR         0x00001000
    #define F_ERROR_OPCODE  0x00002000
    #define F_ERROR_LENGTH  0x00004000
    #define F_ERROR_LOCK    0x00008000
    #define F_ERROR_OPERAND 0x00010000
    #define F_PREFIX_REPNZ  0x01000000
    #define F_PREFIX_REPX   0x02000000
    #define F_PREFIX_REP    0x03000000
    #define F_PREFIX_66     0x04000000
    #define F_PREFIX_67     0x08000000
    #define F_PREFIX_LOCK   0x10000000
    #define F_PREFIX_SEG    0x20000000
    #define F_PREFIX_ANY    0x3f000000

    #define PREFIX_SEGMENT_CS   0x2e
    #define PREFIX_SEGMENT_SS   0x36
    #define PREFIX_SEGMENT_DS   0x3e
    #define PREFIX_SEGMENT_ES   0x26
    #define PREFIX_SEGMENT_FS   0x64
    #define PREFIX_SEGMENT_GS   0x65
    #define PREFIX_LOCK         0xf0
    #define PREFIX_REPNZ        0xf2
    #define PREFIX_REPX         0xf3
    #define PREFIX_OPERAND_SIZE 0x66
    #define PREFIX_ADDRESS_SIZE 0x67

    #pragma pack(push,1)

    typedef struct {
        uint8_t len;
        uint8_t p_rep;
        uint8_t p_lock;
        uint8_t p_seg;
        uint8_t p_66;
        uint8_t p_67;
        uint8_t opcode;
        uint8_t opcode2;
        uint8_t modrm;
        uint8_t modrm_mod;
        uint8_t modrm_reg;
        uint8_t modrm_rm;
        uint8_t sib;
        uint8_t sib_scale;
        uint8_t sib_index;
        uint8_t sib_base;
        union {
            uint8_t imm8;
            uint16_t imm16;
            uint32_t imm32;
        } imm;
        union {
            uint8_t disp8;
            uint16_t disp16;
            uint32_t disp32;
        } disp;
        uint32_t flags;
    } hde32s;

    #pragma pack(pop)

    #ifdef __cplusplus
    extern "C" {
    #endif

    /* __cdecl */
    unsigned int hde32_disasm(const void *code, hde32s *hs);

    #ifdef __cplusplus
    }
    #endif


    // table32.h

    #define C_NONE    0x00
    #define C_MODRM   0x01
    #define C_IMM8    0x02
    #define C_IMM16   0x04
    #define C_IMM_P66 0x10
    #define C_REL8    0x20
    #define C_REL32   0x40
    #define C_GROUP   0x80
    #define C_ERROR   0xff

    #define PRE_ANY  0x00
    #define PRE_NONE 0x01
    #define PRE_F2   0x02
    #define PRE_F3   0x04
    #define PRE_66   0x08
    #define PRE_67   0x10
    #define PRE_LOCK 0x20
    #define PRE_SEG  0x40
    #define PRE_ALL  0xff

    #define DELTA_OPCODES      0x4a
    #define DELTA_FPU_REG      0xf1
    #define DELTA_FPU_MODRM    0xf8
    #define DELTA_PREFIXES     0x130
    #define DELTA_OP_LOCK_OK   0x1a1
    #define DELTA_OP2_LOCK_OK  0x1b9
    #define DELTA_OP_ONLY_MEM  0x1cb
    #define DELTA_OP2_ONLY_MEM 0x1da

    unsigned char hde32_table[] = {
    0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,
    0xa8,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xac,0xaa,0xb2,0xaa,0x9f,0x9f,
    0x9f,0x9f,0xb5,0xa3,0xa3,0xa4,0xaa,0xaa,0xba,0xaa,0x96,0xaa,0xa8,0xaa,0xc3,
    0xc3,0x96,0x96,0xb7,0xae,0xd6,0xbd,0xa3,0xc5,0xa3,0xa3,0x9f,0xc3,0x9c,0xaa,
    0xaa,0xac,0xaa,0xbf,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0x90,
    0x82,0x7d,0x97,0x59,0x59,0x59,0x59,0x59,0x7f,0x59,0x59,0x60,0x7d,0x7f,0x7f,
    0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x9a,0x88,0x7d,
    0x59,0x50,0x50,0x50,0x50,0x59,0x59,0x59,0x59,0x61,0x94,0x61,0x9e,0x59,0x59,
    0x85,0x59,0x92,0xa3,0x60,0x60,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,
    0x59,0x59,0x9f,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xcc,0x01,0xbc,0x03,0xf0,
    0x10,0x10,0x10,0x10,0x50,0x50,0x50,0x50,0x14,0x20,0x20,0x20,0x20,0x01,0x01,
    0x01,0x01,0xc4,0x02,0x10,0x00,0x00,0x00,0x00,0x01,0x01,0xc0,0xc2,0x10,0x11,
    0x02,0x03,0x11,0x03,0x03,0x04,0x00,0x00,0x14,0x00,0x02,0x00,0x00,0xc6,0xc8,
    0x02,0x02,0x02,0x02,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xca,
    0x01,0x01,0x01,0x00,0x06,0x00,0x04,0x00,0xc0,0xc2,0x01,0x01,0x03,0x01,0xff,
    0xff,0x01,0x00,0x03,0xc4,0xc4,0xc6,0x03,0x01,0x01,0x01,0xff,0x03,0x03,0x03,
    0xc8,0x40,0x00,0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,
    0x00,0x00,0x00,0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,
    0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0xff,0xff,0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x7f,0x00,0x00,0xff,0x4a,0x4a,0x4a,0x4a,0x4b,0x52,0x4a,0x4a,0x4a,0x4a,0x4f,
    0x4c,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x55,0x45,0x40,0x4a,0x4a,0x4a,
    0x45,0x59,0x4d,0x46,0x4a,0x5d,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
    0x4a,0x4a,0x4a,0x4a,0x4a,0x61,0x63,0x67,0x4e,0x4a,0x4a,0x6b,0x6d,0x4a,0x4a,
    0x45,0x6d,0x4a,0x4a,0x44,0x45,0x4a,0x4a,0x00,0x00,0x00,0x02,0x0d,0x06,0x06,
    0x06,0x06,0x0e,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x00,0x06,0x06,0x02,0x06,
    0x00,0x0a,0x0a,0x07,0x07,0x06,0x02,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
    0x04,0x04,0x00,0x00,0x00,0x0e,0x05,0x06,0x06,0x06,0x01,0x06,0x00,0x00,0x08,
    0x00,0x10,0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,
    0x86,0x00,0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,
    0xf8,0xbb,0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,
    0xc4,0xff,0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,
    0x13,0x09,0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,
    0xb2,0xff,0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,
    0xe7,0x08,0x00,0xf0,0x02,0x00
    };
#endif


// trampoline.h

#pragma pack(push, 1)

// Structs for writing x86/x64 instructions.

// 8-bit relative jump.
typedef struct _JMP_REL_SHORT
{
    UINT8  opcode;      // EB xx: JMP +2+xx
    UINT8  operand;     // Relative destination address
} JMP_REL_SHORT, *PJMP_REL_SHORT;

// 32-bit direct relative jump/call.
typedef struct _JMP_REL
{
    UINT8  opcode;      // E9/E8 xxxxxxxx: JMP/CALL +5+xxxxxxxx
    UINT32 operand;     // Relative destination address
} JMP_REL, *PJMP_REL, CALL_REL;

// 64-bit indirect absolute jump.
typedef struct _JMP_ABS
{
    UINT8  opcode0;     // FF25 00000000: JMP [+6]
    UINT8  opcode1;
    UINT32 dummy;
    UINT64 address;     // Absolute destination address
} JMP_ABS, *PJMP_ABS;

// 64-bit indirect absolute call.
typedef struct _CALL_ABS
{
    UINT8  opcode0;     // FF15 00000002: CALL [+6]
    UINT8  opcode1;
    UINT32 dummy0;
    UINT8  dummy1;      // EB 08:         JMP +10
    UINT8  dummy2;
    UINT64 address;     // Absolute destination address
} CALL_ABS;

// 32-bit direct relative conditional jumps.
typedef struct _JCC_REL
{
    UINT8  opcode0;     // 0F8* xxxxxxxx: J** +6+xxxxxxxx
    UINT8  opcode1;
    UINT32 operand;     // Relative destination address
} JCC_REL;

// 64bit indirect absolute conditional jumps that x64 lacks.
typedef struct _JCC_ABS
{
    UINT8  opcode;      // 7* 0E:         J** +16
    UINT8  dummy0;
    UINT8  dummy1;      // FF25 00000000: JMP [+6]
    UINT8  dummy2;
    UINT32 dummy3;
    UINT64 address;     // Absolute destination address
} JCC_ABS;

#pragma pack(pop)

#if defined(_M_X64) || defined(__x86_64__)
    typedef JMP_ABS  JMP_RELAY;
    typedef PJMP_ABS PJMP_RELAY;
#else
    typedef JMP_REL  JMP_RELAY;
    typedef PJMP_REL PJMP_RELAY;
#endif

typedef struct _TRAMPOLINE
{
    LPVOID pTarget;         // [In] Address of the target function.
    LPVOID pTrampoline;     // [In] Buffer address for the trampoline function.
    UINT   trampolineSize;  // [In] The size of the trampoline function buffer.

    BOOL   patchAbove;      // [Out] Should use the hot patch area?
    UINT   nIP;             // [Out] Number of the instruction boundaries.
    UINT8  oldIPs[8];       // [Out] Instruction boundaries of the target function.
    UINT8  newIPs[8];       // [Out] Instruction boundaries of the trampoline function.
} TRAMPOLINE, *PTRAMPOLINE;

VOID CreateRelayFunction(PJMP_RELAY pJmpRelay, LPVOID pDetour);
BOOL CreateTrampolineFunction(PTRAMPOLINE ct);

