<火山程序 类型 = "通常" 版本 = 1 />

包 火山.PIV基础类 <注释 = "https://github.com/SaierMe/piv" "">

类 标准调用类 <公开 注释 = "封装作者: kyozy" 注释 = "std::functional" 折叠 @文档 = "category = \"标准库\""
        @视窗.外部头文件 = "<functional>" @禁止创建对象 = 真>
{
    方法 引用 <公开 静态 类型 = 变整数 注释 = "std::ref" 注释 = "返回值是假的,不要用变量接收,只能直接传递给\"标准调用类.调用方法 ()\"的参数." 折叠
            @嵌入式方法 = "">
    参数 对象 <@匹配类型 = 所有类型>
    {
        @ std::ref (@<对象>)
    }

    方法 常引用 <公开 静态 类型 = 变整数 注释 = "std::cref" 注释 = "返回值是假的,不要用变量接收,只能直接传递给\"标准调用类.调用方法 ()\"的参数" 折叠
            @嵌入式方法 = "">
    参数 对象 <@匹配类型 = 所有类型>
    {
        @ std::cref (@<对象>)
    }

    方法 调用方法 <公开 静态 折叠 @嵌入式方法 = "">
    参数 方法 <@匹配方法 = "">
    参数 返回值类型 <折叠2 @匹配类型 = 通用型 @需求类型 = 数据类型 @返回值类型 = 0>
    参数 数据 <折叠2 @匹配类型 = 通用型 @可扩展 = "">
    {
        @ std::bind<@<返回值类型>> (@<方法>, @<数据>) ()
    }

    方法 调用方法无返回 <公开 静态 折叠 @嵌入式方法 = "">
    参数 方法 <@匹配方法 = "">
    参数 数据 <折叠2 @匹配类型 = 通用型 @可扩展 = "">
    {
        @ std::bind (@<方法>, @<数据>) ()
    }

    方法 调用方法无参数 <公开 静态 折叠 @嵌入式方法 = "">
    参数 方法 <@匹配方法 = "">
    参数 返回值类型 <折叠2 @匹配类型 = 通用型 @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ std::bind<@<返回值类型>> (@<方法>) ()
    }

    方法 调用方法无参数及无返回 <公开 静态 折叠 @嵌入式方法 = "">
    参数 方法 <@匹配方法 = "">
    {
        @ std::bind (@<方法>) ()
    }

    方法 调用函数指针 <公开 静态 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 "">
    参数 返回值类型 <折叠2 @匹配类型 = 通用型 @需求类型 = 数据类型 @返回值类型 = 0>
    参数 数据 <折叠2 @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @sn<current_class_def>::pivCallPtr<@<返回值类型>> (reinterpret_cast<void*>(@<函数指针>), @<数据>)
    }

    方法 调用函数指针无返回 <公开 静态 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 "">
    参数 数据 <折叠2 @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @sn<current_class_def>::pivCallPtr<void> (reinterpret_cast<void*>(@<函数指针>), @<数据>)
    }

    方法 调用函数指针无参数 <公开 静态 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 "">
    参数 返回值类型 <折叠2 @匹配类型 = 通用型 @需求类型 = 数据类型 @返回值类型 = 0>
    {
        @ @sn<current_class_def>::pivCallPtr<@<返回值类型>>(reinterpret_cast<void*>(@<函数指针>))
    }

    方法 调用函数指针无参数及无返回 <公开 静态 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 "">
    {
        @ @sn<current_class_def>::pivCallPtr<void>(reinterpret_cast<void*>(@<函数指针>))
    }

    方法 调用函数指针无返回stdcall <公开 静态 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 "">
    参数 数据 <折叠2 @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @sn<current_class_def>::pivCallPtrStdCall<void> (reinterpret_cast<void*>(@<函数指针>), @<数据>)
    }

    方法 调用函数指针stdcall <公开 静态 折叠 @嵌入式方法 = "">
    参数 函数指针 <类型 = 变整数 "">
    参数 返回值类型 <折叠2 @匹配类型 = 通用型 @需求类型 = 数据类型 @返回值类型 = 0>
    参数 数据 <折叠2 @匹配类型 = 通用型 @可扩展 = "">
    {
        @ @sn<current_class_def>::pivCallPtrStdCall<@<返回值类型>> (reinterpret_cast<void*>(@<函数指针>), @<数据>)
    }

    # @begin
    # <> <include>
    #     template<class _R>
    #     static _R pivCallPtr (void* pFunc)
    #     {
    #         return std::bind<_R>((_R (*)(void))pFunc)();
    #     }
    #     template<class _R, class... _Args>
    #     static _R pivCallPtr (void* pFunc, _Args... args)
    #     {
    #         return std::bind<_R>((_R (*)(_Args...))pFunc, args...)();
    #     }
    #     template<class _R, class... _Args>
    #     static _R pivCallPtrStdCall (void* pFunc, _Args... args)
    #     {
    #         return ((_R (__stdcall *)(_Args...))pFunc)(args...);
    #     }
    # <> </include>
    # @end
}

# 集合容器 基本操作 ====

类 标准集合操作类 <基础类 = 扩展对象类 注释 = "封装了集合容器的基本操作,请勿直接使用本类." 注释 = "  模板类型1: 集合的键类型" 折叠
        @文档 = "category = \"数据处理.基础模板类\"" @模板基础类 = 真>
{
    方法 插入 <公开 类型 = 逻辑型 注释 = "插入一个值进集合中" 返回值注释 = "如果所指定值已经存在返回假,否则返回真." 折叠 @嵌入式方法 = "">
    参数 所欲插入的值 <类型 = 模板类型1>
    {
        @ @sn<this>.data().insert (@<所欲插入的值>).second
    }

    方法 取成员数 <公开 类型 = 整数 注释 = "返回本集合中已有成员的数目" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().size ())
    }

    方法 是否存在 <公开 类型 = 逻辑型 注释 = "返回所指定的值是否已经存在" 折叠 @禁止流程检查 = 真>
    参数 所欲检查的值 <类型 = 模板类型1>
    {
        @ return (data().find (@<所欲检查的值>) != data().end ());
    }

    方法 删除 <公开 类型 = 逻辑型 注释 = "删除所指定的值,返回其是否存在." 折叠 @嵌入式方法 = "">
    参数 所欲删除的值 <类型 = 模板类型1>
    {
        @ @sn<this>.data().erase (@<所欲删除的值>) > 0
    }

    方法 清空 <公开 注释 = "清除本集合中的所有内容" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().clear ()
    }

    方法 交换 <公开 注释 = "交换两个集合中的数据" 折叠 @嵌入式方法 = "">
    参数 所欲交换的集合 <类型 = 标准集合操作类>
    {
        @ @sn<this>.data().swap (@<所欲交换的集合>.data())
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回本集合是否为空" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<BOOL>(@sn<this>.data().empty ())
    }

    方法 枚举循环 <公开 注释 = "  启动一个循环来正向枚举本集合中的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值." 折叠
            @嵌入式方法 = "name = iter\r\nhas_loop_body = true">
    {
        @ @m<set>* @sn<rand_name0> = @sn<this>.pdata();
        @ for (@m<set>::iterator _vsetitr = @sn<rand_name0>->begin (); _vsetitr != @sn<rand_name0>->end (); _vsetitr++)
    }

    方法 逆向枚举循环 <公开 注释 = "  启动一个循环来逆向枚举本集合中的每一个成员,在循环中可以调用" 注释 = "\"取枚举值\"方法来获取当前所枚举到的成员值." 折叠
            @嵌入式方法 = "name = r_iter\r\nhas_loop_body = true">
    {
        @ @m<set>* @sn<rand_name0> = @sn<this>.pdata();
        @ for (@m<set>::reverse_iterator _vsetitr = @sn<rand_name0>->rbegin (); _vsetitr != @sn<rand_name0>->rend (); _vsetitr++)
    }

    方法 取枚举值 <公开 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"/\"逆向枚举循环\"语句的子语句体中使用,用作取回当前所枚举到的成员值,\r"
            注释 = "如果有多层本类或本类继承类的\"枚举循环\"/\"逆向枚举循环\"嵌套,本方法将返回最近层\"枚举循环\"/" 注释 = "\"逆向枚举循环\"所枚举到的成员值." 折叠
            @嵌入式方法 = "parent = \"iter, r_iter\"">
    {
        @ *_vsetitr
    }

    # @begin
    # <> <include>
    #     @m<set> m_set;
    #     inline_ @m<set>& data () { return m_set; }
    #     inline_ @m<set>* pdata () { return &m_set; }
    #     inline_ void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom)  { m_set = objCopyFrom.m_set; }
    #     inline_ void @an<_CopySelfFromExtra> (@sn<current_class>&& objCopyFrom)  { m_set = std::move(objCopyFrom.m_set); }
    #     inline_ BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_set == objCompare.m_set); }
    # <> </include>
    # @end
    #
}

# 排序集(std::set) ===

类 通用型排序集模板类 <公开 基础类 = 标准集合操作类 注释 = "  排序集是一种有序容器,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键时会通过红黑树比较大小,按照从小到大进行排序." 注释 = "  模板类型1: 集合的元素类型,支持已知的类型,包括基本型和\r"
        注释 = "用别名封装的对象,但提供的类型必须支持小于操作符<" 折叠 @文档 = "category = \"数据处理.排序集模板\"" @视窗.外部头文件 = "<set>" @模板基础类 = 真
        @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        变量 索引 <类型 = 整数 值 = 0>
        加入格式文本 (展示内容, "<通用型独有排序集> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 索引, 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))
            索引 = 索引 + 1

        }
    }

    # @ @def_macro set std::set<@dt<模板类型1>>
}

类 大小写无关文本排序集模板类 <公开 基础类 = 标准集合操作类 注释 = "  排序集是一种有序容器,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键时会通过红黑树比较大小,按照从小到大进行排序." 注释 = "  模板类型1: 集合的元素类型,支持类型: 文本型、\r"
        注释 = "    标准文本类、标准文本类U、标准文本类A、" 注释 = "    文本视图类、文本视图类U、文本视图类A" 折叠 @文档 = "category = \"数据处理.排序集模板\""
        @视窗.外部头文件 = "<set>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        变量 索引 <类型 = 整数 值 = 0>
        加入格式文本 (展示内容, "<大小写无关文本独有排序集> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 索引, 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))
            索引 = 索引 + 1

        }
    }

    # --
    # @begin
    # @ @def_macro set std::set<@dt<模板类型1>, NocaseLess>
    # <> <include>
    #     struct NocaseLess
    #     {
    #         bool operator()(const @dt<模板类型1>& lhs, const @dt<模板类型1>& rhs ) const { return (lhs.compare(rhs, false) < 0) ; }
    #     };
    # <> </include>
    # @end
}

# ---

类 字节独有排序集 <公开 基础类 = 通用型排序集模板类 注释 = "可以对插入的字节值进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "字节">

类 字符独有排序集 <公开 基础类 = 通用型排序集模板类 注释 = "可以对插入的字符值进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "字符">

类 整数独有排序集 <公开 基础类 = 通用型排序集模板类 注释 = "可以对插入的整数值进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "整数">

类 变整数独有排序集 <公开 基础类 = 通用型排序集模板类 注释 = "可以对插入的变整数值进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "变整数">

类 长整数独有排序集 <公开 基础类 = 通用型排序集模板类 注释 = "可以对插入的长整数值进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "长整数">

类 小数独有排序集 <公开 基础类 = 通用型排序集模板类 注释 = "可以对插入的小数值进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "小数">

类 文本独有排序集 <公开 基础类 = 通用型排序集模板类 注释 = "可以对插入的文本进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "文本型">

类 大小写无关文本独有排序集 <公开 基础类 = 大小写无关文本排序集模板类 注释 = "可以不区分大小写地对插入的文本进行去重和从小到大的排序"
        @文档 = "category = \"数据处理.排序集\"" @模板实现类 = "文本型">

类 标准文本独有排序集W <公开 基础类 = 通用型排序集模板类 注释 = "可以对插入的文本进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "标准文本类">

类 标准文本独有排序集U <公开 基础类 = 通用型排序集模板类 注释 = "可以对插入的文本进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "标准文本类U">

类 文本视图独有排序集W <公开 基础类 = 通用型排序集模板类 注释 = "可以对插入的文本进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "文本视图类">

类 文本视图独有排序集U <公开 基础类 = 通用型排序集模板类 注释 = "可以对插入的文本进行去重和从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "文本视图类U">

# 非独有排序集(std::multiset) ===

类 通用型非独有排序集模板类 <公开 基础类 = 标准集合操作类 注释 = "  非独有排序集是一种有序容器,允许多个键有等价的值.\r"
        注释 = "插入键时会通过红黑树比较大小,按照从小到大进行排序." 注释 = "  模板类型1: 集合的元素类型,支持已知的类型,包括基本型和\r"
        注释 = "用别名封装的对象,但提供的类型必须支持小于操作符<" 折叠 @文档 = "category = \"数据处理.排序集模板\"" @视窗.外部头文件 = "<set>" @模板基础类 = 真
        @输出到部件 = 假>
{
    方法 取值计数 <公开 类型 = 整数 注释 = "返回集合中与所指定的值等价的元素数" 折叠 @嵌入式方法 = "">
    参数 所欲检查的值 <类型 = 模板类型1>
    {
        @ static_cast<INT>(@sn<this>.data().count (@<所欲检查的值>))
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        变量 索引 <类型 = 整数 值 = 0>
        加入格式文本 (展示内容, "<通用型非独有排序集> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 索引, 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))
            索引 = 索引 + 1

        }
    }

    # @ @def_macro set std::multiset<@dt<模板类型1>>
}

类 大小写无关文本非独有排序集模板类 <公开 基础类 = 标准集合操作类 注释 = "  非独有排序集是一种有序容器,允许多个键有等价的值.\r"
        注释 = "插入键时会通过红黑树比较大小,按照从小到大进行排序." 注释 = "  模板类型1: 集合的元素类型,支持类型: 文本型、\r"
        注释 = "    标准文本类、标准文本类U、标准文本类A、" 注释 = "    文本视图类、文本视图类U、文本视图类A" 折叠 @文档 = "category = \"数据处理.排序集模板\""
        @视窗.外部头文件 = "<set>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取值计数 <公开 类型 = 整数 注释 = "返回集合中与所指定的值等价的元素数" 折叠 @嵌入式方法 = "">
    参数 所欲检查的值 <类型 = 模板类型1>
    {
        @ static_cast<INT>(@sn<this>.data().count (@<所欲检查的值>))
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        变量 索引 <类型 = 整数 值 = 0>
        加入格式文本 (展示内容, "<大小写无关文本非独有排序集> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 索引, 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))
            索引 = 索引 + 1

        }
    }

    # --
    # @begin
    # @ @def_macro set std::multiset<@dt<模板类型1>, NocaseLess>
    # <> <include>
    #     struct NocaseLess
    #     {
    #         bool operator()(const @dt<模板类型1>& lhs, const @dt<模板类型1>& rhs ) const { return (lhs.compare(rhs, false) < 0) ; }
    #     };
    # <> </include>
    # @end
}

# ---

类 字节排序集 <公开 基础类 = 通用型非独有排序集模板类 注释 = "可以对插入的字节值进行从小到大的排序" @文档 = "category = \"数据处理.排序集\"" @模板实现类 = "字节">

类 字符排序集 <公开 基础类 = 通用型非独有排序集模板类 注释 = "可以对插入的字符值进行从小到大的排序" @文档 = "category = \"数据处理.排序集\"" @模板实现类 = "字符">

类 整数排序集 <公开 基础类 = 通用型非独有排序集模板类 注释 = "可以对插入的整数值进行从小到大的排序" @文档 = "category = \"数据处理.排序集\"" @模板实现类 = "整数">

类 变整数排序集 <公开 基础类 = 通用型非独有排序集模板类 注释 = "可以对插入的变整数值进行从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "变整数">

类 长整数排序集 <公开 基础类 = 通用型非独有排序集模板类 注释 = "可以对插入的长整数值进行从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "长整数">

类 小数排序集 <公开 基础类 = 通用型非独有排序集模板类 注释 = "可以对插入的小数值进行从小到大的排序" @文档 = "category = \"数据处理.排序集\"" @模板实现类 = "小数">

类 文本排序集 <公开 基础类 = 通用型非独有排序集模板类 注释 = "可以对插入的文本进行从小到大的排序" @文档 = "category = \"数据处理.排序集\"" @模板实现类 = "文本型">

类 大小写无关文本排序集 <公开 基础类 = 大小写无关文本非独有排序集模板类 注释 = "可以不区分大小写地对插入的文本进行从小到大的排序" @文档 = "category = \"数据处理.排序集\""
        @模板实现类 = "文本型">

# 哈希集(std::unordered_set) ===

类 基本型哈希集模板类 <公开 基础类 = 标准集合操作类 注释 = "  非独有哈希集是一种无序容器,允许多个键有等价的值." 注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,\r"
        注释 = "实现快速访问." 注释 = "  模板类型1: 集合的元素类型,仅支持非文本基本型" 折叠 @文档 = "category = \"数据处理.哈希集模板\""
        @视窗.外部头文件 = "<unordered_set>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        变量 索引 <类型 = 整数 值 = 0>
        加入格式文本 (展示内容, "<基本型哈希集> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 索引, 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))
            索引 = 索引 + 1

        }
    }

    # @ @def_macro set std::unordered_set<@dt<模板类型1>>
}

类 文本哈希集模板类 <公开 基础类 = 标准集合操作类 注释 = "  非独有哈希集是一种无序容器,允许多个键有等价的值." 注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,\r"
        注释 = "实现快速访问." 注释 = "  模板类型1: 集合的元素类型,支持类型: 文本型、字节集类" 注释 = "    标准文本类、标准文本类U、标准文本类A、\r"
        注释 = "    文本视图类、文本视图类U、文本视图类A" 折叠 @文档 = "category = \"数据处理.哈希集模板\"" @视窗.外部头文件 = "<unordered_set>"
        @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        变量 索引 <类型 = 整数 值 = 0>
        加入格式文本 (展示内容, "<文本哈希集> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 索引, 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))
            索引 = 索引 + 1

        }
    }

    # --
    # @begin
    # @def_macro set std::unordered_set<@dt<模板类型1>, HashFunc>
    # <> <include>
    #     struct HashFunc
    #     {
    #         size_t operator()(const @dt<模板类型1>& key) const { return key.GetHash(); }
    #     };
    # <> </include>
    # @end
}

类 大小写无关文本哈希集模板类 <公开 基础类 = 标准集合操作类 注释 = "  非独有哈希集是一种无序容器,允许多个键有等价的值.\r"
        注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标," 注释 = "实现快速访问." 注释 = "  模板类型1: 集合的元素类型,支持类型: 文本型、\r"
        注释 = "    标准文本类、标准文本类U、标准文本类A、" 注释 = "    文本视图类、文本视图类U、文本视图类A" 折叠 @文档 = "category = \"数据处理.哈希集模板\""
        @视窗.外部头文件 = "<unordered_set>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        变量 索引 <类型 = 整数 值 = 0>
        加入格式文本 (展示内容, "<大小写无关文本哈希集> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 索引, 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))
            索引 = 索引 + 1

        }
    }

    # --
    # @begin
    # @def_macro set std::unordered_set<@dt<模板类型1>, HashFunc, KeyEqualFunc>
    # <> <include>
    #     struct HashFunc
    #     {
    #         size_t operator()(const @dt<模板类型1>& key) const { return key.GetIHash(); }
    #     };
    #     struct KeyEqualFunc
    #     {
    #         bool operator()(const @dt<模板类型1>& lhs, const @dt<模板类型1>& rhs ) const { return lhs.IIsEqual(rhs); }
    #     };
    # <> </include>
    # @end
}

# 非独有哈希集(std::unordered_multiset) ===

类 基本型非独有哈希集模板类 <公开 基础类 = 标准集合操作类 注释 = "  哈希集是一种无序容器,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,实现" 注释 = "快速访问." 注释 = "  模板类型1: 集合的元素类型,仅支持非文本基本型" 折叠
        @文档 = "category = \"数据处理.哈希集模板\"" @视窗.外部头文件 = "<unordered_set>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取值计数 <公开 类型 = 整数 注释 = "返回集合中与所指定的值等价的元素数" 折叠 @嵌入式方法 = "">
    参数 所欲检查的值 <类型 = 模板类型1>
    {
        @ static_cast<INT>(@sn<this>.data().count (@<所欲检查的值>))
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        变量 索引 <类型 = 整数 值 = 0>
        加入格式文本 (展示内容, "<基本型非独有哈希集> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 索引, 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))
            索引 = 索引 + 1

        }
    }

    # @ @def_macro set std::unordered_multiset<@dt<模板类型1>>
}

类 文本非独有哈希集模板类 <公开 基础类 = 标准集合操作类 注释 = "  哈希集是一种无序容器,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,实现" 注释 = "快速访问." 注释 = "  模板类型1: 集合的元素类型,支持类型: 文本型、字节集类\r"
        注释 = "    标准文本类、标准文本类U、标准文本类A、" 注释 = "    文本视图类、文本视图类U、文本视图类A" 折叠 @文档 = "category = \"数据处理.哈希集模板\""
        @视窗.外部头文件 = "<unordered_set>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取值计数 <公开 类型 = 整数 注释 = "返回集合中与所指定的值等价的元素数" 折叠 @嵌入式方法 = "">
    参数 所欲检查的值 <类型 = 模板类型1>
    {
        @ static_cast<INT>(@sn<this>.data().count (@<所欲检查的值>))
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        变量 索引 <类型 = 整数 值 = 0>
        加入格式文本 (展示内容, "<文本非独有哈希集> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 索引, 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))
            索引 = 索引 + 1

        }
    }

    # --
    # @begin
    # @def_macro set std::unordered_multiset<@dt<模板类型1>, HashFunc>
    # <> <include>
    #     struct HashFunc
    #     {
    #         size_t operator()(const @dt<模板类型1>& key) const { return key.GetHash(); }
    #     };
    # <> </include>
    # @end
}

类 大小写无关文本非独有哈希集模板类 <公开 基础类 = 标准集合操作类 注释 = "  哈希集是一种无序容器,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键时会计算键的哈希值,之后将键的哈希值作为下标,实现" 注释 = "快速访问." 注释 = "  模板类型1: 集合的元素类型,支持类型: 文本型、\r"
        注释 = "    标准文本类、标准文本类U、标准文本类A、" 注释 = "    文本视图类、文本视图类U、文本视图类A" 折叠 @文档 = "category = \"数据处理.哈希集模板\""
        @视窗.外部头文件 = "<unordered_set>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取值计数 <公开 类型 = 整数 注释 = "返回集合中与所指定的值等价的元素数" 折叠 @嵌入式方法 = "">
    参数 所欲检查的值 <类型 = 模板类型1>
    {
        @ static_cast<INT>(@sn<this>.data().count (@<所欲检查的值>))
    }

    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        变量 索引 <类型 = 整数 值 = 0>
        加入格式文本 (展示内容, "<大小写无关文本非独有哈希集> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "%d. %s\r\n", 索引, 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))
            索引 = 索引 + 1

        }
    }

    # --
    # @begin
    # @def_macro set std::unordered_multiset<@dt<模板类型1>, HashFunc, KeyEqualFunc>
    # <> <include>
    #     struct HashFunc
    #     {
    #         size_t operator()(const @dt<模板类型1>& key) const { return key.GetIHash(); }
    #     };
    #     struct KeyEqualFunc
    #     {
    #         bool operator()(const @dt<模板类型1>& lhs, const @dt<模板类型1>& rhs ) const { return lhs.IIsEqual(rhs); }
    #     };
    # <> </include>
    # @end
}

#
#
#
# 键值表容器 基本操作====

类 标准通用型键值表操作类 <公开 基础类 = 扩展对象类 注释 = "封装了键值表容器的基本操作,请勿直接使用本类." 注释 = "  模板类型1: 为键值表的关键字\r"
        注释 = "  模板类型2: 为键值表的对应值,支持已知的类型," 注释 = "包括基本型和用别名封装的对象,比如字节集类" 折叠 @文档 = "category = \"数据处理.基础模板类\""
        @模板基础类 = 真>
{
    方法 插入 <公开 注释 = "  插入一个键值对进键值表中,如果所指定关键字已经存在,则其所对应的" 注释 = "先前值数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 对应值 <类型 = 模板类型2 注释 = "  提供关键字所对应的火山类对象,类库将会创建一个新的同实际数据类型" 注释 = "对象然后将其内容复制进去后插入键值表.">
    {
        @ @sn<this>.data() [@<关键字>] = @<对应值>
    }

    方法 唯一性插入 <公开 类型 = 逻辑型 注释 = "插入一个键值对进键值表中,如果所指定关键字已经存在,则返回失败." 返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假." 折叠
            @嵌入式方法 = "">
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 对应值 <类型 = 模板类型2 注释 = "  提供关键字所对应的火山类对象,类库将会创建一个新的同实际数据类型" 注释 = "对象然后将其内容复制进去后插入键值表.">
    {
        @ @sn<this>.data().insert (@m<map>::value_type (@<关键字>, @<对应值>)).second
    }

    方法 取值 <公开 类型 = 模板类型2 注释 = "  返回所指定关键字在本键值表中所对应值的参考,如果该关键字不存在,将新\r"
            注释 = "建一个数据类型为\"模板类型2\"的空值,并将其插入键值表中后返回." 注释 = "  注意: 如果\"模板类型2\"是对象,而且需要动态挂接事件,请按类似以下格式挂接:\r"
            注释 = "    挂接事件 (表1.取值 (关键字))" 注释 = "  因为火山视窗的赋值操作采用的是值复制方式,所以如果将返回对象赋值到另一\r"
            注释 = "个变量后再挂接这个变量的话,将导致事件挂接在一个复制出来的对象上而不是所" 注释 = "期望的键值表中保存的对象." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ static_cast<@dt<模板类型2>&>(@sn<this>.data() [@<关键字>])
    }

    方法 取成员数 <公开 类型 = 整数 注释 = "返回本键值表中已有键值对成员的数目" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().size ())
    }

    方法 是否存在 <公开 类型 = 逻辑型 注释 = "返回所指定的关键字是否已经存在" 折叠 @禁止流程检查 = 真>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ return (data().find (@<关键字>) != data().end ());
    }

    方法 删除 <公开 类型 = 逻辑型 注释 = "删除所指定的键值对,返回是否存在所指定的关键字." 折叠 @嵌入式方法 = "">
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ @sn<this>.data().erase (@<关键字>) > 0
    }

    方法 清空 <公开 注释 = "清除本键值表中的所有内容" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().clear ()
    }

    方法 交换 <公开 注释 = "交换两个键值表中的数据" 折叠 @嵌入式方法 = "">
    参数 所欲交换的键值表 <类型 = 标准通用型键值表操作类>
    {
        @ @sn<this>.data().swap (@<所欲交换的键值表>.data())
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回本键值表是否为空" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<BOOL>(@sn<this>.data().empty ())
    }

    方法 枚举循环 <公开 注释 = "  启动一个循环来正向枚举本键值表中的每一个成员,在循环中可以调用" 注释 = "\"取枚举关键字\"/\"取枚举值\"方法来获取当前所枚举到键值对的关键字及\r"
            注释 = "其对应值." 折叠 @嵌入式方法 = "name = iter\r\nhas_loop_body = true">
    {
        @ @m<map>* @sn<rand_name0> = @sn<this>.pdata();
        @ for (@m<map>::iterator _pivmapitr_@dt<模板类型1> = @sn<rand_name0>->begin (); _pivmapitr_@dt<模板类型1> != @sn<rand_name0>->end (); _pivmapitr_@dt<模板类型1>++)
    }

    方法 逆向枚举循环 <公开 注释 = "  启动一个循环来逆向枚举本键值表中的每一个成员,在循环中可以调用\r"
            注释 = "\"取枚举关键字\"/\"取枚举值\"方法来获取当前所枚举到键值对的关键字及" 注释 = "其对应值." 折叠
            @嵌入式方法 = "name = riter\r\nhas_loop_body = true">
    {
        @ @m<map>* @sn<rand_name0> = @sn<this>.pdata();
        @ for (@m<map>::reverse_iterator _pivmapitr_@dt<模板类型1> = @sn<rand_name0>->rbegin (); _pivmapitr_@dt<模板类型1> != @sn<rand_name0>->rend (); _pivmapitr_@dt<模板类型1>++)
    }

    方法 取枚举关键字 <公开 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前所枚举到键值对\r"
            注释 = "成员的关键字,如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回最近" 注释 = "层\"枚举循环\"所枚举到键值对成员的关键字." 折叠
            @嵌入式方法 = "parent = \"iter,riter\"" @视窗.返回参考 = 真>
    {
        @ _pivmapitr_@dt<模板类型1>->first
    }

    方法 取枚举值 <公开 类型 = 模板类型2 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前所枚举到键值对\r"
            注释 = "成员的值,如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回最近层" 注释 = "\"枚举循环\"所枚举到键值对成员的值." 折叠
            @嵌入式方法 = "parent = \"iter,riter\"" @视窗.返回参考 = 真>
    {
        @ _pivmapitr_@dt<模板类型1>->second
    }

    # @begin
    # <> <include>
    #     @m<map> m_map;
    #     inline_ @m<map>& data () { return m_map; }
    #     inline_ @m<map>* pdata () { return &m_map; }
    #     inline_ void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom)  { m_map = objCopyFrom.m_map; }
    #     inline_ void @an<_CopySelfFromExtra> (@sn<current_class>&& objCopyFrom)  { m_map = std::move(objCopyFrom.m_map); }
    #     inline_ BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_map == objCompare.m_map); }
    # <> </include>
    # @end
}

类 标准对象类键值表操作类 <公开 基础类 = 扩展对象类 注释 = "封装了键值表容器的基本操作,请勿直接使用本类." 注释 = "  模板类型1: 为键值表的关键字\r"
        注释 = "  模板类型2: 为键值表的对应值,必须是基于对象类" 注释 = "的类型,比如自定义的对象或数组类" 折叠 @文档 = "category = \"数据处理.基础模板类\""
        @视窗.外部头文件 = "<unordered_map>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 插入 <公开 注释 = "  插入一个键值对进键值表中,如果所指定关键字已经存在,则其所对应的" 注释 = "先前值数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 对应值 <类型 = 模板类型2 注释 = "  提供关键字所对应的火山类对象,类库将会创建一个新的同实际数据类型" 注释 = "对象然后将其内容复制进去后插入键值表.">
    {
        @ @sn<this>.data() [@<关键字>] = CVolWrapperObject (@<对应值>)
    }

    方法 唯一性插入 <公开 类型 = 逻辑型 注释 = "插入一个键值对进键值表中,如果所指定关键字已经存在,则返回失败." 返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假." 折叠
            @嵌入式方法 = "">
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    参数 对应值 <类型 = 模板类型2 注释 = "  提供关键字所对应的火山类对象,类库将会创建一个新的同实际数据类型" 注释 = "对象然后将其内容复制进去后插入键值表.">
    {
        @ @sn<this>.data().insert (@m<map>::value_type (@<关键字>, CVolWrapperObject (@<对应值>))).second
    }

    方法 取值 <公开 类型 = 模板类型2 注释 = "  返回所指定关键字在本键值表中所对应类对象的参考,如果该关键字不存在,将新\r"
            注释 = "建一个数据类型为\"对象类\"的空对象(其\"是否为空对象\"方法返回真)并将其插入哈" 注释 = "希表中后返回.\r"
            注释 = "  注意: 如果所获取对象需要动态挂接事件,请按类似以下格式挂接:" 注释 = "    挂接事件 ((对象实际数据类型)键值表1.取值 (关键字))\r"
            注释 = "  因为火山视窗的赋值操作采用的是值复制方式,所以如果将返回对象赋值到另一" 注释 = "个变量后再挂接这个变量的话,将导致事件挂接在一个复制出来的对象上而不是所\r"
            注释 = "期望的键值表中保存的对象." 折叠 @嵌入式方法 = "" @视窗.返回参考 = 真>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ (@dt<模板类型2>&)@sn<this>.data() [@<关键字>].GetVolObject (VOL_RUNTIME_CLASS (@dt<模板类型2>), @dt<模板类型2> ())
    }

    方法 插入新对象 <公开 注释 = "  插入一个键值对进键值表中,如果所指定关键字已经存在,则其所对应的" 注释 = "先前值数据将被覆盖." 折叠 @嵌入式方法 = "">
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ @sn<this>.data() [@<关键字>] = CVolWrapperObject (VOL_RUNTIME_CLASS(@dt<模板类型2>))
    }

    方法 唯一性插入新对象 <公开 类型 = 逻辑型 注释 = "插入一个键值对进键值表中,如果所指定关键字已经存在,则返回失败." 返回值注释 = "所欲插入关键字如果不存在,则成功返回真,否则返回假."
            折叠 @嵌入式方法 = "">
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ @sn<this>.data().insert (@m<map>::value_type (@<关键字>, CVolWrapperObject (VOL_RUNTIME_CLASS(@dt<模板类型2>))).second
    }

    方法 取成员数 <公开 类型 = 整数 注释 = "返回本键值表中已有键值对成员的数目" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<INT>(@sn<this>.data().size ())
    }

    方法 是否存在 <公开 类型 = 逻辑型 注释 = "返回所指定的关键字是否已经存在" 折叠 @禁止流程检查 = 真>
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ return (data().find (@<关键字>) != data().end ());
    }

    方法 删除 <公开 类型 = 逻辑型 注释 = "删除所指定的键值对,返回是否存在所指定的关键字." 折叠 @嵌入式方法 = "">
    参数 关键字 <类型 = 模板类型1 注释 = "提供所对应的关键字">
    {
        @ @sn<this>.data().erase (@<关键字>) > 0
    }

    方法 清空 <公开 注释 = "清除本键值表中的所有内容" 折叠 @嵌入式方法 = "">
    {
        @ @sn<this>.data().clear ()
    }

    方法 交换 <公开 注释 = "交换两个键值表中的数据" 折叠 @嵌入式方法 = "">
    参数 所欲交换的键值表 <类型 = 标准对象类键值表操作类>
    {
        @ @sn<this>.data().swap (@<所欲交换的键值表>.data())
    }

    方法 是否为空 <公开 类型 = 逻辑型 注释 = "返回本键值表是否为空" 折叠 @嵌入式方法 = "">
    {
        @ static_cast<BOOL>(@sn<this>.data().empty ())
    }

    方法 枚举循环 <公开 注释 = "  启动一个循环来正向枚举本键值表中的每一个成员,在循环中可以调用" 注释 = "\"取枚举关键字\"/\"取枚举值\"方法来获取当前所枚举到键值对的关键字及\r"
            注释 = "其对应值." 折叠 @嵌入式方法 = "name = iter\r\nhas_loop_body = true">
    {
        @ @m<map>* @sn<rand_name0> = @sn<this>.pdata();
        @ for (@m<map>::iterator _pivmapitr_@dt<模板类型1> = @sn<rand_name0>->begin (); _pivmapitr_@dt<模板类型1> != @sn<rand_name0>->end (); _pivmapitr_@dt<模板类型1>++)
    }

    方法 逆向枚举循环 <公开 注释 = "  启动一个循环来逆向枚举本键值表中的每一个成员,在循环中可以调用\r"
            注释 = "\"取枚举关键字\"/\"取枚举值\"方法来获取当前所枚举到键值对的关键字及" 注释 = "其对应值." 折叠
            @嵌入式方法 = "name = riter\r\nhas_loop_body = true">
    {
        @ @m<map>* @sn<rand_name0> = @sn<this>.pdata();
        @ for (@m<map>::reverse_iterator _pivmapitr_@dt<模板类型1> = @sn<rand_name0>->rbegin (); _pivmapitr_@dt<模板类型1> != @sn<rand_name0>->rend (); _pivmapitr_@dt<模板类型1>++)
    }

    方法 取枚举关键字 <公开 类型 = 模板类型1 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前所枚举到键值对\r"
            注释 = "成员的关键字,如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回最近" 注释 = "层\"枚举循环\"所枚举到键值对成员的关键字." 折叠
            @嵌入式方法 = "parent = \"iter,riter\"" @视窗.返回参考 = 真>
    {
        @ _pivmapitr_@dt<模板类型1>->first
    }

    方法 取枚举值 <公开 类型 = 模板类型2 注释 = "  只能在本类的\"枚举循环\"语句的子语句体中使用,用作取回当前所枚举到键值对\r"
            注释 = "成员的值,如果有多层本类或本类继承类的\"枚举循环\"嵌套,本方法将返回最近层" 注释 = "\"枚举循环\"所枚举到键值对成员的值." 折叠
            @嵌入式方法 = "parent = \"iter,riter\"" @视窗.返回参考 = 真>
    {
        @ (@dt<模板类型2>&)_pivmapitr_@dt<模板类型1>->second.GetVolObject (VOL_RUNTIME_CLASS (@dt<模板类型2>), @dt<模板类型2> ())
    }

    # --
    # @begin
    # <> <include>
    #     @m<map> m_map;
    #     inline_ @m<map>& data () { return m_map; }
    #     inline_ @m<map>* pdata () { return &m_map; }
    #     inline_ void @an<_CopySelfFromExtra> (const @sn<current_class>& objCopyFrom)  { m_map = objCopyFrom.m_map; }
    #     inline_ void @an<_CopySelfFromExtra> (@sn<current_class>&& objCopyFrom)  { m_map = std::move(objCopyFrom.m_map); }
    #     inline_ BOOL @an<_IsSelfEqualExtra> (const @sn<current_class>& objCompare) const { return (m_map == objCompare.m_map); }
    # <> </include>
    # @end
}

# 排序表(std::map) ===

类 通用型到通用型排序表模板类 <公开 基础类 = 标准通用型键值表操作类 注释 = "  排序表是一种有序的键值表,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键值对时会通过红黑树比较键的大小,按照从小到大进行排序." 注释 = "  模板类型1: 为键值表的关键字,支持已知的类型,包括基本型和\r"
        注释 = "用别名封装的对象,但提供的类型必须支持小于操作符<" 注释 = "  模板类型2: 为键值表的对应值,支持已知的类型,包括基本型和" 注释 = "用别名封装的对象,比如字节集类"
        折叠 @文档 = "category = \"数据处理.排序表模板\"" @视窗.外部头文件 = "<map>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<通用型到通用型独有排序表> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "关键字: %s; 对应值: %s\r\n", 取调试文本2 (最大展示数据尺寸, 取枚举关键字 ()), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # @ @def_macro map std::map<@dt<模板类型1>, @dt<模板类型2>>
}

类 通用型到对象排序表模板类 <公开 基础类 = 标准对象类键值表操作类 注释 = "  排序表是一种有序的键值表,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键值对时会通过红黑树比较键的大小,按照从小到大进行排序." 注释 = "  模板类型1: 为键值表的关键字,支持已知的类型,包括基本型和\r"
        注释 = "用别名封装的对象,但提供的类型必须支持小于操作符<" 注释 = "  模板类型2: 为键值表的对应值,支持已知的类型,包括基本型和" 注释 = "用别名封装的对象,比如字节集类"
        折叠 @文档 = "category = \"数据处理.排序表模板\"" @视窗.外部头文件 = "<map>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<通用型到对象独有排序表> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "关键字: %s; 对应值: %s\r\n", 取调试文本2 (最大展示数据尺寸, 取枚举关键字 ()), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # @ @def_macro map std::map<@dt<模板类型1>, CVolWrapperObject>
}

类 大小写无关文本到通用型排序表模板类 <公开 基础类 = 标准通用型键值表操作类 注释 = "  排序表是一种有序的键值表,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键值对时会通过红黑树比较键的大小,按照从小到大进行排序." 注释 = "  模板类型1: 为键值表的关键字,支持类型: 文本型、\r"
        注释 = "    标准文本类、标准文本类U、标准文本类A、" 注释 = "    文本视图类、文本视图类U、文本视图类A\r"
        注释 = "  模板类型2: 为键值表的对应值,支持已知的类型,包括基本型和" 注释 = "用别名封装的对象,比如字节集类" 折叠 @文档 = "category = \"数据处理.排序表模板\""
        @视窗.外部头文件 = "<map>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<大小写无关文本到通用型独有排序表> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "关键字: %s; 对应值: %s\r\n", 取调试文本2 (最大展示数据尺寸, 取枚举关键字 ()), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # --
    # @begin
    # @def_macro map std::map<@dt<模板类型1>, @dt<模板类型2>, NocaseLess>
    # <> <include>
    #     struct NocaseLess
    #     {
    #         bool operator()(const @dt<模板类型1>& lhs, const @dt<模板类型1>& rhs ) const { return (lhs.compare(rhs, false) < 0) ; }
    #     };
    # <> </include>
    # @end
}

类 大小写无关文本到对象排序表模板类 <公开 基础类 = 标准对象类键值表操作类 注释 = "  排序表是一种有序的键值表,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键值对时会通过红黑树比较键的大小,按照从小到大进行排序." 注释 = "  模板类型1: 为键值表的关键字,支持类型: 文本型、\r"
        注释 = "    标准文本类、标准文本类U、标准文本类A、" 注释 = "    文本视图类、文本视图类U、文本视图类A\r"
        注释 = "  模板类型2: 为键值表的对应值,必须是基于对象类的类型,比如" 注释 = "自定义的对象或数组类" 折叠 @文档 = "category = \"数据处理.排序表模板\""
        @视窗.外部头文件 = "<map>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<大小写无关文本到对象独有排序表> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "关键字: %s; 对应值: %s\r\n", 取调试文本2 (最大展示数据尺寸, 取枚举关键字 ()), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # --
    # @begin
    # @def_macro map std::map<@dt<模板类型1>, CVolWrapperObject, NocaseLess>
    # <> <include>
    #     struct NocaseLess
    #     {
    #         bool operator()(const @dt<模板类型1>& lhs, const @dt<模板类型1>& rhs ) const { return (lhs.compare(rhs, false) < 0) ; }
    #     };
    # <> </include>
    # @end
}

# 哈希表(std::unordered_map) ===

类 基本型到通用型哈希表模板类 <公开 基础类 = 标准通用型键值表操作类 注释 = "  哈希表是一种无序的键值表,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键值对时会计算键的哈希值,之后将键的哈希值作为下标,实现" 注释 = "快速访问表元素的能力,当数据量比较大时,哈希表通常比\"排序表\"" 注释 = "要快一些.\r"
        注释 = "  模板类型1: 为键值表的关键字,仅支持非文本基本型" 注释 = "  模板类型2: 为键值表的对应值,支持已知的类型,包括基本型和" 注释 = "用别名封装的对象,比如字节集类"
        折叠 @文档 = "category = \"数据处理.哈希表模板\"" @视窗.外部头文件 = "<unordered_map>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<基本型到通用型独有哈希表> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "关键字: %s; 对应值: %s\r\n", 取调试文本2 (最大展示数据尺寸, 取枚举关键字 ()), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # @ @def_macro map std::unordered_map<@dt<模板类型1>, @dt<模板类型2>>
}

类 文本到通用型哈希表模板类 <公开 基础类 = 标准通用型键值表操作类 注释 = "  哈希表是一种无序的键值表,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键值对时会计算键的哈希值,之后将键的哈希值作为下标,实现" 注释 = "快速访问表元素的能力,当数据量比较大时,哈希表通常比\"排序表\"" 注释 = "要快一些.\r"
        注释 = "  模板类型1: 为键值表的关键字,支持类型: 文本型、字节集类、" 注释 = "    标准文本类、标准文本类U、标准文本类A、\r"
        注释 = "    文本视图类、文本视图类U、文本视图类A" 注释 = "  模板类型2: 为键值表的对应值,支持已知的类型,包括基本型和" 注释 = "用别名封装的对象,比如字节集类" 折叠
        @文档 = "category = \"数据处理.哈希表模板\"" @视窗.外部头文件 = "<unordered_map>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<文本到通用型独有哈希表> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "关键字: %s; 对应值: %s\r\n", 取调试文本2 (最大展示数据尺寸, 取枚举关键字 ()), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # --
    # @begin
    # @def_macro map std::unordered_map<@dt<模板类型1>, @dt<模板类型2>, HashFunc>
    # <> <include>
    #     struct HashFunc
    #     {
    #         size_t operator()(const @dt<模板类型1>& key) const { return key.GetHash(); }
    #     };
    # <> </include>
    # @end
}

类 文本到对象哈希表模板类 <公开 基础类 = 标准对象类键值表操作类 注释 = "  哈希表是一种无序的键值表,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键值对时会计算键的哈希值,之后将键的哈希值作为下标,实现" 注释 = "快速访问表元素的能力,当数据量比较大时,哈希表通常比\"排序表\"" 注释 = "要快一些.\r"
        注释 = "  模板类型1: 为键值表的关键字,支持类型: 文本型、字节集类、" 注释 = "    标准文本类、标准文本类U、标准文本类A、\r"
        注释 = "    文本视图类、文本视图类U、文本视图类A" 注释 = "  模板类型2: 为键值表的对应值,必须是基于对象类的类型,比如" 注释 = "自定义的对象或数组类" 折叠
        @文档 = "category = \"数据处理.哈希表模板\"" @视窗.外部头文件 = "<unordered_map>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<文本到对象独有哈希表> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "关键字: %s; 对应值: %s\r\n", 取调试文本2 (最大展示数据尺寸, 取枚举关键字 ()), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # --
    # @begin
    # @def_macro map std::unordered_map<@dt<模板类型1>, CVolWrapperObject>, HashFunc>
    # <> <include>
    #     struct HashFunc
    #     {
    #         size_t operator()(const @dt<模板类型1>& key) const { return key.GetHash(); }
    #     };
    # <> </include>
    # @end
}

类 大小写无关文本到通用型哈希表模板类 <公开 基础类 = 标准通用型键值表操作类 注释 = "  对比\"文本到通用型哈希表模板类\",本模板插入和寻找键值对时,\r"
        注释 = "不区分文本键的英文大小写." 注释 = "  哈希表是一种无序的键值表,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键值对时会计算键的哈希值,之后将键的哈希值作为下标,实现" 注释 = "快速访问表元素的能力,当数据量比较大时,哈希表通常比\"排序表\"" 注释 = "要快一些.\r"
        注释 = "  模板类型1: 为键值表的关键字,支持类型: 文本型、" 注释 = "    标准文本类、标准文本类U、标准文本类A、\r"
        注释 = "    文本视图类、文本视图类U、文本视图类A" 注释 = "  模板类型2: 为键值表的对应值,支持已知的类型,包括基本型和" 注释 = "用别名封装的对象,比如字节集类" 折叠
        编辑时信息 = "46A32, 0, 0, 0" @文档 = "category = \"数据处理.哈希表模板\"" @视窗.外部头文件 = "<unordered_map>" @模板基础类 = 真
        @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<大小写无关文本到通用型独有哈希表> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "关键字: %s; 对应值: %s\r\n", 取调试文本2 (最大展示数据尺寸, 取枚举关键字 ()), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # --
    # @begin
    # @def_macro map std::unordered_map<@dt<模板类型1>, @dt<模板类型2>, HashFunc, KeyEqualFunc>
    # <> <include>
    #     struct HashFunc
    #     {
    #         size_t operator()(const @dt<模板类型1>& key) const { return key.GetIHash(); }
    #     };
    #     struct KeyEqualFunc
    #     {
    #         bool operator()(const @dt<模板类型1>& lhs, const @dt<模板类型1>& rhs ) const { return lhs.IIsEqual(rhs); }
    #     };
    # <> </include>
    # @end
}

类 大小写无关文本到对象哈希表模板类 <公开 基础类 = 标准对象类键值表操作类 注释 = "  对比\"文本到对象哈希表模板类\",本模板插入和寻找键值对时,\r"
        注释 = "不区分文本键的英文大小写." 注释 = "  哈希表是一种无序的键值表,因为键的唯一性,天然具有去重功能.\r"
        注释 = "插入键值对时会计算键的哈希值,之后将键的哈希值作为下标,实现" 注释 = "快速访问表元素的能力,当数据量比较大时,哈希表通常比\"排序表\"" 注释 = "要快一些.\r"
        注释 = "  模板类型1: 为键值表的关键字,支持类型: 文本型、" 注释 = "    标准文本类、标准文本类U、标准文本类A、\r"
        注释 = "    文本视图类、文本视图类U、文本视图类A" 注释 = "  模板类型2: 为键值表的对应值,必须是基于对象类的类型,比如" 注释 = "自定义的对象或数组类" 折叠
        @文档 = "category = \"数据处理.哈希表模板\"" @视窗.外部头文件 = "<unordered_map>" @模板基础类 = 真 @输出到部件 = 假>
{
    方法 取展示内容 <公开 注释 = "将本对象中的所有数据用文本方式填入到所提供的文本参数中,用作调试或其它场合展示时使用." 注释 = "" 折叠 @虚拟方法 = 可覆盖>
    参数 展示内容 <类型 = 文本型 注释 = "用作填入本对象中所有数据的展示文本">
    参数 最大展示数据尺寸 <类型 = 整数 注释 = "提供用户所指定的最大允许展示数据尺寸,小于0表示全部展示,等于0表示展示默认尺寸数据.">
    {
        加入格式文本 (展示内容, "<大小写无关文本到对象独有哈希表> 成员数: %d\r\n", 取成员数 ())
        枚举循环 ()
        {
            加入格式文本 (展示内容, "关键字: %s; 对应值: %s\r\n", 取调试文本2 (最大展示数据尺寸, 取枚举关键字 ()), 取调试文本2 (最大展示数据尺寸, 取枚举值 ()))

        }
    }

    # --
    # @begin
    # @def_macro map std::unordered_map<@dt<模板类型1>, CVolWrapperObject, HashFunc, KeyEqualFunc>
    # <> <include>
    #     struct HashFunc
    #     {
    #         size_t operator()(const @dt<模板类型1>& key) const { return static_cast<size_t>(key.GetIHash()); }
    #     };
    #     struct KeyEqualFunc
    #     {
    #         bool operator()(const @dt<模板类型1>& lhs, const @an<CVolString>& rhs ) const { return lhs.IIsEqual(rhs); }
    #     };
    # <> </include>
    # @end
}

#
